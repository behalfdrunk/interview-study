---
typora-root-url: images
typora-copy-images-to: images
---





# 计算机基础

## 一、计算机网络

### 1、计算机网络模型

#### 1）OSI七层模型

<img src="/image-20210904163713455.png" alt="image-20210904163713455" style="zoom:80%;" />

1、物理层：实现计算机节点之间**比特流**的透明传输，屏蔽掉具体传输介质和物理设备的差异。

2、数据链路层：几个基本方法：

数据封装成桢：把网络层数据报加头和尾，封装成帧，帧头中包括**源MAC地址和目的MAC地址**。
透明传输：零比特填充、转义字符。
差错控制：接收者检测错误,如果发现差错，丢弃该帧，差错控制方法有 CRC 循环冗余码
流量控制：控制发送的传输速度，使得接收方来得及接收。传输层TCP也有流量控制功能，但TCP是端到端的流量控制，链路层是点到点（路由器到路由器）
3、网络层：实现**网络地址与物理地址**的转换，并通过路由选择算法为分组通过通信子网选择最适当的路由。路由一般包括**路由表和路由算法**两个方面。

4、传输层：提供源端与目的端之间提供可靠的透明数据传输。传输层协议负责的是提供进程间的逻辑通信；网络层协议负责的是提供主机间的逻辑通信；

5、会话层：是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持、终止通信。

6、表示层：处理用户数据的表示问题，如数据的编码、格式转换、加密和解密、压缩和解压缩。

7、应用层：为用户的应用进程提供网络通信服务，完成和实现用户请求的各种服务。

#### 2）TCP/IP结构模型

OSI 是一个理论上的网络通信模型；而 TCP/IP协议模型（Transmission Control Protocol/Internet Protocol） 是实际上的网络通信标准。

TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程，入栈数据发送方每层不断地封装首部与尾部，添加传输信息确保能传输到目的地，而出栈相反。

![image-20210904173837339](/image-20210904173837339.png)

### 2、网络层

实现网络地址与物理地址的转换，并通过路由选择算法为分组通过通信子网选择最适当的路径

#### 1）物理地址与IP地址

物理地址是数据链路层和物理层使用的地址，IP地址是网络层及以上使用的地址，是一种逻辑地址，其中ARP协议将**IP地址转换成物理地址**。

#### 2）ARP协议的工作原理

ARP 地址解析协议 是**根据 IP 地址获取 MAC 地址**的一种协议，核心原理就是**广播发送ARP请求，单播发送ARP响应**

（1）每个主机都在自己的ARP缓冲区中建立一个ARP列表，保存着 IP 地址和 MAC 地址之间的对应关系。
（2）当源主机要发送数据时，先检查ARP列表中是否有该 IP 地址对应的 MAC 地址，如果有，   则直接发送数据；如果没有，就向本网段所有主机发送ARP数据包，用于查询目的主机的MAC地址，该数据包包括的内容有：**源主机IP地址，源主机MAC地址，目的主机的IP**。
（3）当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
（4）源主机收到 ARP 响应包后，将目的主机的 IP 和 MAC 地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败

例：ping 120.92.172.136  过程中涉及到的协议是ARP协议。

#### 3）RARP协议

RARP是逆地址解析协议，作用是完成 **硬件地址到IP地址的**映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在**网络中配置一台RARP服务器**，里面保存着 MAC 地址和 IP 地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。

#### 4）DHCP协议

**动态主机配置协议**是一个局域网的网络协议，**使用UDP协议工作**，对 IP地址进行集中管理和分配，提升地址的使用率。可以**使客户机自动获得服务器分配的lP地址和子网掩码**

![img](/483d3398a02c591211d94b475d64144e.png)

#### 5）ICMP协议

**英特网控制报文协议**，用于在IP主机、路由器之间传递控制消息（控制消息是指网络通不通、主机是否可达、路由器是否可用等网络本身的消息），**确认 IP 包是否成功到达目标地址。**因为 **IP 协议并不是一个可靠的协议**，它不保证数据被送达，当传送IP数据包发生错误，比如主机不可达、路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机，给主机一个处理错误的机会。

ICMP报文有两种：差错报告报文和询问报文。以下是4种常见的ICMP差错报告报文

<img src="/8ca290c48e6766ce5ade5b6b542b10d9.png" alt="img" style="zoom: 25%;" />

#### 6）交换机与路由器的区别

（1）**交换机工作在OSI第二层数据链路层，路由器工作在OSI第三层网络层；**
（2）寻址方式不同：交换机根据MAC地址寻址，路由器根据IP地址寻址；
（3）转发速不同：交换机的转发速度快，路由器转发速度相对较慢

物理层：中继器（再生数字信号）、集线器 (放大信号)

数据链路层：网桥、交换器

网络层：路由器（分组转发），路由器会**根据IP协议**的包头信息来转发数据包

网络层以上：网关

#### 7）Ip地址

Ip地址总共分为5类，A、B、C、D、E。

IP地址=32=网络地址＋主机地址 。网络号的位数决定了可以分配的网络数；主机号的位数决定了网络中最大的主机数

子网掩码是用来划分子网的。A类网络的网络位数是8位，默认子网掩码就是11111111.00000000.00000000.00000000，换算成二进制表示为255.0.0.0

C类网络的网络位数是24位，默认子网掩码就是11111111.11111111.11111111.00000000，换算成十进制表示为255.255.255.0

<img src="/image-20211001161055793.png" alt="image-20211001161055793" style="zoom: 67%;" />

例1：C类网络192.168.3.0划分子网，采用的子网掩码是255.255.255.240，则可分个 **16 子网**，每个子网最多可容纳的主机数：**14**。

子网掩码第四字节转为二进制为11111111.11111111.11111111.11110000，前28位为子网号，C类网络可分子网数为2的4次方得16，后4位为主机号=2^4=16，一般来说，主机号为全0或全1的地址不能被指派，所以16-2=14。即255-240-1=14

例2：C类IP地址192.168.0.0 想划分2个子网，一个里面有100台电脑，划分的子网掩码：

100小于2的7次方，所以主机位数取7位，网络位数就是32-7=25位，即子网掩码11111111.11111111.11111111.10000000 10进制的就是255.255.255.128

例3：主机的 IP 地址为 212.212.77.55，子网掩码为 255.255.252.0。若该主机向其所在子网发送广播分组，则目的地址是：212.212.79.255

子网掩码252，即11111100，前 22 位为子网号、后 10 位为主机号。将ip的主机号全置为 1，子网号不变。212.212.77.55即212.212. 010011 01 .55。即 广播号：212.212.  100011 11.255

例4：两台主机的IP地址分别与它们的子网掩码相“与”后的结果相同，则说明这两台主机在同一子网中。子网每一段[0,255]，还要求前一段大于后一段。

#### 8）路由选择协议

（1）内部网关协议IGP：

① RIP(Routing Information Protocol）：是一种动态路由选择协议，基于距离矢量算法，使用“跳数”来衡量到达目标地址的路由距离，并且只与自己相邻的路由器交换信息，范围限制在15跳之内。
② **OSPF：开放最短路径优先协议，使用Dijskra算法计算出到达每一网络的最短路径，**并在检测到链路的情况发生变化时（如链路失效），就执行该算法快速收敛到新的无环路拓扑。
（2）外部网关协议：

BGP：边界网关协议，BGP 是力求寻找一条能够到达目的网络 且 较好的路由，而并非要寻找一条最佳路由。BGP采用路径向量路由选择协议。

### 3、传输层

传输层主要提供不同主机上进程间 逻辑通信 + 可靠传输 或者 不可靠传输的功能。

#### 1) TCP 和 UDP的区别**

**传输控制协议TCP , 用户数据报协议UDP**
（1）**TCP是面向字节流的，**基本传输单位是TCP报文段；**UDP是面向报文**的，基本传输单位是是用户数据报；

面向字节流：应用程序和TCP的交互是一次一个数据块（大小不等）。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。
面向报文：面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送。因此，应用程序必须选择合适大小的报文。
（2）TCP **注重安全可靠性**，连接双方在进行通信前，需进行三次握手建立连接。UDP 是无连接的，**使用最大努力交付，即不保证可靠交付**。

（3）UDP 不需要连接等待，所以**数据传输快**，而 TCP 传输效率相对较低

（4）TCP首部开销是20个字节，**报文头部长，传输开销大**；UDP的首部开销是8个字节，这也是减少网络传输开销的一方面

（5）TCP有**拥塞控制和流量控制**，而UDP没有拥塞控制和流量控制

（6）TCP提供**全双工通信，是点对点面向连接的传输协议，不提供广播或多播服务**；UDP支持一对一、**一对多**、多对一、**多对多**的通信模式。

生产上的链接协议如何配置的？是使用tcp吗？

还用过NIO，它类似于TCP传输协议，但是它是用的是**非阻塞型NIO**，它有比TCP更好的性能

#### 2）TCP 和 UDP 的适用场景

（1）当对网络通讯质量要求不高时，并且要求网络通讯速度能尽量的快，就可使用UDP。如即时通信： 语音、 视频 、直播等，**DNS、DHCP、TFTP协议**等

（2）当对网络通讯质量有要求时，要求整个数据准确无误可靠的传递给对方，就使用 TCP 协议，一般用于文件传输、发送和接收邮件等场景。比如**HTTP、HTTPS、FTP**等传输文件的协议，**POP、SMTP**等邮件传输的协议都是使用 TCP 协议

#### 3）TCP的首部字段**

<img src="/20210405193539149.png" alt="img" style="zoom:80%;" />

（1）**源端口和目的端口**：分别占16位，指发送方应用程序的端口和目的方应用程序的端口号，通过 IP 地址 + 端口号就可以确定一个进程地址

（2）序号（Sequense Number，SN）：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，该字段表示本报文段所发送数据的第一个字节的序号。（初始序号称为 Init Sequense Number, ISN）

例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。

（3）确认号 ack：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。

（4）头部长度：指出 TCP报文段的数据起始处 距离 TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。

（5）保留位：占6位，应置为 0，保留为今后使用。

（6）6个控制位：用于说明该报文段的性质：

① 紧急位URG：当 URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。
② 确认ACK：仅当 ACK = 1 时确认号字段才有效，当 ACK = 0 时确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。
③ 推送PSH：接收方收到 PSH = 1 的报文段时，就直接发送给应用进程，而不用等到整个缓冲区都填满了后再向上传送。
④ 复位RST：当 RST = 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。
⑤ 同步SYN：SYN = 1 表示这是一个连接请求或连接接受报文。**当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 且 ACK = 1。**
⑥ 终止FIN：用来释放一个连接。**当 FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。**
（7）**窗口大小：16位，用于控制发送端的滑动窗口大小**

（8）校检和：16位，校验数据段是否未被修改

（9）紧急指针：16位。

#### 4）TCP建立连接的三次握手

<img src="/20210405225641324.png" alt="img" style="zoom:80%;" />

（1）第一次握手：**客户端向服务端发送一个 SYN 同步报文**（SYN = 1），并指明客户端初始化序列号 ISN，即seq = x，表示本报文所发送的第一个字节的序号。此时客户端处于 **SYN_Sent同步发送 状态**。

（2）第二次握手：服务端收到数据包后，由 SYN = 1 知道客户端请求建立连接，那么就会对这个TCP 连接分配缓存和变量（缓存指的是一个字节流队列），接着返回一个确认报文：设置 SYN = 1，ACK = 1，同时指定自己的初始化序列号 ISN，即图中的 seq = y，并把客户端的 ISN + 1 作为**确认号 ack 的值**，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务端进**入SYN_REVD同步接收状态**。

（3）第三次握手：**客户端收到确认后，**检查ACK是否为1，ack是否为 x +1，如果正确，**则给服务端发送一个 ACK 报文**：设置 ACK = 1，把服务端的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1，**此时客户端先进入 ESTABLISHED 状态，服务器端收到确认后也进入 ESTABLISHED 状态**。完成三次握手，随后Client与Server之间可以开始传输数据了。

**三次握手过程中是否可以携带数据**？
第三次握手时是可以携带数据的，但第一二次握手时不可以携带数据。**客户端先处于建立状态，服务端先处于关闭状态。**

（1）假如第一次握手可以携带数据的话，那么会放大 SYN 洪泛（恶意攻击服务器产生）。

（2） 第三次握手时客户端已经处于 ESTABLISHED 建立起连接的状态，并且已经知道服务器的接收和发送能力是正常的，所以也就可以携带数据了。

**为什么三次握手？**

TCP是**双向通信协议的可靠传输**，三次握手是保证可靠性的基础上握手次数最少的方案。

（1）**目的是各自确认双方的接收与发送能力是否正常**。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方的序列号则得不到确认

（2）防止已失效的连接请求报文段突然又传送到了服务端，产生错误连接。要多一次握手，客户端收到服务端的确认后会判断是否是历史连接再确认是否要建立连接。

#### 5）TCP断开连接的四次挥手

<img src="/20210406012728597.png" alt="img" style="zoom:80%;" />

（1）第一次挥手：**客户端发送一个 FIN 报文**，设置 FIN  = 1 并指定序列号 seq = u（u 是之前传送过来的最后一个字节的序号 + 1），主动关闭 TCP 连接，**此时客户端进入FIN_WAIT_1状态；**

（2）第二次挥手：服务端收到 FIN 报文后，由FIN=1 知道客户端请求关闭连接，**则返回确认报文：设置ACK = 1**，ack = u + 1，seq = v（v 的值取决于服务器发送给客户端之前的一个包确认号是多少）

**服务端进入CLOSE_WAIT状态**，此时TCP连接处于半关闭状态，即客户端不能向服务端发送报文，只能接收，但服务端仍然可以向客户端发送数据。
**客户端收到服务端的确认后，进入 FIN_WAIT2 状态**，等待服务端发出的连接释放报文段。
（3）第三次挥手：**当服务端没有要向客户端发送的数据时，就向客户端发送一个 FIN 报文，**设置 FIN = 1 并指定序列号 seq = w（w 的值取决于服务器发送给客户端之前的一个包确认号是多少），用于关闭服务端到客户端的数据传送。**此时服务器处于 LAST_ACK 状态**

（4）第四次挥手：**客户端收到 FIN 报文后，发送给服务端一个 ACK 报文作为应答**：设置 ACK=1 和 ack = w +1。发送之后，**客户端处于 TIME_WAIT状态，如果服务端接收到这个数据包，则进入CLOSED状态**，完成四次挥手。**除了第一次挥手，其他挥手ACK都=1。**

**为什么需要 TIME_WAIT 状态？** 
TIME_WAIT 状态持续 **2MSL（最大报文存活时间）**，约4分钟才转换成CLOSE状态。

（1）保证最后一次挥手的 ACK 报文一定到达服务器，如果 ACK 丢失，则重发丢失的 ACK+FIN 报文，保证连接可靠的关闭。

（2）这段时间保证本次连接产生的所有数据报文段从网络中消失，不会干扰新的连接。

**为什么需要四次挥手？**
TCP 是全双工模式的通信，并且支持半关闭特性。服务端收到客户端的FIN报文，仅表示客户端不再发数据，但服务端还可能会发数据，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。

#### 6）SYN洪泛

SYN 洪泛是指利用 TCP 需要三次握手的特性，攻击者伪造 SYN 报文向服务器发起连接，服务器在收到报文后用 ACK 应答，但之后攻击者不再对该响应进行应答，造成一个半连接。大量的半连接导致半连接队列满了，耗尽其资源，导致正常的 SYN 请求被丢弃，使得正常用户无法访问。

半连接队列：服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，完成三次握手后建立起的连接就会放在全连接队列中。

#### 7）TCP的粘包和拆包**

程序需要发送的数据大小和TCP报文段能发送MSS（Maximum Segment Size，**最大报文长度，缓冲区）是不一样的**。大于MSS时，就需要把程序数据拆分为多个TCP报文段，称之为拆包；小于时，则要考虑合并多个程序数据为一个TCP报文段，则是粘包；其中MSS = TCP报文段长度-TCP首部长度。在IP协议层或者链路层、物理层，都存在拆包、粘包现象。

**解决粘包和拆包的方法主要有：**

（1）在数据尾部增加特殊字符进行分割，http协议的header以换行符“rn”分割；
（2）将数据定为固定大小；
（3）把消息分成消息头和消息体，其中头部大小固定且有一个**字段声明内容体的大小**

TCP报文段很长的话，发送时发生**分段**，在接收时进行重组，同样IP数据报在长度超过一定值时也会发生**分片**，在接收端再将分片重组

**TCP发送的数据是有序的，但接受的顺序不一定是有序的**，会对其再次排序，从而保证结果的有序性

#### 8）TCP 如何保证可靠性传输

（1）**三次握手四次挥手**
（2）应答机制与**超时重传**：TCP接收端收到发送端的数据时，它将发送一个确认。当TCP发送端发出一个报文段后，它会启动一个定时器，等待接收端的确认报文段，如果不能及时收到一个确认，将重发这个报文段。
（3）数据包校验与丢弃重复数据：TCP会检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP会超时重发数据；对于重复数据，则进行丢弃；
（4）对失序数据包进行重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
（5）**流量控制**：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，防止较快主机致使较慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议。
（6）**拥塞控制**：网络拥塞时，减少数据的发送。

#### 9）TCP的流量控制

**所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。**TCP的流量控制是通过**大小可变的滑动窗口**来实现的。接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK报文来通知发送端，滑动窗口是接收端用来控制发送端发送数据的大小，从而达到流量控制

其实发送方的窗口上限，**是取值拥塞窗口和滑动窗口两者的最小值**。当滑动窗口为 0 时，发送方一般不能再发送数据包，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。 只有在 ACK=1 时确认号字段才有意义。

滑动窗口协议有：

1、停止等待协议，**发送窗口=1，接受窗口=1**。发送端给接收端发送数据，等待接收端确认回复ACk，并停止发送新的数据包，开启计时器。数据包在计时器超时之前得到确认，那么计时器就会关闭，并发送下一个数据包。如果计时器超时，发送端就认为数据包丢失或被破坏，需要重新发送之前的数据包，说明数据包在得到确认之前，发送端需要存储数据包的副本。
2、退后N帧协议，**发送>1,接收=1**。在发送完一个帧后，不用停下来等待确认，而是可以连续发送多个数据帧。**收到确认帧时**，任可发送数据，这样就减少了等待时间，整个通信的通吞吐量提高。

<img src="/20160418155350232" alt="这里写图片描述" style="zoom:80%;" />

3、选择重传协议，**发送>1,接收>1**。在发送过程中，如果一个数据帧计时器超时，就认为该帧丢失或者被破坏，接收端只把出错的的帧丢弃，其后面的数据帧保存在缓存中，**并向发送端回复NAK（非确认帧）**，发送端接收到NAK时，只发送出错的帧。

<img src="/20160418155400842" alt="这里写图片描述" style="zoom:80%;" />

#### 10）TCP的拥塞控制

**拥塞控制就是防止过多的数据注入网络中，使网络中的路由器或链路不致过载**。发送方维持一个拥塞窗口cwnd 的状态变量。拥塞窗口的大小动态变化，取决于网络的拥塞程度，发送方让自己的发送窗口等于拥塞窗口。 拥塞控制的方法主要有以下几种：慢启动、拥塞避免、快重传和快恢复。

（1）**慢开始算法**：当发送主机开始发送数据时，先试探一下网络的拥塞情况，由小到大逐渐增大发送窗口。在开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段，然后**每经过一个传输轮次RTT，拥塞窗口 cwnd 就加倍。**另外，为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh 状态变量。

当 cwnd < ssthresh 时，使用上述的慢开始算法。

当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。

当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。

（2）**拥塞避免算法：**让拥塞窗口cwnd缓慢地增大，即**每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1**。比**慢开始的拥塞窗口增长速率缓慢得多**

只要网络出现拥塞（其根据就是没有收到确认），把慢开始门限ssthresh设置为出现拥塞时的拥塞窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd 设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的数据量。

（3）快重传：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（使发送方及早知道有报文段没有到达对方）而不必等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

（4）快恢复：与快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减少”算法，把ssthresh门限设置为拥塞窗口cwnd的一半，但是接下去并不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法：因为如果网络出现拥塞的话，就不会收到好几个重复的确认。

![image-20210905160221174](/image-20210905160221174.png)

**拥塞控制和流量控制的差别**
（1）相同点：拥塞控制和流量控制的相同点都是控制丢包现象，实现机制都是让发送方发得慢一点。

（2）不同点：

① 拥塞控制是**一个全局性的过程，防止过多的数据注入到网络中，**造成网络拥塞

② 流量控制指**点对点通信量的控制，要做的就是控制发送端发送数据的速率，**以便使接收端来得及接受。

#### 11）电路交换和分组交换

<img src="/image-20210929160344805.png" alt="image-20210929160344805" style="zoom:67%;" />

电路交换（SCN）：包含一条物理路径，并支持网络连接过程中两个终点间的单连接方式。包括建立连接、数据传输、释放连接三个阶段。**传输可靠、迅速，数据不会丢失**，且保持原来的序列。如：打电话。

分组交换：分组就是将一个数据包分成一个个更小的数据包。在通信过程中，通信双方以分组为单位、使用**存储-转发机制**实现数据交互的通信方式。不同的数据分组可以在同一条链路上以动态共享和复用方式进行传输，通信资源利用率高；但不具有实时性，会出现丢包的情况。如：上网。

### 4、应用层

应用层主要提供应用进程间的网络通信服务，完成用户请求的各种服务。  

#### 1）http协议

http协议即**超文本传输协议，基于TCP协议，**用于从Web服务器传输超文本到本地浏览器的传送协议。**http协议是无状态明文传输的协议**，自身不对请求和响应直接的通信状态进行保存，但有些场景下我们需要保存用户的登陆信息，所以引入了cookie 和 session 来管理状态。

##### 1、cookie 和 session 的区别

（1）保存位置与安全性：**cookie保存在客户端，session保存在服务端，所以cookie存在安全隐患**，可以通过拦截或本地文件找到cookie后进行攻击。因此，**可以将登陆信息等重要信息存放为session中。访问多时session会比较占用服务器的性能，用COOKIE减轻服务器压力。**

（2）存储容量：**单个cookie最大只允许4KB**，一个站点最多保存20个Cookie；**session没有大小限制**，只跟服务器的内存大小有关。

（3）有效期与实现机制：可通过设置cookie的属性，达到使cookie长期有效的效果。session依赖于名为JSESSIONID的cookie，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果（tomcat默认设置是30分钟）。

（4）**Cookie是不允许垮域访问**，隐私安全机制能够禁止网站非法获取其他网站的Cookie。Token机制可以跨域。**Session可以在多台服务器之间共享**。每个客户端对应一个session ，客户端之间的 session  相互独立；

cookie：服务器使用 SET-Cookie 将它作为 HTTP响应的一部分传送到客户端，cookie存放在客户端，可以分为内存cookie和磁盘cookie。内存cookie在浏览器关闭后消失，磁盘cookie超时后才消失。当浏览器发送请求时，将自动携带对应cookie信息 ，服务器会检查该cookie，以此来辨认用户状态。

<img src="/20190917204655188.png" alt="在这里插入图片描述" style="zoom:80%;" />

session：当客户端请求服务器时，都会带上cookie，cookie里面一般都会有一个JSESSIONID，服务器就按照 JSESSIONID 来找到对应的 session；如果客户端请求不包含 JSESSIONID，则为此客户端创建session并生成相关联的JSESSIONID，并将这个JSESSIONID在本次响应中返回给客户端使用cookie机制保存。若浏览器禁用Cookie的话，可以通过 **URL重写机制 将JSESSIONID传回服务器**。

![在这里插入图片描述](/2019091720523621.png)

##### 2、完整的http请求

**即从输入网址到获得页面的过程**

（1）解析url，获取 url 中包含的域名；

（2）通过DNS系统查询域名对应的IP；

<img src="/20210325142501428.png" alt="img" style="zoom:67%;" />

DNS服务器大致分为三种类型：**根DNS服务器、顶级域DNS服务器 和 权威DNS服务器，** 顶级域DNS服务器主要负责com、org、net、edu、gov 等顶级域名。

权威服务器会返回给你具体的 IP 地址。此外，本地 DNS 服务器是具有缓存功能的，通常两天内的记录都会被缓存。

通过DNS系统查询域名对应的 IP 的具体步骤可以总结为：

① 操作系统先查**本地 hosts文件** 中是否有记录，如果有，则直接返回相对应映射的IP地址。
② 如果本地hosts文件中没有配置，则主机向自己的本地 DNS 服务器 发送查询报文，如果本地DNS服务器缓存中有，将直接返回结果
③ 如果本地服务器缓存中没有，则从内置在内部的根服务器列表（全球13台，固定的IP地址）中选一个发送查询报文
④ 根服务器解析域名中的后缀名，告诉本地服务器负责该后缀名的所有顶级服务器列表
⑤ 本地服务器选择其中一个顶级域服务器发送查询请求，顶级域服务器拿到域名后继续解析，返回对应域的所有权威服务器列表
⑥ 本地服务器再向返回的权威服务器发送查询报文，最终会从某一个权威服务器上得到具体的 IP 地址
⑦ 主机返回结果IP
（3）浏览器得到域名对应的IP地址之后，向服务器发起三次握手请求建立TCP链接；

（4）TCP链接链接建立起来后，浏览器向服务器发送http请求，如果 html文件在缓存里，浏览器则直接返回， 如果没有，则去后台拿；

① 浏览器首次加载资源成功时，服务器返回200，此时浏览器不仅将资源下载下来，而且把response的header(里面的date属性非常重要，用来计算第二次相同资源时当前时间和date的时间差)一并缓存;

② 下一次加载资源时，首先要经过强缓存的处理，cache-control的优先级最高，比如cache-control：no-cache,就直接进入到协商缓存的步骤了，如果cache-control：max-age=xxx,就会先比较当前时间和上一次返回200时的时间差，如果没有超过max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有cache-control，会取expires的值，来对比是否过期），过期的话会进入下一个阶段，协商缓存

③ 协商缓存阶段，则向服务器发送header带有If-None-Match和If-Modified-Since的请求，服务器会比较Etag，如果相同，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200;

④ 协商缓存第二个重要的字段是，If-Modified-Since，如果客户端发送的If-Modified-Since的值跟服务器端获取的文件最近改动的时间，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200;

（5）服务器接收到请求后，根据路径参数映射到特定的处理器进行处理，并将处理结果以及相应的视图返回给浏览器。

（6）浏览器解析视图，并根据请求到的资源、数据进行渲染页面，最终向用户呈现一个完整的页面。

构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；
构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；
执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；
构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；
渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。
布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；
绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；

##### 3、http的长连接和短连接

**http的长连接和短连接本质上是TCP长连接和短连接。**从http1.1开始就默认使用长连接。

短链接是指客户端与服务端每进行一次请求操作，就建立一次TCP连接，**收到服务器响应后，就断开连接。**

长连接是指客户端和服务建立TCP连接后，它们之间的连接会持续存在，**不会因为一次HTTP请求后关闭，后续的请求也是用这个连接进行通信，**使用长连接的HTTP协议，会在响应头有加入：Connection:keep-alive。长连接可以省去每次TCP建立和关闭的握手和挥手操作，节约时间提高效率。但在长连接下，客户端一般不会主动关闭连接，如果客户端和服务端之间的连接一直不关闭的话，随着连接数越来越多，会对服务端造成压力。

例如：**频繁请求资源且连接数不多的数据库连接用长连接。**而像Web网站这种并发量大，但是每个用户无需频繁操作的场景，一般都使用短连接。

##### 4、http的断点续传是如何实现的

HTTP请求头有个Range字段；我们下载文件的时候如果遇到网络中断，如果重头开始下载会浪费时间，所以我们可以从上一次中断处继续开始下载；

##### 5、http存在的问题

通信使用明文不加密，通信内容可能被窃听；
无法验证报文的完整性，数据内容可能被篡改
不验证通信方身份、可能遭到伪装，无法保证数据发送到正确的机器上；

#### 2）https协议

https 是基于tcp协议，在http的基础上加入了SSL/TLS，可看成是添加了**加密和认证机制的http**，使用**对称加密、非对称加密、证书等技术**进行进行客户端与服务端的数据加密传输，最终达到保证整个通信的安全性。

对称加密指加密和解密都使用**同一个密钥**的方式，这种方式存在如何安全地将密钥发送对方的问题；

非对称加密使用两个密钥，**公钥加密则需要私钥解密，私钥加密则需要公钥解密**。不能私钥加密，私钥解密。非对称加密不需要发送用来解密的私钥，所以可以保证安全性，但是和对称加密比起来，速度非常的慢，所以我们还是要用对称加密来传送消息，但加密所使用的密钥可以通过非对称加密的方式发送出去。

##### 1、https的认证加密过程

**1-6；**非对称加密密钥：C.pri、C.pub

<img src="/87618b07e93b25c6407fcd2399b0b7d4.png" alt="img" style="zoom:50%;" />

##### 2、根证书保证证书安全有效

（1）服务器会预先生成非对称加密密钥，私钥S.pri自己保留，而公钥S.pub则发送给CA进行签名认证
（2）CA机构也会预先生成非对称加密密钥，其私钥C.pri用来对服务器的公钥S.pub进行签名，生成CA证书
（3）CA机构将签名生成的CA证书返回给服务器，也就是前面服务端给客户端那个证书
（4）因为CA机构比较权威，所以很多**浏览器会内置包含它公钥C.pub的证书，称之为根证书**，然后可以使用**根证书来验证其颁发证书的合法性了**

**在整个过程中，一共涉及2对公私密钥对，一对由服务器产生，主要用于加密，一对由CA产生，主要用于签名。**

3、为什么需要CA证书认证机构呢？
CA证书是为了确保服务端的公钥是准确无误、没有被修改过的。虽然https是加密的，但是请求还是可以被拦截的，假设没有CA证书，如果服务器返回的包含公钥的包被攻击者截取，然后攻击者也生成一对公私钥，他将自己的公钥发给客户端。攻击者得到客户端数据后进行解密，然后再通过服务器的公钥加密发给服务器，这样数据就被攻击者获取到了。

有了CA证书后，客户端根据内置的CA根证书，很容易识别出攻击者的公钥不合法，或者说攻击者的证书不合法。

证书通常包含这些内容：(1) 服务端的公钥；(2) 证书发行者(CA)对证书的数字签名；(3) 证书所用的签名算法；(4) 证书发布机构、有效期、所有者的信息等其他信息

**https加密是在传输层 ，https报文在被包装成tcp报文的时候完成加密的过程**

#### 3）http 的请求与响应

##### 1、http的常见请求方式

（1）get：**向服务端获取资源**，所以查询操作一般用get
（2）post：**向服务端提交请求字段**，创建操作使用 post，该操作不是幂等的，多次执行会导致多条数据被创建
（3）put：**修改指定URL的资源**，如果资源不存在则进行创建，修改操作一般使用 put，在http中，put 被定义成幂等的，多次操作会导致前面的数据被覆盖
（4）patch：局部修改URL所在资源的数据，是对put的补充
（5）delete：删除指定URL的资源。
（6）head：获取响应报文的首部，即获得URL资源的头部
（7）options：询问服务器支持哪些方法，响应头中返回 Allow: GET、POST、HEAD
（8）trace：追踪路径，主要用于测试或诊断；在请求头中在Max-Forwards字段设置数字，每经过一个服务器该数字就减一，当到0的时候就直接返回，一般通过该方法检查请求发送出去是否被篡改

##### 2、get和 post 请求的区别

（1）**功能：get一般通过URL从服务器上面获取资源，post一般用来更新服务器上面的资源。**
（2）幂等性：get 是幂等的，post 为非幂等的
（3）**安全性：get 请求的参数会明文附加在URL之后，而 post 请求提交的数据则被封装到请求体中，相对更安全。**
（4）**传输数据量的大小**：get请求允许发送的数据量比较小，大多数浏览器会限制请求的url长度在2048个字节，而大多数服务器最多处理64K大小的url；而post请求提交的数据量则是没有大小限制的。
（5）参数的数据类型：GET只接受ASCII字符，而POST没有限制。
（6）GET在浏览器回退时是无害的，而POST会再次提交请求。
（7）**get请求可以被缓存**，可以被保留在浏览器的历史记录中；post请求不会被缓存。

##### 3、http报文头分析**

（1）报文类型：报文类型分为请求报文和响应报文

① 请求报文请求格式和参数：

请求行：**包含请求方法（一般有post,get）、URI**、HTTP版本信息
**请求首部字段：可接受的编码类型，内容类型，cookie**
请求内容实体：

② 响应报文包含三部分：

状态行：包含HTTP版本、状态码、状态码的原因短语
响应首部字段
响应内容实体

<img src="/441cc60d7b9456660f383e370806f377.png" alt="img" style="zoom: 80%;" />

##### 4、Http 常见的状态码

（1）1xx：请求处理中，请求已被接受，正在处理。

（2）2xx：请求成功，请求被成功处理。

200 ：OK，客户端请求成功；
204（请求处理成功，但是没有资源返回）
（3）3xx：重定向，要完成请求必须进一步处理。

301：**资源被永久转移到其他URL**
302：暂时重定向
304：已缓存。**资源已找到，但是不符合条件请求**
（4）4xx：客户端错误，请求不合法。

**400：客户端请求报文出现错误，通常是参数错误**
401：客户端未认证授权
403：没有权限访问该资源
**404：未找到请求的资源**
405：不支持该请求方法，**如：服务器支持GET，客户端却用POST请求**
（5）5xx：服务端错误，服务端不能处理合法请求。

500：服务器内部错误。
503：服务不可用，一段时间后可能恢复正常。

##### 5、http/1.1和http/2.0的区别

（1）HTTP2.0 **使用了多路复用的技术**，做到同一个连接并发处理多个请求，并发请求的数量比HTTP1.1大了好几个数量级。

（2）**支持首部压缩**：HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

（3）**服务器推送**Server Push：当向支持HTTP2.0的web服务器请求时，服务器会顺便把客户端需要的资源一起推送到客户端，避免客户端再次创建连接发送请求到服务器端获取，这种方式非常合适加载静态资源。

（4）http2.0**采用二进制而不是文本格式**

##### 6、http 和 https 的区别

（1）**http 和 https 都是基于 TCP 协议，但是 http 是使用明文传输**，通讯内容可能被窃听和篡改，客户端也无法验证通讯方的身份；https 在 http 的基础上添加了**加密和认证机制（加入了 SSL/TLS），使用对称加密、非对称加密、证书等技术进行数据加密传输，保证整个通信的安全性。**

（2）端口不同：**http 使用的是80端口，https 使用的443端口**

（3）资源消耗：和 http 通信相比，https通信会由于**加解密处理消耗更多的CPU和内存资源**

#### 4）在浏览器中输⼊url地址到显示主⻚的过程 

1. 对输入到浏览器的url进行DNS解析，将域名转换为IP地址。

2. 和目的服务器建立TCP连接

3. 向目的服务器发送HTTP请求

4. 服务器处理请求并返回HTTP报文

5. 浏览器解析并渲染页面

#### 5）应用层其他相关的协议 

（1）DNS域名系统：用于域名解析服务，将域名地址转换为IP地址，基于UDP服务，使用53端口。

**DNS底层：域名解析时使用UDP协议，区域传送时使用TCP（**辅域名服务器会定时（一般时3小时）向主域名服务器进行查询，若数据同步，传送的数据多）
（2）**FTP**：定义了文件传输协议，使用21端口。**上传下载文件，都要用到FTP服务。**

（3）Telnet：远程终端协议，它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，提供一种基于DOS模式下的通信服务。

（4）**SMTP**：定义了简单**邮件传送协议**，用于发送邮件，使用25号端口。

（5）POP3：与SMTP对应，POP3用于接收邮件。使用110端口。

（6）SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。

（7）**TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在69端口上使用UDP服务**

 （8）**SSH** 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供**安全性的协议**。






## 二、操作系统

### 1、操作系统简介

#### 1）操作系统

操作系统本质上是一个**运行在计算机上的软件程序 ，管理着计算机硬件和软件资源，**为计算机硬件和软件提供了一种中间层和分离，操作系统的主要功能有：

（1）进程管理：进程管理的主要作用就是任务调度，以及进程的创建销毁、阻塞唤醒、进程同步、进程通信、死锁处理等功能。
（2）内存管理：内存分配与回收、地址映射、虚拟内存以及页面的置换
（3）文件管理：有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。
（4）设备管理：根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。

#### 2）用户态和内核态

将操作系统的运行状态分为用户态和内核态，主要是为了**对访问能力进行限制**，防止随意进行一些比较危险的操作导致系统的崩溃，比**如设置时钟、内存清理**，这些都需要在内核态下完成

内核态：内核态运行的程序可以**访问计算机的任何数据和资源**，包括外围设备，如网卡、硬盘等。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且CPU 不会发生抢占情况。

用户态：用户态运行的程序只能**受限地访问内存，可读取用户程序的数据，不允许访问外围设备**。用户态下的 CPU 不允许独占，CPU 能够被其他程序获取。

### 2、进程与线程

**进程由进程控制块（PCB）、程序段、数据段组成**。

#### 1）进程与线程的区别**

**（1）进程是运行中的一个程序，是操作系统资源调度和分配的最小单位；线程是程序执行的最小单位，是CPU处理器调度和分派的基本的单位**

**（2）一个程序至少有一个进程，一个进程至少有一个线程，线程是依赖于进程存在的，线程是一个进程中代码的不同的执行路线**

（3）资源与内存空间：**线程不拥有资源**；进程之间拥有相互独立的内存单位，但是同一个进程下的各个线程之间共享程序的内存空间，（包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；

（4）系统开销：创建或销毁进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等；而线程只需要堆栈指针以及程序计数器就可以了，开销远小。**两者均可并发执行**，进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

（5）通信：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。

进程和线程的资源分别存在哪?

线程：栈，寄存器，程序计数器

进程：全局变量，堆，方法区

#### 2）线程的状态和生命周期

![image-20210905201534310](/image-20210905201534310.png)

（1）创建状态：进程刚被创建，尚未进入就绪队列。创建进程需要两个步骤：即为新进程分配所需要的资源和空间。

（2）就绪状态：进程已获得除CPU以外的所需的一切资源，一旦得到CPU资源即可运行；就绪态和运行态可以相互转换

（3）运行状态：进程正在处理器上面运行

（4）阻塞状态：阻塞状态是缺少需要的资源（不包括 CPU 时间）从而由运行状态转换而来，阻塞的情况分三种：
(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。
(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )队列中。
(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。

​	 TIMED_WAITING和WAITING,的区别：
​	 WAITING是一直等，Time_wating是设置时间等

​	wait是object的方法，释放锁；sleep是Thread的方法，不释放锁。

（5）终止状态：进程达到正常结束点或因其他原因被终止，下一步将被撤销。 终止一个进程需要两个步骤：先等待操作系统或相关的进程进行善后处理；然后回收占用的资源并被系统删除。

#### 3）进程的调度算法

（1）**先来先服务FCFS** (first come first service)：按照请求的顺序进行调度，使用队列实现。**有利于长作业，不利于短作业**（等长作业执行完才能执行）

（2）**最短作业优先SJF/SPN**：按照估计运行时间最短的顺序进行调度**。有利于短作业，但长作业有可能饿死**。

（3）最短剩余时间优先SRT：按估计剩余时间最短的顺序进行调度。

（4）**时间片轮转RR**：将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，当时间片用完时，将未执行完的当前进程送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：时间片太小，会导致进程切换频繁切换，切换要保存当前进程的信息并载入新进程的信息；时间片过长，那么实时性就不能得到保证。

（5）优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

（6）**高响应比优先HRRN**：该算法是对FCFS调度算法和SJF调度算法的一种平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，选出**响应比最高**的作业投入运行。 响应比=（等待时间+服务时间）/服务时间。服务时间越短，其响应比越高，**有利于短作业**（大于1的分数，分子分母加相同数会变小）。**等待时间越长，其响应比越高，兼顾了长作业**，不会饥饿的情况。

（7）**多级反馈队列调度算法**：是时间片轮转和优先级调度的结合。设置多个队列，**优先级越高的队列中时间片越小，进程FCFS原则排队**，在第一个队列没执行完就移到下一个队列。当第一队列空闲时，调度程序才调度第二队列中的进程运行；如果正在处理第i队列中某进程，又有新进程进入优先权较高的队列，则把正在运行的进程放在第i队列的队尾并运行优先权较高的队列。

#### 4）进程的通信（IPC）方式**

（1）**匿名管道 ：古老，半双工的，即数据只能在一个方向上流动。用于具有亲缘关系的进程间（父子，兄弟进程）的通信；**

（2）**命名管道 FIFO**：可以用于**无亲缘关系的进程间的通信**，半双工，可以实现本机任意两个进程间的通信。存在于实际的磁盘介质或者文件系统，速度慢。

（3）信号量 semophore：**信号量是一个计数器，用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。信号量基于操作系统的 PV 操作(对信号量的加减)，都是原子操作**；

（4）消息队列 Message Queuing ：A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。**消息队列是消息的链表。**管道和消息队列的通信数据**都是先进先出的原则**，但消息队列也可以按消息的类型读取，比 FIFO 更有优势。存放在内核中，**只有在操作系统重启或者显示地删除一个消息队列时，该消息队列才会被真正的删除**。

（5）共享内存：多个进程共享一个给定的存储区；是最快的一种 IPC，因为进程是直接对内存进行存取。

（7）套接字 socket：它把传输层TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用。

#### 5）线程间同步的方式

（1）临界区 CriticalSection：**在任意时刻只允许一个线程对共享资源进行访问，**其他访问的线程将被挂起，临界区在被释放后，其他线程才可以抢占。

（2）互斥量 Mutex：采用互斥对象机制。互斥对象只有一个，能保证公共资源不会同时被多个线程访问。互斥对象和临界区对象非常相似，但是互斥量允许在进程间使用，而临界区只限制于同一进程的各个线程之间使用，但是更节省资源，更有效率。

（3）信号量 semophore：信号量其实就是一个计数器，**限制了同一时刻访问同一资源的最大线程数**。如果这个计数达到了零，则所有对这个Semaphore类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计数值不为零为止。

（4）事件 Event，wait/notify：事件机制，允许一个线程在处理完一个任务后，主动唤醒另一个线程执行任务，通过通知操作的方式来保持线程的同步。

### 3、死锁

**两个或以上的线程因争夺资源而互相等待，形成闭环。**

如：线程A拥有a锁，但要B锁才能执行下去，同时线程B拥有B锁，但要A锁才能执行下去，两个线程就互相等待

<img src="/image-20211018171922392.png" alt="image-20211018171922392" style="zoom:67%;" />

```java
lass HoldThread implements Runnable {
    private String lockA;
    private String lockB;
    public HoldThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }
    @Override
    public void run() {
        synchronized (lockA) {   //获得 A 后等一秒让另一个线程拿到 B
try {TimeUnit.SECONDS.sleep(1);} catch (InterruptedException e) {e.printStackTrace();}
         synchronized (lockB) {
            }
        }
    }
}
public class DeadLockDemo {
    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";
        new Thread(new HoldThread(lockA, lockB), "AAA").start();
        new Thread(new HoldThread(lockB, lockA), "BBB").start();
    }
}
```

#### 1）死锁的四个必要条件

**四个必要条件，缺一不可**：
（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：进程因请求资源得不到而阻塞时，对已获得的资源保持不放。
（3）不可剥夺条件：进程已获得的资源在末使用完之前，不能强行剥夺，只能由自己释放。
（4） 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

#### 2）处理死锁的基本策略

常用的处理死锁的方法有：死锁预防、死锁避免、死锁检测、死锁解除、鸵鸟策略。

（1）死锁的预防：破坏至少一个死锁的四个必要条件：

**每个进程在开始时就一次性分配好所有资源**；但进程是动态执行的，很多情况下无法预知进程执行所需的全部资源（破坏请求请保条件）
当某进程**得不到需要的资源，就释放已占有的资源**（破坏不可剥夺条件）
将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，申请资源时**获得较小编号才能申请较大编号的资源**（破坏循环等待条件）
（2）死锁避免：

**死锁预防会导致资源和进程的使用非常低效。**而死锁避免则允许前三个必要条件，循环等待条件不成立。**银行家算法是经典的死锁避免的算法**：在进行资源分配之前可预先计算资源分配的安全性**（存在能让所有进程执行完不产生死锁的序列）。若系统处于安全状态**，则将资源分配给进程；否则，进程阻塞等待。
先定义：系统的状态：是当前给进程分配的资源情况。状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。

（3）死锁检测：

死锁预防策略是非常保守的，死锁检测则是完全相反，它不限制资源访问或约束进程行为，只要有可能，被请求的资源就被授权给进程。但是操作系统会周期性地执行一个算法检测前面的循环等待的条件。死锁检测算法是通过**资源分配图来检测是否存在环来实现**，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有存在环，也就是检测到死锁的发生。

​		1）如果进程-资源分配图中无环路，此时系统没有死锁。 
​		2）如果进程-资源分配图中有环路，且每个资源类中只有一个资源，则系统发生死锁。 
​		3）如果进程-资源分配图中有环路，且所涉及的资源类有多个资源，则不一定会发生死锁。
（4）死锁解除：

常用方法：剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；

​				    终止进程：**可以终止死锁代价最小的进程，**直至死锁状态消除

（5）鸵鸟策略：

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任何措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

#### 3）死锁检测分析

1、jps命令定位进程编号

<img src="/image-20211018172933801.png" alt="image-20211018172933801" style="zoom:67%;" />

2、jconsole/jstack找到死锁查看。

Jconsole是JDK自带的图形化监控工具，在JDK/bin目录下可以找到。直接在idea使用

jstack是java虚拟机自带的一种堆栈跟踪工具：jstack  进程号

<img src="/image-20211018173057472.png" alt="image-20211018173057472" style="zoom:67%;" />

### 4、内存管理

#### 1）内存连续分配算法

为了能将用户程序装入内存，必须为它分配一定大小的内存空间。连续分配算法是最早出现的分配方式，该分配方式为用户程序在内存中分配一个连续的内存空间。**连续分配方式可以分为四类：**单一连续分配、固定分区分配、动态分区分配 和 动态可重定位分区分配。

（1）单一连续分配：内存在此方式下分为系统区和用户区，只能用于单用户、单任务的操作系统中，

（2）固定分区分配：存在内部碎片。

（3）**动态分区分配：**在进程装入内存时，根据进程的大小动态地建立分区，常见的分配策略有：

① **首次适应算法**：**从空闲分区链首开始查找**，直至找到一个能满足其大小需求的空闲分区为止。

保留了高地址部分的大空闲区。缺点在于低址部分不断被划分，留下许多内存碎片，并且每次查找都从低址部分开始，会增加查找的开销。

② 循环首次适应算法：不再每次从链首开始查找，而是**从上次找到的空闲分区开始查找**，直至找到一个能满足需求的空闲分区，并从中划出一块来分给作业。

该算法能使空闲中的内存分区分布得更加均匀，缺点是将会缺乏大的空闲分区。

（3）**最佳适应算法：**将所有的空闲区**按照大小从小到大排序**，按此顺序查找，直至找到一个能满足需求的空闲分区，必然是最优的。

缺点是在于内存中将留下许多难以利用的小空闲区。同时每次分配后必须重新排序，这也带来了一定的开销。

（4）**最差适应算法：按分区大小从大到小排序的顺序形成空闲区链，**分配时直接从空闲区链的第一个空闲分区中分配。

**该算法克服了最佳适应算法留下的许多小碎片的不足，**但缺点是保留大的空闲区的可能性减小了，而且空闲区回收也和最佳适应算法相同复杂。

#### 2）虚拟内存

**连续分配方式会形成许多内存“碎片”**，虽然可以通过“压缩”方法将碎片拼接成可用的大块空间，但开销很大。**可以将一个进程分散地装入到许多不相邻的分区中，便可以充分利用内存。即离散分配方式：分页存储管理、分段存储管理、段页式存储管理。而实现这种离散式分配的基础就是虚拟内存。**

虚拟内存的基本思想是：每个程序拥有自己的地址空间，这个空间被分为大小相等的多个块，称为页，**每个页都是一段连续的地址。**这些页被映射到物理内存，但并**不是所有的页都必须在内存中才能运行程序。**当程序仅需将当前运行所需的少数页面或段先装入内存，由硬件立刻进行必要的映射，其余部分暂留在磁盘上。

虚拟内存的好处在于：在内存中更多的进程，提高系统并发度；进程可以比物理内存的全部空间还大。

#### 3）页面置换算法

在进程运行的过程中，如果**所要访问的页面不在内存，则需把他们调入内存**，但是如果**内存已无空闲空间时**，系统必须从内存中调出一页程序或者数据送到磁盘的对换区中。这时，把选择换出页面的算法称为页面置换算法

（1）**最佳页面替换算法（OPT）**：将不会被用到的页换出内存；如果所有页都会被用到，**就把需要使用时间离现在最长的页换出**，保证最低的缺页率。理论上的算法，因为无法知道一个页面多长时间不再被访问。

（2）**先进先出（FIFO）：**最简单的页面置换算法，淘汰在内存中驻留时间最长的页。 

（3）**最近最少使用（LRU）**：淘汰最近一段时间内最久未被使用的页面。 

（4）最近未使用（NRU）：每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

（5）第二机会算法（SCR）：在FIFO 算法基础上，当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，然后继续从链表的头部开始搜索。

（6）**时钟页面替换算法（Clock）**：第二次机会算法需要在链表中移动页面，降低了效率。在SCR算法基础上，用循环队列来构造页面队列，队列指针指向可能被淘汰的页面。如果队列指针指向的页的“引用位”为1，则将其置为0，同时队列指针指向下一个页。

例：M为3：相当于物理块为3；**F就是缺页次数，缺页率就是缺页次数/总列数。**OPT有的页面就不动

<img src="/image-20210922182810434.png" alt="image-20210922182810434" style="zoom:80%;" />

 访问顺序相当于右进左出的队列，按照访问顺序划掉数字。OPT是按未来使用时间距离**，相同删后面，**LRU是按已使用时间，相同删前面

<img src="/image-20210921212110434.png" alt="image-20210921212110434" style="zoom:80%;" />

#### 4）内存离散分配方式

分页存储管理：将**程序/进程(不是线程)**的逻辑地址空间划分为固定大小的**页(page)**，编译后从0开始编址。而物理内存划分为同样大小的**页框**(page frame)

例1：某作业的页表如下所示。已知页面大小为 1024 字节，则逻辑地址 3000 对应的物理地址为：1976

![image-20210921130717208](/image-20210921130717208.png)

3000/1024=2（页号）余952（位移量），逻辑页号2对物理块1，物理地址：1*1024+952=1976



例2：某计算机主存按字节编址，逻辑地址和物理地址都是32位，页表项大小为4B（32位），若使用一级页表的分页存储管理方式，逻辑地址结构为：

![image-20210923000205622](/image-20210923000205622.png)

则：**页的大小=页内偏移量的大小=2^12B=4KB**

**页表项（一个页表项代表一个页号到物理块号的映射）**个数=页号个数=物理块个数=2^20

页表（页号到物理块号的地址映射）占用字节=(2^20)*4B=4MB



 段式存储管理：指把一个程序分成若干个段（segment）进行存储，每个段都是一个逻辑实体（logical entity）



CPU形成内存地址的方式是“段基址* 16 + 偏移地址”

x86 CPU在实模式下解释代码时看到一个地址为2330H:5041H,请问它最终在内存中要找的地址是：28341H。（偏移4位(16进制偏移1位)+ip，即2330 0 +5041）

#### 5）颠簸/抖动

**颠簸本质上是指频繁的页调度行为，**具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。

内存颠簸的解决策略包括：

如果是因为页面替换策略失误，可以**修改替换算法**来解决这个问题；
如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要**降低多道程序的数量**；
否则，还剩下两个办法：**终止该进程或增加物理内存容量**



### 5、文件系统

#### 1）磁盘的物理结构

![OS_DISK](/20161224212641212)

在磁盘上定位某个物理记录需要知道其柱面号、磁头号以及扇区号。定位物理记录时，磁头到达指定扇区的时间称为查找时间， 选择磁头号并旋转至指定扇区的时间称为 搜索延迟。

#### 2）磁盘调度算法

读写一个磁盘块的时间的影响因素有：寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）；旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）；
实际的数据传输时间。其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的**平均寻道时间最短**。

（1）先来先服务（FCFS）：**按磁盘请求的先后顺序进行调度**。优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

（2）最短寻道时间优先（SSTF）：**优先调度与当前磁头距离最近的磁道**。虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，**也就是出现饥饿现象**。具体来说，两端的磁道请求更容易出现饥饿现象。

（3）电梯调度算法（SCAN）：电梯算法和电梯的运行过程类似，**总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求后改变方向。**因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。

**平均寻道长度：总移动磁道数/总请求数**

例：当前位于116道，一个磁道访问请求序列为48, 59, 37, 81, 125, 195, 185, 205，采用电梯调度SCAN算法：125, 185, 195, 205, 81, 59, 48, 37（不是37开头）

### 6、常见的IO模型

#### 1）Unix 常见的IO模型

**对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到用户缓冲区。**所以说，当一个read操作发生时，它会经历两个阶段：

​	等待数据准备就绪 (Waiting for the data to be ready)

​	将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)

内核空间：应用程序是不能直接访问硬盘的，但是操作系统（Windows、Linux…）会给我们一部分权限较高的内核空间。

#### 2）四种主要的IO模型

- 同步，一个任务的完成之前不能做其他操作，必须等待（等于在打电话）

- 异步，一个任务的完成之前，可以进行其他操作（等于在聊QQ）

- 阻塞，是相对于CPU来说的， 挂起当前线程，不能做其他操作只能等待

- 非阻塞,，无须挂起当前线程，可以去执行其他操作

  阻塞/非阻塞指的是**用户空间程序的执行状态**。

  BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。

##### 3) BIO

**同步并阻塞，有线程上下文的切换**，可以用线程池。

阻塞IO的特点是：在内核进行**IO执行的两个阶段（等待复制数据），用户线程都被阻塞了**

![image-20220718152905934](C:/Users/henan/AppData/Roaming/Typora/typora-user-images/image-20220718152905934.png)

##### 2）NIO

**同步非阻塞，**通过selector，Channel，buffer实现非阻塞io操作，用到了反应器设计模式(react)。多路轮询器selector监听端口。

Channel 对象和流（Stream）的区别：**流是单向阻塞的，通道是双向异步的，可读可写。BIO是面向流的，只能单向读写，NIO是面向缓冲的, 可以双向读写**

同步非阻塞IO特点：程序需要不断**轮询数据是否准备好，如果没有准备好，就继续轮询**。没有阻塞的。

![image-20220718153030888](C:/Users/henan/AppData/Roaming/Typora/typora-user-images/image-20220718153030888.png)

##### 3）IO多路复用模型

**IO多路复用指的是单个进程或者线程能同时处理多个IO请求，同时监听多个文件描述符。**

select、poll 和 epoll 的区别：

select是将装有文件描述符的集合从用户空间拷贝到内核空间，底层是数组，有数量限制，最大1024文件描述符（32*32）。select会有空轮询的问题，selector.select()会获取不到事件，一直循环；可以selector.select(timeout)设置超时机制解决

poll和select类似，都是基于轮询的，但是底层是链表，这就代表没有数量限制。

epoll是**事件驱动模式，获取文件描述符后有回调机制**，其监听到数据流的fd，只将其返回给用户空间，避免轮询。数据结构是红黑数结构。

 select，poll，epoll 本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间。

**不断的进行select/epoll轮询，查询IO的就绪状态，当某个或者某些socket网络连接有IO就绪的状态，就返回对应的可以执行的读写操作**

![image-20220718153509104](C:/Users/henan/AppData/Roaming/Typora/typora-user-images/image-20220718153509104.png)

##### 4）AIO

**异步非阻塞，**用于连接数目多且连接比较长的架构。JDK1.7之后开始支持。

在**内核等待数据**和**复制数据**的两个阶段，**用户线程都不是阻塞的**。当**内核的IO操作**（等待数据和复制数据）全部完成后，**内核会通知应用程序读数据**。

![image-20220718153359239](C:/Users/henan/AppData/Roaming/Typora/typora-user-images/image-20220718153359239.png)

4、Netty框架：**由NIO演进而来，对NIO的封装。**Netty提供异步的、事件驱动的简化开发工具。

零拷贝：一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术，**可以减少数据拷贝和共享总线操作的次数**。一种方法是调用mmap()来代替read调用

<img src="/image-20211101143531953.png" alt="image-20211101143531953" style="zoom:80%;" />

在netty里面，很明显channelHandler和Pipeline构成了责任链模式。使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。

```Java
//依赖
		<dependency>
            <groupId>io.netty</groupId>
            <artifactId>netty-all</artifactId>
            <version>4.1.16.Final</version>
        </dependency>
//使用模板
public class NettyServer {
    public static void main(String[] args) throws InterruptedException {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            ChannelPipeline pipeline = socketChannel.pipeline();
                            pipeline.addLast(new StringDecoder());
                            pipeline.addLast("encoder", new ObjectEncoder());
                            pipeline.addLast(" decoder", new io.netty.handler.codec.serialization.ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(null)));
                            //重点，其他的都是复用的，这是真正的I0的业务代码，把他封装成一个个的个Handle类就行了
                            //把他当成 SpringMVC的Controller
                            pipeline.addLast(new NettyServerHandler());
                        }
                    })
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(8000).sync();
            System.out.println("服务端启动成功，端口号为:" + 8000);
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
}
```



## 三、数据结构与算法

算法由两种基本要素组成：**对数据对象的运算和操作，算法的控制结构**。

递归与递推的区别：递归使程序结构更简洁，但占用CPU的时间更多（会大量存储重复的数据），消耗大量的内存空间，比递推效率慢。

### 1、数据结构

#### 1）链表

线性链表中的各元素在存储空间中的位置不一定是连续的，且各元素的存储空间顺序也是任意的：表头结点不一定在其它元素的前面

广义表长度的：**最大括号中**的逗号数加1。深度：每个元素的括号匹配数加1的最大值。E((a,(a,b),((a,b),c)))的长度和深度分别为1和4。

存储结构：顺序存储（数组），链式存储（链表）

反转链表：

```java
public Node reverse(Node head) {	
		if(head.next == null || head.next.next == null) System.out.println("无需翻转");		//链表为空或者只有一个节点，无需翻转		
		Node reHead = new Node(-1);//创建新的头结点
		Node cur = head.next;
		Node nextNode = null;
		while(cur!=null) {
			nextNode=cur.next;
			cur.next =reHead.next;   //箭头=属性
			reHead.next = cur;
			cur=nextNode;
		}
    head.next=reHead.next;  //将头换过来
	}
```

例：双链表中p所指结点不是最后结点，要在p之后插入s所指结点，则执行：s->next=p->next;  p->next->pre=s;    s->pre=p;  p->next=s;

<img src="/image-20211001182951392-1648621170877.png" alt="image-20211001182951392" style="zoom:80%;" />

删除：

![image-20211021174725309](/image-20211021174725309.png)

约瑟夫环：单向环形链表

```java
class CircleList{	
    public static void count(int start, int countNum, int num){ 
        if (nums<1) { System.out.println("不能构成一个环形队列");return;}
        Node head = new Node(-1);
		Node cur = head;		
		for(int i=1;i<=num;i++){  //建环
			cur.next = new Node(i);
			cur = node;
		}
        cur.next = head.next; //环形链表
        cur=head.next;       
        for (int i=1;i<start;++i){   //第几个小孩开始的，将cur移到他上面
           cur=cur.next();
        }
        while (cur.next!=cur){   //剩余一个停
            for (int i=1;i<countNum-1;++i){
                cur=cur.next;
            }
            System.out.printf("\n小孩%d出圈\n",cur.next.n);
			cur.next=cur.next.next;
            cur=cur.next; 	 //从移除后的下一位开始
        }
        System.out.println("最后留在圈内的小孩是："+cur.n);
    }
}
static class Node{
    int n;
    Node next;
    Node(int n) {
        this.n = n;
    }
}
```

#### 2）队列

Queue 中 add() 和 offer()都是用来向队列添加一个元素。add() 方法会抛出IllegalStateException异常，offer() 方法只会返回 false 。remove() 和 poll()都是用来从队列头部删除一个元素。peek方法查看

用俩个栈模拟实现一个队列，如果栈的容量分别是O和P(O>P)，则队列最大容量是 2P+1。（一次性可取最大）

用一个栈作为存储空间，另一个栈作为输出缓冲区：

<img src="/image-20211001160014288.png" alt="image-20211001160014288" style="zoom:80%;" /><img src="/image-20211001160134461.png" alt="image-20211001160134461" style="zoom:80%;" />

#### 3）栈

 peek() 	//获得当前栈顶元素，等效方法：peekFirst()
 pop() 	//获得当前栈顶元素并删除 ， 等效方法：removeFirst()
 push(E object) 	//将元素加入栈顶 

**大小为3为空的栈**，已知一组数据经过这个栈后，最终的数据顺序依次为：1 3 2 4 ，进栈数据不可能是：4231。（大小为3）

### 2、查找算法

对N个元素的链表做顺序查找时，若查找每个元素的概率相同，则平均查找长度为：(N+1)/2，（1+2+...+N=N(N+1)/2）

#### 1）二分查找

**前提：顺序存储，被查找的数组已排好序**

```java
public static int binarySearch(int[] arr, int value) {		
		int low = 0; // 开始位置
		int high = arr.length - 1; // 结束 位置		
		while(low <= high) {   //等于也要进循环
			int middle = (low + high) / 2;			
			if (value == arr[middle]) {
				return middle; //返回查询到的索引位置
			}			
			if (value > arr[middle]) {
				low = middle + 1;
			}			
			if (value < arr[middle]) {
				high = middle - 1;
			}
		}
		return -1;	//未找到，返回-1
	}
//递归
 public static int binSearch(int arr[], int start, int end, int value) {   
          	   if (start > end) return -1;    //不要等于
                int middle =  (start+end)/2;
                if (value == arr[middle]) {
                    return middle;
                } else if (value< arr[middle]) {
                    return binSearch(arr, start, middle - 1, value);
                } else {
                    return binSearch(arr, middle + 1, end,value);
                }
  } 
```

k次二分剩下元素个数：n/(2^k)，最坏时分到一个元素才找到：n/(2^k)=1	===》最坏时间复杂度 log2 n   (和hashmap的contains方法一样)

折半判定树就是一颗完全二叉树。

例：九个砝码，其中一个砝码比另八个要轻一些，至少要用天平**称 2 次**才能将轻的那个找出来

第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；第二次，一边1个，哪边轻就是哪个

### 3、排序算法

#### 1）算法分类

十种常见排序算法可以分为两大类：

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- **非比较类排序**：不通过比较来决定元素间的相对次序，也称为线性时间非比较类排序。 

<img src="/849589-20190306165258970-1789860540.png" alt="img" style="zoom:50%;" />

####  2）算法复杂度

![img](/img-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg)

- **稳定**：a=b，排序前a在b前面，排序之后a仍然在b的前面。不是下标不变。
- O(lgn)：将数据集分两半，一直分下去。O(nlgn)：是分的每一半都还要遍历一遍
- 存储结构由数组变为链表则获取指定位置的数据的算法的时间复杂度会升高，如：希尔，堆排序。相邻的不会
- 基数排序可以在 O(N) 的时间内完成整数之间的排序

#### 3）冒泡排序

**以下算法代码都是从小到大排序**

比较相邻的元素。每次确定最大元素位置放到最后

```java
public static void bubbleSort(int[] arr){
        boolean flag=false;
        for (int i=0;i<arr.length-1;++i){  //趟数,len-1次
            flag=false； //重置标志
            for (int j=0;j<arr.length-i-1;++j){
                if (arr[j]>arr[j+1]){
                    flag=true;
                	arr[j]=arr[j+1]-arr[j]+(arr[j+1]=arr[j]);
                }
            }
            if (!flag){   //有一趟没有交换冒泡说明已经排好了
                break;
            }
        }
    }
```

#### 4）简单选择排序

比较当前位置和当前位置以后的元素。每次确定最小元素放到前面

```java
 public static void selectionSort(int[] arr) { 
    	int index=0；
        for(int i = 0; i < arr.length - 1; i++) {   //趟数，len-1次
            index=i;
            for(int j = i + 1; j < arr.length; j++) {
                if(arr[index]>arr[j]) index = j;       // 将最小数的索引保存
            }
           if(index!=i) arr[i]=arr[index]-arr[i]+(arr[index]=arr[i]);
        }
}
```

#### 5）简单插入排序

<img src="/image-20210918134338901.png" alt="image-20210918134338901" style="zoom:50%;" />

将未排数在已排数中找到位置插入。**最后才能确定每个元素位置**

```java
public static void insertionSort(int[] arr){
        int j=0,temp=0;   //写在外面，不用每次都新建变量
        for (int i=1;i<arr.length;++i){
                j=i;temp=arr[j];
                while (j-1>=0&&temp<arr[j-1]){
                    arr[j]=arr[j-1];    //平移
                    j--;
                }
              arr[j]=temp;
        }
    }
```

例：对 54，38，72，60，45 进行从小到大的直接插入排序，当把45插入到有序表时，为找到插入位置需比较  **4 次**（38，54，60，72，45）多比一次哦！

#### 6）希尔排序

<img src="/image-20210918181524751.png" alt="image-20210918181524751" style="zoom:67%;" />

简单插入排序的改进版，优先比较距离较远的元素，又叫**缩小增量排序**。最后才能确定每个元素位置

```java
public static void shellSort(int[] arr){
        int j=0,temp=0; 
        for (int gap=arr.length/2;gap>0;gap/=2){
            for (int i=gap;i<arr.length;++i){
                    j = i;temp = arr[j];
                    while (j - gap >= 0 && temp < arr[j - gap]) {
                        arr[j] = arr[j - gap];
                        j -= gap;
                    }
                    arr[j] = temp;
                }
        }
    }
```

#### 7）堆排序*

初始堆是大顶堆，从下往上走，从最后叶子结点始，和兄弟节点比较找到大的值再和父结点比较，**若有交换要向下调整**。每一次排序确定最大（堆顶）元素放最后

```java
 public static void heapSort(int[] arr){
        maxHeap(arr);
        for (int i=arr.length-1;i>0;--i){   //第一个即最大，将最大的换到后面
            arr[i]=arr[0]-arr[i]+(arr[0]=arr[i]);
            adjust(arr,0,i);    //下面的都是大顶堆了，第一个根节点堆调整就行
        }
    }
    public static void maxHeap(int[] arr){    //建大顶堆，上浮
        for (int i=(arr.length-2）>>1;i>=0;--i){ //默认是一棵树，从最后一个元素的父元素开始
            adjust(arr,i,arr.length);
        }
    }
    public static void adjust(int[] arr,int i,int length){       // 下沉，length要传参
        for (int k=(i<<1)+1;k<length;k=(k<<1)+1){  //i为根节点有调整的话子树也要调整
            if (k+1<length&&arr[k]<arr[k+1]){k++;}   //长度限制
            if (arr[i]<arr[k]){
                arr[i]=arr[k]-arr[i]+(arr[k]=arr[i]);
                i=k;  //不要漏
            }else{
                break;      //下面已经是排好的大顶堆
            }
        }
    }
```

![image-20210922123628487](/image-20210922123628487.png)

最快的速度挑选出前10个最大的元素，最合适的是 堆排序。

#### 8）快速排序

每次选个基准元素将待排记录分成两份，后用分治思想递归。每一趟排序都可以确定指定的哨兵元素位置，如：3趟应该**至少有3个数字在正确位置**

快速排序一般需要先打乱数组，否则最坏情况下时间复杂度为 *O*(*n*2)

```java
//递归
quickSort(arr,0,arr.length-1);
public static void quickSort(int[] arr,int left,int right){
              if (left>=right){return;}
              int i=left;
              int j=right;
    		  int base=arr[left];
              while (i<j){
              while (i<j&&arr[j]>=base){j--;}   
              while (i<j&&arr[i]<=base){i++;}   //i写在j的下一行保证最后arr[i]<=arr[left],等于肯定要放要不第一次不走
              arr[i]=arr[j]-arr[i]+(arr[j]=arr[i]);
    }
              //最后i=j相遇
              arr[left]=arr[i];
              arr[i]=base;
              quickSort(arr,left,i-1);   //arr[i]已排好序
              quickSort(arr,i+1,right);
    }
```

#### 9）归并排序*

<img src="/image-20210918175620585.png" alt="image-20210918175620585" style="zoom:50%;" />

采用分治法，先局部排序，再将已有序的子序列合并。最后才能确定每个元素位置

```java
public static void mergeSort(int[] arr){
        int [] temp=new int[arr.length];
        mergeSort(arr,0,arr.length-1,temp);
    }
    public static void mergeSort(int[] arr,int left,int right,int[] temp){
        if (left<right){
            int mid=(left+right)>>1;
            mergeSort(arr,left,mid,temp);
            mergeSort(arr,mid+1,right,temp);
            if(arr[mid] > arr[mid+1]) {   //小优化
            merge(arr,left,right,mid,temp);
            }
        }
    }
    public static void merge(int[] arr,int left,int right,int mid,int[] temp){      //合并，之后整个数组是有序的
        int i=left,j=mid+1,t=0;
        while (i<=mid&&j<=right){
            temp[t++]=arr[i]<=arr[j]?arr[i++]:arr[j++];     //重要
        }
        while (i<=mid){ temp[t++]=arr[i++];}
        while (j<=right){   temp[t++]=arr[j++];}
        //复制
        t=0;i=left;  //不能写零
        while (i<=right){ arr[i++]=temp[t++]; }
    }
```

#### 10）基数排序

<img src="/849589-20171015232453668-1397662527.gif" alt="img" style="zoom:67%;" />

先找到最大数得其位数，先低位排序收集，再按照高位排序收集。最后才能确定每个元素位置

```java
 public static void radixSort(int[] arr) {
        int len=arr.length,max=nums[0],digit=0,idx=0;
        List<Integer>[] arr=new ArrayList[10];  //比二维数组节省内存
        for(int i=0;i<10;++i){
            arr[i]=new ArrayList<>();
        }
        for(int n:nums){    //找最大数
            max=Math.max(n,max);
        }
        for(int n=1;max/n>0;n*=10){ //从个位开始排
            //放入
            for(int i:nums){
                digit=(i/n)%10;
                arr[digit].add(i);
            }
            //取出
            idx=0;
            for(int i=0;i<10;++i){
                if(!arr[i].isEmpty()){
                    for(int j=0;j<arr[i].size();++j){
                        nums[idx++]=arr[i].get(j);
                    }
                    arr[i].clear();
                }
            }
        }
    }
```

**num % 10 表示取最后一位数字			num /10 表示小数点左移一位并去掉小数**



### 4、二叉树

#### 1）基本概念

**空树可以是任意一种树。**

**前辈节点**：层号比该结点小的结点

#### 2）树的高度

递归计算出左子树和右子树的高度，然后找出这两棵子树高度中的最大值，再加1

```java
int height(TreeNode root){
  if(root == null) return 0;   //有return，下面的有没有else都一样
   int left = height(root.left());
   int right = height(root.right());
   return Math.max(left,right)+1;
}
```

#### 3）树的遍历

前序遍历：先输出该节点，然后输出他的左孩子，最后输出他的右孩子。**前中后是看输出本节点在输出孩子节点的前中后。**

下面树的中序遍历：7 6 5 1 3

<img src="/49754179E8857A76EAF13CD0D08FCBA5" alt="img" style="zoom:80%;" />

已知：前序遍历: GDAFEMHZ；中序遍历: ADEFGHMZ；求后序遍历：先看前序遍历，第一个一定是根节点；中序遍历G的左边是左子树；重复以上步骤。

<img src="/image-20210915154945285.png" alt="image-20210915154945285" style="zoom:50%;" />

已知：中序：ADEFGHMZ 和后序：AEFDHZMG，求前序遍历：先看后序，G是根节点；看中序ADEF是左子树；ADEF看后序确定D根；重复以上步骤

已知先序序列和中序序列、后序序列和中序序列可确定一棵唯一的二叉树；**先序和后序不能确定一棵唯一的二叉树。中序分左右，前后分根**

##### 1、前中后遍历

```java
//递归
 public void preOrder(TreeNode root) {
        if (root == null) return;
            System.out.print(root.val + "->");    //前，深度优先
            preOrder(root.left);			//写在下行中序
            preOrder(root.right);
    }
//非递归，用栈实现
 public void preOrder(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while (node != null || !stack.empty()) {   //存入不为空 或 取出不为空
            if (node != null) {
                System.out.print(node.val + "->");  //前
                stack.push(node);
                node = node.left;
            } else {
                TreeNode tem = stack.pop();	//写在下行中序
                node = tem.right;
            }
        }
    }
```

##### 2、树的层序遍历

即广度优先遍历，由队列实现，先往队列中插入左节点，再插右节点，这样出队就是先左节点后右节点了。

```java
  public void levelOrder(TreeNode root) {
        if (root == null)  return;
	    Queue<TreeNode> queue = new LinkedList<TreeNode>();   //LinkedList是queue的实现
        queue.add(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            System.out.print(node.val + "->");
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
    }
```

#### 4）查找树/排序树/搜索树

排序二叉树(Binary Sort Tree，BST树)

- **没有键值相等的节点，第一个点为根节点，每次插入的节点都成为叶子节点。**
- **左子树上所有节点的值均小于它的根节点的值，右大于根。键要实现comparable接口。堆不一定左小于右**
- **中序遍历排序**二叉树可以得到由小到大的有序序列
- 最坏的情况：插入的数据本身就是排好序的，退化成了普通链表，检索效率就会很差。 

#### 5）平衡二叉树

平衡二叉树，又称AVL树(Adelson-Velskii 和 Laandis)。**为了保证不退化成线性查找，就要维持树的平衡**

- **每个节点的左子树和右子树的高度最多差1**

- 是一棵排序二叉树

- 插入(或删除)一个节点要**扫描两趟树**，一次向下查找插入点，一次向上平衡树（执行一次或两次旋转），所以AVL树不如红黑树效率高，也不如红黑树常用。

  **插入节点：注意刚插入位置要满足排序树的规则（左小右大），下图的数字有误，不用在意。先找到不平衡节点，判断类型，再旋转。**

  ①LL型：右单旋转

  　　<img src="/image-20211030195552961.png" alt="image-20211030195552961" style="zoom: 50%;" />

  　　②RR：左单旋转

  　　<img src="/1206020-20180821193753995-286858700.png" alt="img" style="zoom:50%;" />

  　　③LR型：先左后右

  　　<img src="/image-20211030200552723.png" alt="image-20211030200552723" style="zoom: 50%;" />

  　　④RL型：先右后左

  <img src="/1206020-20190217174247558-896614249.png" alt="img" style="zoom:50%;" />　　

#### 6）红黑树

**红黑树是一种不大严格的平衡二叉树**

**1）每个节点是红色或者黑色**
**2）根结点是黑的。**
**3）每个叶结点，即空结点（NIL）是黑的。**
**4）如果一个结点是红的，那么它的俩个儿子都是黑的。**
**5）每个节点到其尾端节点(NIL)的路径都包含了相同数目的黑节点**

<img src="/424830-20170526165853591-61235113.png" alt="img" style="zoom:67%;" />

**有了二叉查找树、平衡树（AVL），为啥还需要红黑树：**

**红黑树是一种不大严格的平衡二叉树，旋转平衡没有avl树多**

极端情况下，二叉树会退化成链表，时间复杂度从O(logn)退化为O(n)，所以有了平衡二叉树。

平衡二叉树对平衡的要求过于严格：左右子树的高度差最多为1。每次进行插入或删除时都要左旋和右旋来调整。但单在查找效率方面，平衡树比红黑树快。

红黑树高度近似2logn，完全二叉树/avl树高度近似logn。

#### 7）完全二叉树和满二叉树

<img src="/image-20210915161218001.png" alt="image-20210915161218001" style="zoom:67%;" />

满：每个节点的度都是2。第k层的结点数是： 2^(k-1)　　总结点数是： 2^k-1   		（等比，首项1，公比2），满二叉树的深度为k=log2(n+1)

完：节点数的范围2^ (k - 1) -1 < N< =2^k - 1，==》og2(n+1)<=k<=log2n +1 ，k向下取整log2n +1



一个二叉树有n个节点，出度为0的节点（叶子节点）个数是n0，出度为1的节点个数是n1，出度为2的节点个数是n2，则：

n = n0 + n1 +n2

n-1条边

n+1 【 2n-(n-1)=n+1】个空指针域

n0 = n2 + 1  （除了根节点，其余节点只有一个父节点，故共有n - 1 条边。即`0*n0 + 1*n1 + 2*n2=n-1` 即为边的个数。把n用n0 + n1 + n2 替换，得到）

满/完：n0 = (n +1) / 2 （完全二叉树 n1 只能等于0或1。n0为空指针域除以2）



下标：从0开始，父K，子左2K+1

#### 8）哈夫曼树和编解码

哈夫曼树是带权路径长度最短的二叉树，也称为**最优二叉树**。相同带权结点的哈夫曼树不惟一

路径：根结点到某个节点的节点序列；路径长度：等于路径上的结点数减1；带权路径：**路径长度乘该结点的权**

树的带权路径长度：树中所有叶子结点的带权路径长度之和

![image-20210915145427533](/image-20210915145427533.png)

构建哈夫曼树的图解过程：

![image-20210915145950437](/image-20210915145950437.png)

哈夫曼编码：利用哈夫曼树求得的用于通信的二进制编码称为哈夫曼编码。约定指向左子树的分支表示”0”码，指向右子树的分支表示“1”码。A，B，C，D对应的哈夫曼编码分别为：111，10，110，0；电文 ‘ABCD’ 便为 ‘111101100’（共 9 位）

![ds50](/19165415-2a99d675bbe54f0b98db7e1c8d445c0a.jpg)

**可用 n 种字符出现的频率作权**。例：字符串"hello world"，使用哈夫曼编码最少使用多少bit内存？32bit

一共有h e l o w r d和空格 八个不同的字符：某个字符个数*其编码

<img src="/image-20210918104523155.png" alt="image-20210918104523155" style="zoom:67%;" />

#### 9） 字典树

Trie树，又称单词查找树或键树。用于统计，排序和保存大量的字符串（不仅限于字符串），经常被搜索引擎系统的文本词频统计。优点是：**利用字符串的公共前缀来节约存储空间**，查询效率比哈希表高。 

根节点不含字符，其他节点都只含一个字符。从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。

建Trie树：把单词的一个个字母插入Trie树，插入前先看前缀是否存在，存在就共享，否则创建对应的节点和边。

<img src="/image-20211004204022776.png" alt="image-20211004204022776" style="zoom: 80%;" />

#### 10）大小顶堆

堆一般是完全二叉树。根节点下标是0的情况下，i 节点的子节点下标是2i+1和 2i+2。

最大堆/大顶堆/大根堆：根结点最大，且每个结点的值都比其孩子的值大。

最小堆：根结点最小，且每个结点的值都比其孩子的值小。

插入在最后，删除根节点字节点换上

#### 11）线索化二叉树

一般的二叉树，叶子节点的左右指针都为空，这样就会造成**空间的浪费**。n个结点的二叉链表中含有 n+1 【 2n-(n-1)=n+1】个空指针域

线索化二叉树：线索二叉树可分为**前序/中序/后序线索二叉树三种**。按中序遍历的顺序，叶子节点的左指针指向它的前驱节点，右指针指向它的后驱节点，形成中序线索化二叉树，把一棵二叉树转变成了一个“特殊的双向链表“，新增、删除、查找节点带来了方便

<img src="/f4a82313574b58e839fbcb303545d6e9.png" alt="f4a82313574b58e839fbcb303545d6e9.png" style="zoom:80%;" />

```java
// 中序线索化
	private void midThreaded(Student node) {
		if(node == null) return;
		//左线索化
		midThreaded(node.getLeft());        
		//线索化当前节点，左指针和左边指向自己的指针（前驱节点的右指针）
		//如果当前节点的左指针为空，就指向前驱节点，并改变左指针类型
		if(node.getLeft() == null) {
			node.setLeft(pre);
			node.setLeftType(1);  //左、右指针的类型，0-->指向的是左右孩子，1-->指向的是前驱、后续节点
		}
		if(pre != null && pre.getRight() == null) {
			pre.setRight(node);
			pre.setRightType(1);
		}
		//处理一个节点后，让当前节点变为下一个节点的前驱节点
		pre = node;
		//右线索化
		midThreaded(node.getRight());
	}
```

#### 12）解空间树搜索算法

回溯法：一个结点有多次机会成为活结点

<img src="/image-20210928194236375.png" alt="image-20210928194236375" style="zoom:50%;" />



### 5、图

#### 1）基础概念

**线性表可以是空表，树可以是空树，但图不可以是空图。**

图(Graph)：表示“多对多”关系的数据结构。**每条边都没有方向，则称该图为无向图。条边都有方向为有向图。**
图的组成：图G由一个非空的有限**顶点集合V(G)**和一个有限**边集合E(G)**组成，定义为G=(V，E)。
顶点的度：无向图度表示以该顶点作为一个端点的边的数目；有向图分为入度和出度，该顶点的度等于其入度和出度之和。
图的表示：
	邻接矩阵：使用一个二维数组 `G[N][N]`存储图，**如果顶点 Vi 和 顶点 Vj 之间有边，则 `G[Vi][Vj]` = 1** 或 weight。邻接矩阵是对称的。
	邻接表：**邻接表由数组+单链表组成**。邻接于某个顶点的节点链成一个单链表，邻接表只有存在的边，此没有空间浪费。

​	**使用场景：邻接表占用空间少，适合存储稀疏图；邻接矩阵适合存储稠密图。要直接判断两个结点之间是否有边连接用邻接矩阵。**
环：某条路径包含相同的顶点两次或两次以上。
有向无环图：没有环的有向图，简称DAG。
带权有向图的最短路径长度：源点Vm到终点Vn的所有路径中，权值和最小的路径是最短路径，其长度是最短路径长度。
完全图：**任意两个顶点都相连的图称为完全图，**又分为无向完全图和有向完全图。**n个端点的有向图：n（n-1） 无向图：n(n-1)/2 条边**
连通图：在无向图中，若任意两个顶点都有路径相通，则称该无向图为连通图，至少n-1条边。

强连通图：**在有向图中**，若任意两个顶点都有路径相通。

**极小连通图：**保持图的联通性，还要求子图的边数最少。

连通网：带权值的连通图叫做连通网。
树与图的关系：树的定义：有且只有一个结点的入度为0，**其他节点的入度为1**。任何两个顶点只通过一条路径连接。 一个**没有环路**的无向连通图是一棵树。

![image-20210919142824072](/image-20210919142824072.png)

#### 2）深度优先遍历(DFS)

**类似于树的前序遍历。**起始顶点开始访问下一点，再以下一个点为起始点访问未访问过的点，一直访问下去直到没有未访问过的顶点时，则回溯到上一个顶点，继续试探别的顶点，直至所有的顶点都被访问过。如果还有顶点未被访问到，则随机选一个未访问的作为起始点重复深度遍历，直到图中的所有节点均被访问过。

有向图的深度遍历：A -> B -> F -> H -> G -> C -> D -> E。ABCD按顺序存储，B在"C和F"的前面，先访问B。G点时B访问过就不访问了

<img src="/image-20210920205622411.png" alt="image-20210920205622411" style="zoom: 80%;" />

<img src="/image-20210920221426708.png" alt="image-20210920221426708" style="zoom: 67%;" />

```java
private int number = 9;	// 顶点数
private boolean[] flag;
void DFSTraverse() {
flag = new boolean[number];
	for (int i = 0; i < number; i++) {
		if (flag[i] == false) {// 当前顶点没有被访问
			DFS(i);
		}
	}
}
// 图的深度优先递归算法
void DFS(int i) {
flag[i] = true;// 第i个顶点被访问
System.out.print(vertexs[i] + " ");
	for (int j = 0; j < number; j++) {
		if (flag[j] == false && edges[i][j] == 1) {
			DFS(j);
		}
	}
}

//Node节点表示有向图
 public static void Dfs(Node node){   //调整为有向树就不用visit变量了
        //。。。。。操作
        if(node.sonList.size()==0)return;  //不用出口也行，不用回溯
        for(Node n:node.sonList){
            Dfs(n,cnt);
        }
    }
```

#### 3）广度优先遍历(BFS)

**类似于树的层序遍历，一般用队列实现。**从图中某个顶点v0出发，先访问v0，再依次访问v0的各个未被访问的邻接点，再依次从上述邻接点出发，访问他们的各个未被访问的邻接点。如果还有顶点未被访问到，则随机选一个未访问的作为起始点重复深度遍历，直到图中的所有节点均被访问过。

![广度优先搜索遍历(BFS)](/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy85MGRMRTZpYnNnMGZObkJld0xDSzQyUUJsZXBEWWh6b0VFUFJWTE1CSllkTEFnWUwzZzNoTWFwNzR2MXR0aWFzZDE5c1dMR3dCVnhtb01EaWJkSm1tYzJPdy82NDA)

```java
void BFSTraverse() {
flag = new boolean[number];
Queue<Integer> queue = new LinkedList<Integer>();
	for (int i = 0; i < number; i++) {
		if (flag[i] == false) {		
			flag[i] = true;
			System.out.print(vertexs[i] + " ");
			queue.add(i);
			while (!queue.isEmpty()) {
				int j = queue.poll();
					for (int k = 0; k < number; k++) {
						if (edges[j][k] == 1 && flag[k] == false) {
								flag[k] = true;
							System.out.print(vertexs[k] + " ");
							queue.add(k);
                        }
                    }
			}
		}
    }
}
```

#### 4）最小生成树

**图的生成树：包含图的所有节点且仅有n-1边的子图，是没有环的。最小生成树（MST）：所有边权值和最小的生成树**。求最小生成树的算法：

两个算法的区别：都使用了贪心算法的思想。加边法适合稀疏图（边少）时间复杂度：O(MlogN) 边：M，点N。加点法适合稠密图，时复杂度：O(N^2)

##### 1、Kruskal算法(加边法)

克鲁斯卡尔算法：边按权值从小到大排序，**每次选择一条最小权值并且不会产生回路的边**，加入到最小生成树的边集合里。

终点：连通权值最大的点。回路：加入边的两个节点不能有相同的终点，否则形成回路。

![image-20210920171331606](/image-20210920171331606.png)

例：如下的无向图中有多少个不同的最小生成树：3*2=6。没有起点用加边法，先选权值1的边

![img](/388501259_1550932088357_E6C688B0A3BBCBBE62A8F4A2AE0318D5)

##### 2、Prim算法(加点法)

普里姆算法：所有顶点集合为V，初始集合u={A}，v=V−u；每一次选择 u集合中点的没有访问的最小权值的边对应的点，加入u中。**广度优先遍历**

<img src="/image-20210920165144633.png" alt="image-20210920165144633" style="zoom:67%;" />

#### 5） 最短路径

**最短路径：**某一个顶点到另其他顶点的最短路径。

##### 1、Dijkstra算法

迪杰斯特拉算法**：用动态规划思想实现，执行广度优先遍历，每次选从顶点到新点的相邻点的最短路径。**

顶点集合 V[0,0,0,0,0]，访问过的就置为1；出发顶点v1 到各顶点的距离构成距离集合Dis{d1,d2,di...}，不通为无穷大；前驱节点数组pre[5,0,5,5,5]

![image-20210920182642615](/image-20210920182642615.png)

```java
	for (int[] arr : adj) {
            Arrays.fill(arr, Integer.MAX_VALUE);  //二维数组赋值，等价于两个for循环中f[i][j] = Integer.MAX_VALUE;
        }
	 for(int[] arr : maxValue) {
         System.out.println(Arrays.toString(arr));  //打印二维数组
      }
```

##### 2、Floyd算法

**弗洛伊德算法：每一个顶点都是出发点，求各个顶点之间的最短路径，时间复杂度较高但较好实现。迪杰斯特拉是计算某一个顶点到其他顶点的最短路径。**

![image-20210920185051490](/image-20210920185051490.png)

选取某个节点m作为 i 到 j 需要经过的中间节点（三层for循环），通过比较d(i,m)+d(k,m) 和现有 d(i,j) 的大小，将较小值更新为路径长度。

```java
public class FloydAlgorithm {
    public static int MaxValue = 100000;
    public static int[][] path;
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);       
        int vertex = input.nextInt(); //顶点数        
        int edge = input.nextInt();//边数
        int[][] matrix = new int[vertex][vertex];
        path = new int[vertex][vertex];        //初始化路径数组，即前驱表
        //初始化邻接矩阵
        for (int[] m:matrix) {
             Arrays.fill(m,MaxValue);  //将数组m中的元素都填充为MaxValue 
        }
        //初始化边权值
        for (int i = 0; i < edge; i++) {
            int source = input.nextInt();
            int target = input.nextInt();
            int weight = input.nextInt();
            matrix[source][target] = weight;
        } 
        for (int[] p:path) {
             Arrays.fill(p,-1);   
        }       
        floyd(matrix);
    }
    public static void floyd(int[][] matrix) {
        for (int m = 0; m < matrix.length; m++) {  
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < matrix.length; j++) {
                    if (matrix[i][m] + matrix[m][j] < matrix[i][j]) {
                        matrix[i][j] = matrix[i][m] + matrix[m][j];                       
                        path[i][j] = m; //记录经由哪个点到达
                    }
                }
            }
        }
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix.length; j++) {
                if (i != j) {
                    if (matrix[i][j] == MaxValue) {
                        System.out.println(i + "到" + j + "不可达");
                    } else {
                        System.out.print(i + "到" + j + "的最短路径长度是：" + matrix[i][j]);
                        System.out.print("最短路径为：" + i + "->");
                        findPath(i, j);
                        System.out.println(j);
                    }
                }
            }
        }
    }
    //递归寻找路径
    public static void findPath(int i, int j) {
        int m = path[i][j];
        if (m == -1) {
            return;
        } 
        findPath(i, m);
        System.out.print(m + "->");
        findPath(m, j);
    }
}
```

#### 6）拓扑排序

拓扑排序（Topological Sorting）是一个有向无环图（DAG）的所有顶点的线性序列。

先找出任意一个没有入边的顶点，然后打印该顶点，并将它及其边一起从图中剔除，然后对其余的部分继续这个操作



### 6、算法思想

#### 1）回溯/递归算法

八皇后问题：在 8×8格的国际象棋上摆放八个皇后，任意两个皇后都**不能处于同一行、同一列或同一斜线上**，问有多少种摆法(92)。

解析：将第一个皇后放在第一行第一列，将第二个皇后放在第二行第一列，若会相互攻击，则放到第二列…直到不会攻击，将第三个皇后放在第三行第一列……，当八个都放好就得到一个正确的解，就回溯到上一行继续尝试

```java
public class Demo3 {
   static int sum = 0;
   int  max = 8;
   int[] arr = new int[max];
   public static void main(String[] args) {
      Demo3 demo = new Demo3();
      demo.put(0);
      System.out.println("一共有"+sum+"种放法");
   }
   public boolean judge(int position) {
      for(int i = 0; i<position; i++) {
         //因为数组下标代表行数，所以不会存在皇后在同一行,如果两个皇后在同一列或者同一斜线(行号-行号是否等于列号-列号，且列号相减要取绝对值)，就冲突
         if(arr[i] == arr[position] || (position-i) == Math.abs(arr[position]-arr[i])) {
            return true;
         }
      }
      return false;
   }
   public void put(int queen) {   
      if(queen == max)   { sum++;  return;}
      for(int i = 0; i<max; i++) {
         //把当前皇后放在第i列
         arr[queen] = i;
         if(!judge(queen)) {  //判断该位置的皇后与前面几个是否冲突，不冲突，就去放下一个皇后            
           put(queen+1);
         }
      }
   }
}
```

#### 2）分治算法

分解：将原问题分解为若干与原问题形式相同的子问题；	解决；	合并：将子问题的解合并为原问题的解；  快速/分治排序，

汉诺塔问题：A、B、C三个塔，从小到大所有盘在A，小盘只能放大盘上，要将所有盘都移到C上。

- 如果只有一个盘，直接A->C

- 如果大于等于两个盘，就分成两部分。

  最下面的一个盘为一部分，上面的所有盘为一部分。将上面部分的盘A->B；最下面的盘A->C；再将B中的盘B->C

```java
public static void hanoiTower(int num, char a, char b, char c) {
      //如果只有一个盘，把这个盘从A移动到C
      if(num == 1) {
         System.out.println("把第" + num + "个盘从" + a + "->" + c);
         return;
      }
      //如果大于等于两个盘，将上面部分的盘从A借助C移动到B
      hanoiTower(num-1, a, c, b);
      //把最下面的盘从A移动到C
      System.out.println("把第" + num + "个盘从" + a + "->" + c);
      //把上面部分的盘从B借助A移动到C
      hanoiTower(num-1, b, a, c);
   }
}
```

#### 3）动态规划

##### 01背包问题

将大问题划分为小问题获取最优解的处理算法。与分治法不同，分解的**子问题往往不是互相独立的**（下一个求解是建立在上一个解基础上的）。

背包问题：一个背包最多装4kg，求装入物品使得背包的总价值最大，要求：不超出背包的容量，装入物品不能重复（关键，可重复算性价比用贪心）

| 物品 | 重量 | 价值 |
| ---- | ---- | ---- |
| 吉他 | 1    | 1500 |
| 音响 | 4    | 3000 |
| 电脑 | 3    | 2000 |

<img src="/image-20210920144009913.png" alt="image-20210920144009913" style="zoom:50%;" />

能不能放，要不要放：

<img src="/image-20211108191653996.png" alt="image-20211108191653996" style="zoom: 50%;" />

```java
/**
v[i][j]表示在前i个物品中能够装入容量为 j的背包中的最大价值。 v[i]、w[i]分别为第 i个物品的价值和重量，
v[i][0]=v[0][j]=0; //表示填入表的第一行和第一列是 0，主要是为了方便表示物品和容量
*/
public class Demo2 {
   public static void main(String[] args) {
      //各个物品的重量
      int[] weight = {1, 4, 3};
      //各个物品的价值
      int[] value = {1500, 3000, 2000};
      //背包的最大容量
      int maxSize = 4;
      //各种方法的价值的最大值，第0行和第0列值为0，方便后续操作
      int[][] maxValue = new int[value.length+1][maxSize+1];
      //用于表示物品放入背包的方式
      int[][] method = new int[value.length+1][maxSize+1];
      //依次将物品放入背包，0行0列都是0不用赋值
      for(int i = 1; i<4; i++) {
         for(int j = 1; j<maxSize; j++) {
            //如果物品的重量大于背包剩余的容量，就不放入
            if(weight[i-1] > j) {	           
               maxValue[i][j] = maxValue[i-1][j];// 当准备加入新增的商品的重量大于当前背包的容量时，就直接使用上一个单元格的装入策略
            } else {
               //背包剩余的容量
               int remaining = j - weight[i-1];
               //如果放入该物品前的最大价值大于放入该物品后的最大价值，就不放入该物品
               if(maxValue[i-1][j] > value[i-1]+maxValue[i-1][remaining]) {   //重点
                  maxValue[i][j] = maxValue[i-1][j];
               } else {
                  maxValue[i][j] = value[i-1]+maxValue[i-1][remaining];
                  //存入放入方法
                  method[i][j] = 1;
               }
            }
         }
      }
      //打印放入背包的最大价值，打印二维数组
      for(int[] arr : maxValue) {
         System.out.println(Arrays.toString(arr));
      }
      //打印价值最大的放法
      //存放方法的二维数组的最大下标，从最后开始搜索存放方法
      int i = method.length - 1;
      int j = method[0].length - 1;
      while(i > 0 && j > 0) {
         if(method[i][j] == 1) {
            System.out.println("将第" + i + "个物品放入背包");
            //背包剩余容量
            j -= weight[i-1];
         }
         i--;
      }
   }
}
将第3个物品放入背包
将第1个物品放入背包
```

#### 4）KMP算法

检查字符串在文本串是否出现过，如果出现过，找出第一次出现的位置，没有出现就返回-1。

KMP 算法思想：不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。

如：判断 str1 是否含有 str2，对 str2计算出一张**部分匹配表。移动位数 = 已匹配的字符数 - 到最后一个匹配字符的部分匹配值**

部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度：

<img src="/image-20210919205610972.png" alt="image-20210919205610972" style="zoom: 67%;" />

<img src="/20200803144203.png" alt="img" style="zoom: 33%;" />===移动：6-2=4位=======》<img src="/20200803144832.png" alt="img" style="zoom:33%;" />

```java
  /**
    *得部分匹配表
    * @param matchStr 用于匹配的字符串
    * @return 部分匹配表
    */
   public static int[] getTable(String matchStr) {
      //部分匹配值的数组
      int[] sectionTable = new int[matchStr.length()];
      //匹配字符串的第一个元素没有前缀与后缀，部分匹配值为0
      sectionTable[0] = 0;
      //i用来指向部分匹配字符串末尾的字符，j用来指向开始的字符
      for(int i = 1, j = 0; i<matchStr.length(); i++) {
         //当j>0且前缀后缀不匹配时
         while (j > 0 && matchStr.charAt(j) != matchStr.charAt(i)) {	//循环直到相等或者j=0
            j = sectionTable[j-1];//j=部分匹配表中前一个表项的值，这是重点
         }
         //如果前缀后缀匹配，j向后移，继续比较
         if(matchStr.charAt(j) == matchStr.charAt(i)) {
            j++;
         }
         //存入匹配值
         sectionTable[i] = j;
      }
      return sectionTable;
   }
   /**
    * 通过KMP算法匹配字符串，若匹配成功，返回第一个字符出现的位置
    * @param str1 用于匹配的字符串
    * @param str2 要匹配的字符串
    * @return 第一个字符出现的位置，没有则返回-1
    */
   public static int getPosition(String str1, String str2) {
      //获得str2的部分匹配表
      int[] sectionTable = getTable(str2);
      for(int i = 0, j = 0; i < str1.length(); i++) {
         //两个字符匹配
         if(str1.charAt(i) == str2.charAt(j)) {
            j++;
            if(j == str2.length()) {
               //如果匹配完成，返回第一个字符出现位置
               return i - str2.length() + 1;
            }
         } else {
            //如果匹配失败了，使用部分匹配表，跳转到str1对应位置
            //如果j==0，说明没有字符被被匹配，直接让i指向str1的下一个字符
            if(j == 0) {
               continue;
            }
            //跳转步数 = 已经匹配的字符个数 - 部分匹配表对应的值
            int position = j - sectionTable[j-1];
            i += position;
            //因为循环后会+1，所以此处i-1
            i--;
            //重置j，重新匹配
            j = 0;
         }
      }
      return -1;
   }
```

#### 5）贪心算法

**每一步选择都采取最优选择，结果是近似最优解，不一定是最优的结果**

1、电台问题：如何选择最少的广播台，让所有的地区都可以接收到信号。

先写出地区集合，每次找到一个覆盖了最多地区的电台加入电台集合并将电台已经覆盖的地区去掉。

<img src="/20200804125936.png" alt="img" style="zoom: 67%;" />

<img src="/20200804130307.png" alt="img" style="zoom: 67%;" />

<img src="/20200804130307.png" alt="img" style="zoom:67%;" />

```java
HashMap<String, HashSet<String>> broadcasts //创建广播电台,放入到Map
HashSet<String> allAreas //存放所有的地区
		//创建ArrayList, 存放选择的电台集合
		ArrayList<String> selects = new ArrayList<String>();
		//存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
		HashSet<String> tempSet = new HashSet<String>();
		while (allAreas.size() != 0) { 
		//maxKey 能够覆盖最大未覆盖的地区对应的电台的key
			String maxKey = null;
			//遍历 broadcasts, 取出对应key
			for (String key : broadcasts.keySet()) {
				tempSet.clear();
				//当前这个key能够覆盖的地区
				HashSet<String> areas = broadcasts.get(key);
				tempSet.addAll(areas);
				//求出tempSet 和 allAreas 集合的交集, 交集会赋给 tempSet
				tempSet.retainAll(allAreas);
				//如果当前这个集合包含的未覆盖地区的数量比maxKey指向的集合地区还多，就需要重置maxKey
				//体现出贪心算法的特点,每次都选择最优的
				if (tempSet.size() > 0 && (maxKey == null || tempSet.size() > broadcasts.get(maxKey).size())) {
					maxKey = key;
				}
			}
			//maxKey != null, 就应该将maxKey 加入selects
			if (maxKey != null) {
				selects.add(maxKey);
				//将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉
				allAreas.removeAll(broadcasts.get(maxKey));
				broadcasts.remove(maxKey);
			}
		}
		System.out.println("得到的选择结果是" + selects);//[K1,K2,K3,K5]
	}
```

2、钱币找零问题：纸币金额为1元、5元、10元、20元、50元、100元，要凑成123元应该尽可能兑换少的纸币

尽可能从大面值一直往下减即可

```java
   public static void splitChange(int money) {
      int[] prices = {100, 50, 20, 10, 5, 1};
      //用于记录每种纸币的数量，下标与prices数组的下标对应
      int[] counts = new int[prices.length];
      //剩下的金额
      int surplus = money;
      if(money > 0) {
         while(surplus > 0) {
            //从大金额向小金额进行凑数
            for(int i = 0; i<prices.length; i++) {
               //每张钱币的数量
               int count = 0;
               //如果该金额的钱币小于总金额，该钱币数量+1
               while (surplus - prices[i] >= 0) {
                  count++;
                  surplus -= prices[i];
               }
               counts[i] = count;
            }
         }
      }
```



### 7、海量数据处理的方法

**基础知识：**

- bit：位

- byte（B）：字节

   **1B（Byte，字节）=8b（bit，位）**
    1024=2^10
     1 GB = 2^10MB=2^20KB=2^30B=10.7亿=2.6亿个int

- int /unsigned int 类型为 4 byte(32位)，范围： 2^31=21.4亿

- 在时间复杂度中，log(2,n)(以2为底)与lg(n)(以10为底)是等价的，因为对数换底公式：log(a,b)=log(c,b)/log(c,a)，故log(2,n)=log(2,10)*lg(n)，忽略掉系数

#### 1）hash映射/分解 + hashmap统计 + 快速/归并/堆排序

**分治思想是解决空间限制典型思想，**即海量数据不能一次性读入内存，而我们需要对海量数据进行的计数、排序等操作。基本思路如下图所示：**先借助哈希算法，计算每一条数据的 hash 值，按照 hash 值将海量数据分布存储到多个桶中，再依次处理这些小文件，最后做合并运算即可。**

<img src="/image-20210906203010096.png" alt="image-20210906203010096" style="zoom: 67%;" />

**问题1：**海量日志数据，统计出某日访问百度次数最多的那个IP

解决方式：IP地址最多有 2^32 = 4G 种取值情况，所以不能完全加载到内存中进行处理

（1）按照 IP 地址的 Hash(IP)%1024 值，把海量IP日志分别存储到1024个小文件中，**如果某个小文件大小还大于内存，进行多级hash；** 
（2）对于每一个小文件，构建一个IP为key，出现次数为value的Hash map/字典树，**小顶堆取出每个文件出现次数最多的那个IP地址**（若要求top10，采用包**含10个元素的小顶堆完成**）
（3）然后归并，在这1024组最大的IP中，找出那个频率最大的IP
**问题2**：有a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？

解决方案1：如果内存中想要存入所有的 url，共需要 50亿 * 64= 320G大小空间。

（1）将a、b两个文件，分别求取hash(url)%1024，然后根据所取得的值将 url 分别存储到1024个小文件（a0~a1023）中。这样每个小文件的大约为300M。如果hash结果很集中使得某个文件过大，还可以按照hash继续往下分，最后分解得到的小文件的大小都不超过4G即可。
（2）把a中一个小文件的 url 存储到 hashmap 中，然后遍历b中一个小文件的每个url，看其是否在刚才构建的 hashmap 中，如果是，那么就是共同的url，存到文件中，如此对比a和b中的每个小文件。
（3）把1024个文件中的相同 url 合并起来
解决方案2：**Bloom filter求交集**

如果允许有一定的错误率，可以使用 Bloom filter，4G内存大概可以表示 340 亿bit，n = 50亿，如果按照出错率0.01算需要的大概是650亿个bit，现在可用的是340亿，相差并不多，这样可能会使出错率上升些，将其中一个文件中的 url 使用 Bloom filter 映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter相同，如果是，那么该url应该是共同的url（注意会有一定的错误率）

若是多个文件：依次遍历每个大文件中的每条数据，如果Bloom Filter中不存在，则插入Bloom Filter；如果已经存在，则在另外的集合中记录下来；

问题3：一共有N个机器，每个机器上有N个数，每个机器最多存 N 个数，如何找到 N^2 个数中的中数？
解决方案： 分而治之 + 归并

先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。找到第（N^2）/2个便是所求。复杂度是O（N^2 * lgN^2）的

#### 2）Trie树/hashmap+堆

Trie树、红黑树 和 hashmap 可以认为是分治算法的具体实现方法之一。

其中，**Trie树即 字典树，**适合处理海量字符串数据，尤其是大量的字符串数据中存在前缀时，用于**统计，排序和存储大量的字符串**（不仅限于字符串）。

用于存储时，Trie树因为重复存储公共前缀，节省了大量的存储空间；在字符串统计中，**Trie树能够快速记录每个字符串出现的次数，任意数据量的字符串集合中都能以O(len)的时间复杂度完成查找（len为要检索的字符串长度）；**

**问题1：**有一千万个字符串记录（这些字符串的重复率比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个），每个查询串的长度为1-255字节。请你统计最热门的10个查询串（重复度越高，说明越热门），要求使用的内存不能超过1G。

解决思路： trie树 + 堆排序

**用 trie树 统计每个词出现的次数，**时间复杂度是O(n***len)（len表示单词的平均长度）。
然后使用小顶堆找出出现最频繁的前10个词，**时间复杂度是O(n*lg10)。

内存不能超过 1G，每条记录是 255byte，1000W 条记录需要要占据2.375G内存，这个条件就不满足要求了，但是去重后只有 300W 条记录，最多占用0.75G内存，因此可以将它们都存进内存中去。使用 trie树（或者使用hashmap），关键字域存该查询串出现的次数。最后用10个元素的最小堆来对出现频率进行排序。**总的时间复杂度，是O(n*le)与O(n*lg10)中较大的那一个。**

#### 3）BitMap 和 Bloom Filter

 位图（BitMap）：每一位来存放某种状态（存不存在），**适用于大规模数据，但数据状态又不是很多的情况。**使用场景：利用二进制的一位来表示磁盘中的盘块的使用情况。0表示对应的盘块为空闲，1已分配。本质上是压缩存储来方便**磁盘空间的管理。**

 布隆过滤器（Bloom Filter）：对位图的一种改进，底层是**一个很长的二进制矢量和一系列随机映射函数。可以用来快速判断一个元素是否在一个集合中**
原理： 布隆过滤器有一个位数组（每一位都是二进制位），还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值；再根据**得到的哈希值在位数组中把对应下标的值置为 1**。

随着元素插入的增加，当一个不在布隆过滤器中的元素，经过同样规则的哈希计算之后，数组中把对应下标的值**可能被之前其它元素的操作先置为 1 了。** 这就是布隆过滤器的缺陷：存在误判。**判断不在的一定不在 （False is always false. True is maybe true），元素越多，false positive rate(误报率)越大**

1、一般适合的处理数据范围小于 8bit *2^32。否则内存超过4G，内存资源消耗有点多。

2、Bloom Filter 主要是用于**判定目标数据是否存在于一个海量数据集 以及 集合求交集**。以 O(k) 的时间复杂度判定目标数据的存在性，k为使用的hash函数个数

问题1：现有两个各有20亿行的文件，每一行都只有一个数字，求这两个文件的交集。 

解决方案：采用 bitmap 进行问题解决，因为 int 的范围是 2^32 = 4G，用一个二进制的下标来表示一个 int 值，大概需要4G个bit位，即约4G/8 = 512M的内存，就可以解决问题了。

① 首先遍历文件，将每个文件按照数字的正数，负数标记到2个 bitmap 上，为：正数 bitmapA_positive，负数 bitmapA_negative
② 遍历另为一个文件，生成正数：bitmapB_positive，bitmapB_negative
③ 取 bitmapA_positive and bitmapB_positive 得到2个文件的正数的交集，同理得到负数的交集。
④ 合并，问题解决
这里一次只能解决全正数，或全负数，所以要分两次

#### 4）求交集

 十亿个数的集合和 10w 个数的集合，如何求它们的交集。

对小数组做 hash，然后遍历大数组即可
