---
typora-copy-images-to: images
typora-root-url: images
---



# 第一季  JavaSE

## 1、自增变量

自增自减也不是原子操作：i++ 分为 3 步

JVM从局部变量表中取出变量i，**把变量压入操作栈，然后对局部变量表中的变量i自增**，之后将操作栈中的数据取出来使用。

++i : 从局部变量表中取出变量，**对局部变量表中的变量i自增一，然后把变量压入操作栈**，之后就将操作栈中的数据取出来使用

```java
  public static void main(String[] args) {
        int i = 1;
        i = i++; //将变量从局部变量表的第1个Slot取出并放到操作数栈顶，将局部变量表的变量加1，再从操作数栈顶取出到局部变量表覆盖
        int j = i++;
        int k = i + ++i * i++;
        System.out.println("i=" + i);
        System.out.println("j=" + j);
        System.out.println("k=" + k);
    }
```

<img src="/Snipaste_2020-09-22_13-24-00.png"  />

i++ 计算后将值给到 j ，i=2，j=1.

<img src="/Snipaste_2020-09-22_13-25-04.png" style="zoom: 67%;" />

最后一步，**从左到右加入操作数栈，再按优先级计算，**i=4，j=1，k=11

<img src="/Snipaste_2020-09-22_13-26-36.png" style="zoom: 67%;" />

总结：

​	赋值=，最后计算
​	**=右边的从左到右加载值依次压入操作数栈。实际先算哪个，看运算符优先级**
​	自增、自减操作都是直接修改变量的值（局部变量表），不经过操作数栈。++i 和 i++区别是看先自增还是先入操作数栈

​	最后的赋值之前，临时结果也是存储在操作数栈中

## 2、单例模式

### 1、Singleton

单：唯一				例：实例

例如：代表JVM运行环境的**Runtime类**

### 2、常见形式

#### 饿汉式

**直接创建对象，无线程安全问题**

**实现1：直接实例化饿汉式**

```java
public final class Singleton implements Serializable { 		//加 final为了防止子类继承更改   
    private Singleton() {}    // 构造器私有，防止其它类中使用new生成新的实例，这样不能防止反射创建新的实例。
    //final不能修改， 静态成员变量在类加载阶段完成，jvm保证了初始化的线程安全性，不管是否需要都会创建
    private static final Singleton INSTANCE = new Singleton();
    //为什么提供静态方法而不是直接将 INSTANCE 设置为 public(对外提供)： 1.提供更好的封装性；2.提供泛型的支持
    public static Singleton getInstance() {
        return INSTANCE;
    }
    //如果实现了序列化接口,进行反序列化的时候会生成新的对象，这样跟单例模式生成的对象是不同的。要解决直接加上readResolve()方法就行了
    public Object readResolve() {
        return INSTANCE;
    }
}
```

**实现2： 枚举类饿汉式**   ，可防止反射和反序列化破坏对象，也是Singleton.INSTANCE 调用  （最简洁，推荐）

```java
// 问题1：枚举类型，表示该类型对象是有限个数：创建枚举类的时候限定一个就成了单例，每个枚举常量其实就是枚举类的一个静态成员变量
// 问题2：枚举单例在创建时是否有并发问题：没有，这是静态成员变量，jvm保证了此操作的线程安全性
// 枚举单例可以防止反射、反序列化破坏单例：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例
// 问题5：枚举单例属于懒汉式还是饿汉式：饿汉式，静态成员变量随类的加载而加载
// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做：加构造方法就行了
enum Singleton {
 INSTANCE;
}
```

**实现3：静态代码块饿汉式(适合复杂实例化)**

```java
public final class Singleton {
    public static final Singleton INSTANCE;   //和下面的static代码合成cinit()类初始化方法，线程安全
    private int age;
    static {
        try {
            Properties pro=new Properties();
            pro.load(Singleton.class.getClassLoader().getResourceAsStream("文件名"))；
            INSTANCE = new Singleton(pro.getProperty("age"));  
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    private Singleton(int age) {
        this.age =age;
    }
}
```

#### 懒汉式

**延迟创建对象**

**实现4：DCL 双重检查懒汉式**

```java
 public final class Singleton {
        private Singleton() { }
        private static volatile Singleton INSTANCE = null;    // volatile禁用指令重排，new对象会有三步：开辟空间，复制（构造器用），赋值
        public static Singleton getInstance() {
            if(INSTANCE == null) {    			 // 提高了性能，不用每一次都加锁        
                synchronized(Singleton.class) {       //不能锁INSTANCE变量，可能为null  
                    if (INSTANCE == null) {          //仅外面的判断不能保证原子性，有并发问题：两个线程同时拿到null值，不能保证单例
                        INSTANCE = new Singleton();
                    }
                }
            }
            return INSTANCE;
        }
    }
```

**实现5：静态内部类懒汉式**（推荐）

```java
public final class Singleton {
    private Singleton() { }     
//静态内部类，可访问外部类私有构造；类的初始化是懒惰的，没调用getInstance类是不加载的；只初始化一次保证是单例且JVM保证类的初始化(cinit())是线程安全的
    private static class Inner { 	//不要忘记static	
        static final Singleton INSTANCE= new Singleton();   //引用类型的静态常量
    } 
    public static Singleton getInstance() {      
        return Inner.INSTANCE; 
    }
}
```



## 3、类初始化实例初始化

类的初始化（clinit方法），类的实例化（调用构造方法，内存中申请一块内存空间，属性是默认值），实例的初始化（构造/init方法，给属性完成赋值操作）

### 1、类初始化clinit

> 先判断会不会引发类的初始化
>
> **main方法所在的类需要先加载和初始化**（main中没有创建实例时也初始化）
>
> 子类要初始化需要先初始化父类，第一个被执行的<clinit>（）方法的类肯定是java.lang.Object，<clinit>（）方法对于类或接口来说并不是必须的
>
> ​		**<clinit>()方法static变量显示赋值代码和静态代码块代码从上到下执行**
>
> ​		**<clinit>()方法只调用一次**

### 2、实例初始化过程init

> ​	<init>()方法可能重载有多个，有几个构造器就有几个<init>()方法
>
> ​	<init>()方法由非静态实例变量显示赋值代码和非静态代码块，对应构造器代码组成
>
> ​	**非静态实例变量显示赋值代码和非静态代码块从上到下顺序执行，而对应构造器的代码最后执行**
>
> ​	每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法
>
> ​	<init>方法的首行是super()和super(实参列表) ,即对应父类的<init>方法

### 3、方法的重写/覆盖

对象的多态性：子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码（非静态方法默认的调用对象是this，this对象在构造器或者说<init>，**表示的是正在创建的对象**，若正在创建子类对象则调用子类重写的代码(面向对象多态)）

注：Override重写要求：**两同两小一大**原则：

​			方法名，形参列表相同；

​			子类返回类型小于等于父类方法返回类型（1.5前必须相同）；子类抛出异常小于等于父类方法抛出异常；
​			子类访问权限大于等于父类方法访问权限。（接口也一样要求，方法头指：修饰符+返回值类型+方法名（形参列表））

​		构造方法、final、static（能被再次声明）、private方法不能被重写；子父类不在同个包中，子类只能重写父类声明 public /protected 的非 final 方法

Overload重载：发生在同一个类中，要求：方法名一致，参数列表不一致（个数/类型/顺序）；返回类型和方法的修饰符可以不相同

##### Father.java

```java
public class Father {
    private int i = test();
    private static int j = method();  //类的初始化会从上到下执行静态的东西
    static{
        System.out.println("(1)");
    }
    Father() {
        System.out.println("(2)");
    }
    {
        System.out.println("(3)");
    }
    public int test(){
        System.out.println("(4)");
        return 1;
    }
    public static int method() {
        System.out.println("(5)");
        return 1;
    }
}
public class Son extends Father {
    private int i = test();
    private static int j = method();	
    static {
        System.out.println("(6)");
    }
    Son() {
        super();  //子类的构造器一定会调用父类的构造器，写不写都在
        System.out.println("(7)");
    }
    {
        System.out.println("(8)");
    }
    public int test(){
        System.out.println("(9)");
        return 1;
    }
    public static int method() {
        System.out.println("(10)");
        return 1;
    }
    public static void main(String[] args) {   //先类初始化,有mian引发初始化本类<clinit>，会先初始化父类 (5)(1)，再初始化子类 (10) (6)
        Son son = new Son();	//类实例化<init>，先父的非静态变量显示赋值代码和非静态代码块(9)(3)，后父的构造器(2)，然后是子的(9)(8)(7)
        Son son1 = new Son();	//类只初始化一次，实例初始化可多次
    }
}
//执行结果：
(5)(1)(10)(6) (9)(3)(2)(9)(8)(7) (9)(3)(2)(9)(8)(7)
```

Java程序初始化顺序：   顺序都是先父类后子类

1. 父类的静态代码块         （先类初始化 clinit，静态随类初始化而执行）
2. 子类的静态代码块      
3. 父类的普通代码块       （实例初始化 init，非静态，实例化子类且子类方法重写就执行子类的）
4. 父类的构造方法
5. 子类的普通代码块      
6. 子类的构造方法



以下代码执行后输出：blockA NC blockB blockC A blockA 8。

```java
public class Test{
    public static Test t1 = new Test();		//实例初始化，只会执行构造块代码(非静态的)
    {	//构造块
         System.out.println("blockA");
    }
    static{	
        System.out.println("blockB");
    }
    Test(int x) {
        System.out.println(x);
    }
    Test() {
        System.out.println("NC");
    }
    public static void main(String[] args){  //有mian方法会类初始化，静态域按照顺序执行,blockA NC blockB blockC
        System.out.println("A");    //A
        new Test(8);    //blockA 8，不调用Test()构造
    }
     static{	
        System.out.println("blockC");
    }
 }
```



### 4、多态

```java
public class Father {
    public void say(){
        System.out.println("father");
    }
    public static void action(){
        System.out.println("爸爸打儿子！");
    }
}
public class Son extends Father{
    public void say() {
        System.out.println("son");
    }
   public static void action(){
        System.out.println("打打！");
    }
    public static void main(String[] args) {  //类的初始化，静态类变量显示赋值代码和静态代码块，静态方法没调用不执行
        Father f=new Son();
        f.say();
        f.action();
    }
}
输出：son  爸爸打儿子！
```

在java的多态调用中:

1.成员变量/静态方法：看左边。（相当于static方法没有被重写，若是private  final则没有继承父类的）

2.**非静态方法**：编译看左边（看左边的类有没有此方法，**没有编译报错**），运行看右边（new的是哪一个类就调用的哪个类的方法）



```java
public class Demo {
	public static void main(String[] args) {
	Collection<?>[] collections = {new HashSet<String>(), new ArrayList<String>(), new HashMap<String, String>().values()};
				Super subToSuper = new Sub();
		for(Collection<?> collection: collections) {
			System.out.println(subToSuper.getType(collection));
		}
}
abstract static class Super {
public static String getType(Collection<?> collection) {
		return “Super:collection”;
}
public static String getType(List<?> list) {
		return “Super:list”;
}
public String getType(ArrayList<?> list) {
		return “Super:arrayList”;
}
public static String getType(Set<?> set) {
		return “Super:set”;
}
public String getType(HashSet<?> set) {
		return “Super:hashSet”;
}
}
static class Sub extends Super {
	public static String getType(Collection<?> collection) {
            return "Sub"; }
}
}
//输出：
Super:collection
Super:collection
Super:collection
```

1. 静态方法，不存在重写，调用父类的
2.   **重载是根据形参的静态类型确定调用的方法版本**，collections数组的静态类型是Collection的。



```java
public class Base{
   public void methodOne(){
      System.out.print("A");
      methodTwo();		//调用子类的方法
   }
   public void methodTwo(){
      System.out.print("B");
   }
}
public class Derived extends Base{
   public void methodOne(){		//第一步执行
      super.methodOne();	//调用父类的方法
      System.out.print("C");
   }
   public void methodTwo(){
      super.methodTwo();
      System.out.print("D");
   }
}
```

Base b = new Derived（）; b.methodOne（）后，输出结果：ABDC



## 4、方法参数传递机制

java是强类型语言，javascript是弱类型语言

java中参数传递只有值传递（传递的是实际参数的副本），没有引用传递（实际参数的地址直接传递到函数，不建副本）

引用类型额外有**类型对象指针和同步块索引**，值类型是没有的。所以我们平时使**用lock 锁的对象不可能是值类型**

```java
public class Exam4 {
    public static void main(String[] args) {
        int i = 1;
        String str = "hello";	//改成String str = new String("hello");结果也一样，这个放在堆中
        Integer num = 200;
        int[] arr = {1,2,3,4,5};	//引用数据类型
        MyData my = new MyData();
        change(i,str,num,arr,my);  //实际参数
     
        System.out.println("i= " + i);  //1
        System.out.println("str= " + str);  //hello
        System.out.println("num= " + num);  //200
        System.out.println("arr= " + Arrays.toString(arr));   //[2,2,3,4,5]
        System.out.println("my.a= " + my.a);    //11
    }
    public static void change(int j, String s, Integer n, int[] a, MyData m) {   //形式参数
        j += 1;
        s += "world";   //方法区中的新对象
        n += 1;
        a[0] += 1;
        m.a += 1;
    }
}
class MyData {
    int a = 10;
}
```

### 方法传参机制

1、实参是**基本数据类型**（枚举）：传递数据值的副本，**不改变实参**。 **即使是static 修饰但是按形参传入**

2、实参是引用数据类型（集合、数组）：传递地址值的副本，会改变对象，特殊：**String(final修饰,即使是new的在堆中)、包装类**等对象的不可变性（fianl修饰，变了就是新的对象和地址了，**同基本类型不改变实参**，要改变要使用 反射）

<img src="/Snipaste_2020-09-28_13-36-29.png" style="zoom:200%;" />



## 5、成员变量和局部变量

首先看一道题目如下：由main中的要执行的语句，看变量的作用范围，局部变量加了对最后结果也无影响

```java
public class Exam5 {
    static int s;   		//成员变量，类变量，所有实例共享
    int i;     				//成员变量，实例变量，只在一个实例中共享
    int j;		 			//成员变量，实例变量，默认是0
    {               //实例初始化init调用
        int i = 1;   		//局部变量，栈帧中分配一个i，只在{}共享（作用）
        i++;			  // 就近原则 ，改的是栈帧中的
        j++;   		//实例变量，改的堆中的
        s++;  		 //类变量，改的方法区中的
    }
    public void test(int j) {   //形参，局部变量j，栈帧中分配一个j
        j++; // 就近原则 ，改的是栈帧中的
        i++; 
        s++;
    }
    public static void main(String[] args){ 
        Exam5 obj1 = new Exam5();   //局部变量，obj1，实例化执行非静态代码块。 0，1，1
        Exam5 obj2 = new Exam5();   //局部变量，obj2.  0，1，2
        obj1.test(10);   //1，1，3
        obj1.test(20);	//2，1，4
        obj2.test(30);   //1，1，5
        System.out.println(obj1.i + "," + obj1.j + "," + obj1.s); // 2 1 5  //同一个类static 中访问非static时使用“类名.”或 “对象名.” 
        System.out.println(obj2.i + "," + obj2.j + "," + obj2.s);   // 1 1 5  //调用的是实例变量和类变量
    }
}
```

### 考点

局部变量，在同一作用域，**就近原则**

变量的分类：**成员变量（全局变量）： 类变量（方法区，所有实例共享）、实例变量（堆）；**

​						**局部变量(在栈帧中，作用域在代码块内)**

局部变量与成员变量区别:

### 1、声明的位置

​	局部变量：方法体{}中，形参，代码块{}中

​	成员变量：类方法外

​			类变量： 有static修饰

​			实例变量：没有static修饰

### 2、修饰符

​	**局部变量：final**

​	成员变量：public protected,private,final ,static volatile,transient

### 3、生命周期

局部变量：每一个线程，每一次调用执行都是新的生命周期

实例变量：**随着对象**的创建而初始化，随着对象的被回收而消亡，每一个对象的实例变量都是独立的

类变量：**随着类**的初始化而初始化，随着类的卸载而消亡，该类的所有对象的**类变量是共享的**

### 4、重名

当局部变量与XX变量重名时，如何区分：

1、局部变量与实例变量重名: 变量前面加 “this.”表示实例变量

2、局部变量与类变量重名： 变量前面加 “类名.”表示类变量



# SSM面试题

## 1、Spring

### 1、什么是Spring框架，主要模块

Spring是一个分层的**一站式的轻量级开源框架**，Spring的核心是控制反转（IOC）和面向切面（AOP）。它使得开发者只需要关心业务需求，简化开发。

主要模块：

- **Spring Core：**核心类库，所有功能都依赖于该类库，提供IOC和DI服务。

- **Spring Aspects ** ： 该模块为与AspectJ的集成提供支持。
- **Spring AOP** ：提供了面向方面的编程实现。 
- **Spring JDBC** : Java数据库连接。
- **Spring JMS** ：Java消息服务。
- **Spring ORM** : 用于支持Hibernate等ORM工具。
- **Spring Web** : 为创建Web应用程序提供支持。
- **Spring Test** : 提供了对 JUnit 和 TestNG 测试的支持。

下图对应的是Spring 4.x的版本，5.x版本中Web模块的Portlet组件已经被废弃

![img](/1260012-20180706173553038-1830659875.png)

### 2、Spring框架的优势

（1）spring属于**低侵入式设计**，代码的污染极低；

（2）Spring的DI 依赖注入，**减低组件的耦合性**；

（3）Spring提供了AOP技术，支持将一些通用任务，如安全、**事务、日志**、权限等进行**集中式管理**，从而提供更好的复用。

（4）spring对于**主流的应用框架提供了集成支持**。

### 3、谈谈对Spring IOC的理解 

#### 1）概念

**IOC（Inverse of ControlIOC）就是控制反转**，**将对象的控制权（创建实例和管理各个实例之间的依赖关系）转移给Spring容器进行管理**。IOC 并非 Spirng 特有。

**IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。**项目启动时根据全限定类名使用反射创建对象放入map中，在代码中需要用到对象的时候再通过依赖注入将对象注入到组件中。

**DI 依赖注入**：**在程序运行期间由容器动态地将依赖对象注入到组件中**，IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。

#### 2）IOC的底层原理和流程

1、先创建IOC容器，**实例化BeanFactory**【DefaultListableBeanFactory】工厂，用于生成Bean对象。

2、读取，通过xml文件（中指定的要**扫描的包**里的.class文件放入set集合中 ）进行Resource资源读取定位

3、解析，通过BeanDefinitionReader将特定的类解析成  **BeanDefinition** 对象（存储了 bean 对象的所有特征信息，如是否单例，是否懒加载等）

4、注册，将BeanDefinition对象**注册到BeanFactory里**（即保存到HashMap），这就**完成了spring IOC容器的初始化**

5、**期间会调用一些refresh()刷新容器的方法**，比如：**BeanFactoryPostProcessor**方法，就是BeanFactory的后置处理器，就是一个扩展点

6、还执行registerBeanPostProcessors方法，向容器中注册Bean的后置处理器，也是方便后续对bean对象的扩展

7、**经历Bean对象的生命周期，**先实例化Bean对象，先通过getBean，doGetBean方法从容器中查找对象，找不到就通过createBean，doCreateBean方法由反射的方式将BeanDefinition对象实例化成具体的bean对象（一般是无参的构造方法getDeclaredConstructor，newlnstance）

8、再填充对象的属性（aware子类的方法populateBean），之后调用BeanPostProcessor前置/后置处理方法做其他 init 初始化操作

9、最后生成完整的bean对象，通过getBean()方法可以获取到

这是我对 IOC 粗浅的理解，您看有什么问题。

![image-20210817092044446](/image-20210817092044446.png)

### 4、BeanFactory 和 FactoryBean的区别

相同点：都是用来创建bean对象的接口

- **BeanFactory**是个Factory，是ioc 容器中的一个顶级接口，保存和管理对外提供的所有Bean，提供了实例化对象，依赖注入及获取对象getBean()等功能。**创建的对象必须严格遵循Bean的生命周期流程。**典型的如：XMLBeanFactory

  从Ioc容器中获取Bean(byName or byType)

  - 检索Ioc容器中是否包含指定的Bean

  判断Bean是否为单例

- **FactoryBean**是个Bean，可以返回创建bean的工厂（beanName前加&符号），**可以扩展默认 Bean的创建规则**，spring Boot SpringCloud中会实现这个接口去**自定义一些组件。是一个能生产或者修饰对象生成的工厂Bean**，它的实现与设计模式中的工厂模式和修饰器模式类似。getBean方法返回的是factorybean.getobject()的返回值，而不是factorybean。

  ProxyFactoryBean

### 5、BeanFactory和ApplicationContext的区别

1、BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。ApplicationContext（继承于ListableBeanFactory）是BeanFactory的子接口，有更丰富的功能：比如支持国际化，提供统一的资源访问方式，能够将事件发布到注册为监听器的bean。

2、BeanFactroy采用的是延迟加载形式来注入Bean的，只有在调用getBean()方法时，才对该Bean进行加载实例化。不能提前发现Spring的配置问题

3、ApplicationContext 是在容器启动时一次性创建了所有的Bean，能提前发现Spring的配置问题，检查所依赖属性是否注入

4、BeanFactory需要手动注册，而ApplicationContext则是自动注册

5、BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建

### 6、Spring Bean 的生命周期

![img](/84341632e9df3625a91c3e2a1437ee65.png)

1、**实例化bean：由doCreateBean方法通过反射的方式将BeanDefinition 对象实例化成具体的bean对象**

2、**填充bean的属性：populateBean()**，根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入

3、回调aware接口相关的方法：先检测该对象是否实现了xxxAware接口，比如：BeanNameAware，BeanFactoryAware，ApplicationContextAware

4、调用 BeanPostProcessor中的前置处理方法：可对Bean进行一些自定义的处理，可以让Bean实现了BeanPostProcessor接口。

5、**调用 init-method 初始化方法**: invokelnitmethod()判断是否实现了initializingBean接口，如果有调用afterPropertiesSet方法，没有就不调用

6、调用BeanPostProcessor的后置处理方法： 在这里会进行 aop。AbstractAutoProxyCreator注册Destuction相关的回调接口:钩子函数

7、可以通过getBean的方式获取到完整的对象，使用Bean

8、**销毁流程**：当Bean不再需要时会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用destroy()方法；如果这个Bean配置了destroy-method属性，会自动调用其配置的销毁方法

1. createBeanInstance() -> 实例化
2. populateBean() -> 属性赋值
3. initializeBean() -> 初始化
4. destroy()->销毁

### 7、Spring Bean 的作用域

在 Spring 的配置文件中，给 bean 加上 scope 属性来指定 bean 的作用域如下：

singleton：spring中的默认值，**IOC容器一创建就会创建唯一的Bean实例**（单例），后续通过 getBean()和 bean 引用来返回 bean
prototype：原型的，每次调用**getBean()方法时再实例化Bean**，而且每**调用一次创建一个Bean**。
request： 为每一次 HTTP 请求实例化一个 bean，在请求完成以后，bean会失效并被垃圾回收器回收，仅适用于webApplicationContext环境。
session：同一个 HTTP session 中共享一个Bean，在session过期后，bean会随之失效，仅适用于webApplicationContext环境。

application：限定一个Bean的作用域为 ServletContext 的生命周期。

global-session：全局session作用域，，所有会话共享一个实例。Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。global-session基于portlet容器，可以像servlet一样处理HTTP请求。但是与 servlet 不同，每个 portlet 都有不同的会话。

### 8、Spring AOP的实现原理

#### 1）原理

AOP(Aspect-Oriented Programming) **面向切面编程**，**能够将那些与业务无关，但却对业务产生影响的公共行为和逻辑（如事务、日志管理、权限控制等）抽取封装为一个可重用的模块（切面），减少重复代码，降低耦合度，提高可拓展性和可维护性**。AOP代理主要分为静态代理和动态代理。静态代理如 AspectJ，**Spring AOP是基于动态代理的**，可分为**JDK动态代理和CGLIB动态代理**：

 ① JDK动态代理**只提供接口的代理，要求被代理类实现接口**。其核心是**InvocationHandler接口和Proxy类**，使用Proxy类来动态创建目标类的代理对象（代理类**继承自Proxy并实现了我们定义的接口**）， InvocationHandler 通过invoke()方法反射来调用目标类中的代码。

```java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)

invoke(Object proxy,Method method,Object[] args)	//proxy是生成的代理对象;method 是被代理目标实例的某个方法;args是方法的具体入参
```

 ② **若被代理类没有实现接口，Spring AOP会使用CGLIB来动态代理目标类**。CGLIB（Code Generation Library）是一个代码生成的类库，利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成目标类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB通过**继承**的方式实现动态代理，故某个类被标记为final无法使用CGLIB。

#### 2） aop之链式调用的实现

代理对象中有和目标对象一样的同名方法，我们在这个**方法前后加上增强**，比如前置通知和后置通知。
**AOP会将这些增强代码包装成拦截器，组合成拦截器链**。

**methodinvocation 的 proceed()** 递归方法 实现链式调用：

怎么实现包夹顺序的:  会先排序。

![image-20220721195258702](/image-20220721195258702.png)

#### 3）Spring AOP 和 AspectJ AOP 区别

Spring AOP 属于运行时增强（基于动态代理），而 AspectJ 是编译时增强（基于静态代理）

Spring AOP 集成了 AspectJ，AspectJ  功能更加强大，Spring AOP 相对来说更简单；切面多的话 AspectJ 比Spring AOP 性能更好

```Java
<aop:aspectj-autoproxy proxy-target-class="true"/>   //配置开启强制使用cglib代理
```

#### 4）Spring AOP里面的几个名词

（1）**切面（Aspect）：**被抽取出来的**公共模块**。由多**个切点和通知**组成。可在类上使用 @AspectJ 注解来实现。

（2）**连接点（Join point）**：程序执行流程中的某个点（如：某个方法调用前、调用后，方法抛出异常后）

（3）**切点（Pointcut）：**定义 要**对哪些连接点进行拦截**，定义通知织入到哪些连接点上

（4）**通知（Advice）：**指要在**连接点**上执行的动作，**即增强的逻辑**，比如权限校验和、日志记录等。通知有各种类型。

（5）目标对象（Target）：包含连接点的对象，也称作被通知的对象。 由于Spring AOP是通过动态代理实现的，所以这个对象永远是一个代理对象。

（6）织入（Weaving）：通过**动态代理**，在目标对象（Target）的方法（即连接点）中执行增强逻辑（Advice）的过程。

（7）引入（Introduction）：添加额外的方法或者字段到被通知的类。Spring允许引入新的接口（以及对应的实现）到任何被代理的对象。

![img](/2020120700443256.png)

### 9、Spring通知有哪些类型

（1）前置通知（Before Advice）：在连接点（Join point）之前执行的通知。

（2）后置通知（After Advice）：当连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 

（3）环绕通知（Around Advice）：包围一个连接点的通知，**这是最强大的一种通知类型**。 它可以选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。

（4）返回后通知（AfterReturning Advice）：在连接点正常完成后执行的通知（如果连接点抛出异常，则不执行）

（5）抛出异常后通知（AfterThrowing advice）：在方法抛出异常退出时执行的通知

spring4/springBoot1：

（1）没有异常情况下的执行顺序：

around before advice
before advice
target method 执行
around after advice
after advice
afterReturning
（2）有异常情况下的执行顺序：

around before advice
before advice
after advice
afterThrowing
java.lang.RuntimeException: 异常发生

<img src="/image-20211015202328566.png" alt="image-20211015202328566" style="zoom: 67%;" />

spring5 通知Aop的执行顺序/springBoot2：

<img src="/image-20211015214117053.png" alt="image-20211015214117053" style="zoom:67%;" />

### 10、Spring如何解决循环依赖

#### 1）循环依赖

1、循环依赖：spring容器中2个或2个以上bean 互相持有对方/相互依赖，最终形成闭环。循环依赖报错：BeanCurrentlylnCreationException（自己注入自己也会）

![image-20210817112941808](/image-20210817112941808.png)

2、可通过**构造方法和set方法**注入依赖对象，产生的循环依赖问题主要有三种情况：

（1）构造方法进行依赖注入时。new对象时会堵塞住，就是”先有鸡还是先有蛋“的难题，spring不能解决
（2）setter方法进行依赖注入且是在多例（原型）模式时。多例情况下每一次getBean()时，都会产生一个新的Bean，最终会导致OOM
（3**）setter方法进行依赖注入且是在单例模式时。**Spring中只有这种方式的循环依赖问题被解决了

3、Spring在单例模式下的setter方法依赖注入引起的循环依赖问题，**主要是通过三级缓存来解决的**，最主要的是第三级缓存。

getSingleton方法和doCreateBean方法创建实例化A，在populateBean()填充属性时发现A对象里面依赖了B，此时又会走getSingleton方法和doCreateBean方法创建B，赋值时发现依赖A，因为之前addSingletonFactory方法将A放入了缓存中，此时可以从缓存中拿的到A的，就可以将B创建完，这时A也可创建完。

**核心原理：实例化（分配内存）和初始化（赋值）分开操作**，在对象实例化之后依赖注入之前，Spring**提前暴露的Bean实例的引用在第三级缓存中进行存储**。

4、三级缓存+四大方法

**第一级缓存：Map<String, Object> singletonObjects：**已实例化且初始化好（已完成生命周期）的对象。K：bean的名称，V：bean的实例对象/代理对象

**第二级缓存：Map<String, Object> earlySingletonObjects：**实例化但未初始化的Bean对象。kv和一级缓存一样

**第三级缓存：Map<String, ObjectFactory<?>> singletonFactories：**存储单例模式下正在创建，提前暴露的Bean实例的引用。K：bean的名称，V：ObjectFactory对象工厂，持有提前暴露的bean实例的引用

读取顺序依次是一级缓存 ==> 二级缓存 ==> 三级缓存，放缓存是3，2，1的顺序放的，如果某一级的缓存中有了对象，其他级缓存中同名的对象就会被删除。

1.getSingleton：从容器里面获得单例的bean，没有的话就去创建
2.doCreateBean: 创建bean
3.populateBean: 创建完了以后，要填充属性
4.addSingleton: 填充完了以后，再添加到容器进行使用

5、为什么使用三级缓存？第三级缓存为什么要使用ObjectFactory函数式接口？

容器中Bean对象有两种状态：已经实例化和初始化好的Bean（一级缓存中）， 实例化但未初始化的Bean（二级缓存中），要分开使用不同的map存储，所以有一二级缓存。如果仅仅是解决循环依赖问题，使用一二级缓存就可以了。三级缓存map的value类型是ObjectFactory，是一个函数式接口，使用第三级缓存为了，如果对象实现了AOP需要生成代理对象，在此之前是还需要生成普通对象的，普通对象和代理对象是不能同时出现在容器中的，因此使用三级缓存的ObjectFactory 产生代理对象覆盖掉之前的普通对象，保证容器运行中只有一个同名的bean对象。

6、解决构造函数相互注入造成的循环依赖

可以在A或者B的**构造函数的形参上加个@Lazy注解实现延迟加载**。

@Lazy原理：当实例化对象时发现属性有@Lazy注解，使用动态代理创建代理对象，注入依赖时注入一个代理对象，也是属于实例化但未完成初始化状态。

### 11、Spring 事务的实现方式

​		Spring事务**采用AOP的方式实现**，事务的概念是数据库层面的，spring只是基于此进行了扩展。

spring事务**管理两种方式：一种是编程式事务**，代码量大的情况下不好用，一种是**声明式事务**，可分为基于XML的和基于注解的。比如：@Transactional就是声明式事务，一个方法上加了这个注解的 话，spring会基于这个类生成一个代理对象，将这个代理对象做为bean，当使用这个代理对象的方法时，如果方法存在@Transactional注解，**代理对象会先把事务的自动提交设为false，**然后再去执行原本的业务逻辑方法，如果没有出现异常，则代理逻辑会将事务进行提交，如果出现了异常就会回滚，默认对RuntimeException和Error回滚，也可以利用注解中的rollbackFor属性配置哪些异常回滚。

#### 1）spring事务什么时候失效**

Spring事务的原理是AOP，失效的原因是这个Aop不起作用了，常见情况：

1、发生自调用，在本类中使用this调用 事务方法(this可省略)，此时这个this对象不是代理类。只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。解决是this调用的方法上也加事务注解（这样是个大事务了，不推荐），二：自己注入自己。

2、方法不是public的，@Transactional 只能用于 public的方法上，否则事务不会失效，如果要用在非public方法上，可以开启Aspect代理模式。

3、数据库引擎不支持事务或事务没有被spring管理

4、@Transactional 注解属性 rollbackFor 设置错误：Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务；其他异常不会触发回滚事务

5、异常被吃掉（catch），事务不会回滚(或者抛出的异常没有被定义，默认为RuntimeException)

6、在事务方法中开启多线程(异步编排，stream并行流) 新开的线程不被事务管理，因为事务作用域是 threadlocal，解决是用编程式事务

### 12、事务的基本特性（ACID）

1) 原子性（atomicity）：事务是不可分割的操作单元，要么全部成功，要么全部失败。（由DBMS的**事务管理子系统**来实现）

2) 一致性（consistency）：事务的执行使得数据库从一种正确状态转换成另外一种正确状态，事务前后数据的完整性要保持一致。（完整性子系统）

3) 隔离性（isolation）：一个事务执行时不能被其他事务所影响，对其他事务不可见。（并发控制子系统）

4) 持久性（durability）：一个事务一旦提交，会保存到数据库中并对数据库产生的影响是永久的。（恢复管理子系统）

### 13、Spring支持的事务传播行为

不同事务方法的嵌套调用中，必须指定使用同一个事务还是不同事务，出现异常是回滚还是提交。Spring 中事务有7种传播属性：

| 传播属性         | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| **REQUIRED**     | 如果当前没有事务就创建一个事务，如果当前存在事务就加入该事务**（默认，最常用）** |
| **REQUIRES_NEW** | 无论当前存不存在事务都创建新事务运行，如果当前有事务正在运行则将他挂起 |
| SUPPORTS         | 支持当前事务，如果当前存在事务就加入，如果当前**不存在事务就以非事务执行** |
| NOT_SUPPORTE     | 以非事务方式执行操作，如果当前存在事务就挂起                 |
| MANDATORY        | 强制的，支持当前事务，如果当前存在事务就加入，如果当前不存在事务就抛出异常 |
| NEVER            | 以非事务方式执行，如果当前存在事务就抛出异常                 |
| **NESTED**       | 当前存在事务则在嵌套在当前事务内执行。如果没有事务则开启一个事务，与父事务同步提交或回滚 |

事务传播属性可以在 **@Transactional(propagation=Propagation.REQUIRES_NEW)** 属性中定义

purchase为checkout事务中的方法，REQUIRES_NEW时：

![image-20210729184813225](/image-20210729184813225.png)

面试题：

一、嵌套方法调用出现异常时spring事务是怎么处理：

1、事务大致可分为三类：支持当前事务，不支持当前事务，嵌套事务nested

2、如果外层方法是required/requires_new/nested，内层方法是required/requires_new/nested 

大致处理逻辑：

①使用同一个事务时：REQUIRED和NESTED的区别：NESTED保存点会清除，而REQUIRED的回滚点不会清除，提交时有回滚点就会回滚。

当内部方法设置为 **REQUIRED时**，使用的是同一事务，即**内层事务会跟着外层事务一同提交，一同失败回滚（子事务用catch父事务不回滚）** 。

当内部方法设置为 **nested 时**，进入嵌套事务会先建立一个保存点save point，如果这个嵌套事务失败将回滚到此 savepoint，外层事务从保存点开始继续执行其他业务，因此**子事务回滚不会影响父事务回滚。但父事务回滚子事务也回滚**，因为嵌套是子事务套在父事务中执行，由父事务统一提交。

②使用不同事务时：

当内部方法设置为**REQUIRED_NEW时**，开启一个新的事务而不依赖于外部事务，**内层事务的提交commited 和回滚rolled back与外层的事务的互不影响** 。

二、对于核心的业务检查逻辑，不能放到事务之外，而且必须要作为分布式下的并发控制，加锁。

二、spring 什么情况下进行事务回滚？

Spring、EJB的声明式事务默认是在抛出 unchecked exception（即runtime exception）并且你的业务方法中没有catch到的话就会触发事务的回滚。若用 try{}catch 则不会回滚，事务就不生效了。一般不需要在业务方法中catch异常，如果非要catch，在做完你想做的工作后（比如关闭文件等）一定要抛出runtime exception，否则spring没有回滚直接提交，会产生脏读问题。

### 14、 spring的事务隔离级别

#### 	1）数据库事务并发问题

1)    脏读

​	当前事务读到其他事务**修改了但还没有提交**（可能回滚）的值，就是无效值。

2)    不可重复读

​	 A事务读取了B事务**已经提交的修改数据**，和更新前的不一致；对操作的数据添加行级锁

3)    幻读

​	A事务读取到B事务**已提交的对数据库表的增删数据**，和更新前的不一致；添加表级锁

#### 	2）隔离级别

数据库要避免各种并发问题。**一个事务与其他事务隔离的程度称为隔离级别**。隔离级别越高，数据一致性就越好，但并发性越弱。

spring的事务隔离级别就是数据库的隔离级别，外加一个默认等级。

1)	**默认：**DEFAULT：使用数据库默认的事务隔离级别。

2)    **读未提交**：READ UNCOMMITTED，脏读

3)    **读已提交**：READ COMMITTED，不可重复读

4)   **可重复读：REPEATABLE READ**：Transaction01执行期间禁止其它事务对这**个字段**进行更新。**读的值都一样**

5） **串行化**：SERIALIZABLE：Transaction01执行期间，禁止其它事务对**这个表**进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。

  各个隔离级别解决并发问题的能力见下表

![](/Snipaste_2020-10-06_21-22-35.png)

**@Transactional(isolation=Isolation.DEFAULT)**

### 15、Spring 中用到的设计模式

（1）**工厂模式：**通过BeanFactory和ApplicationContext来创建对象，不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。

（2）**责任链模式：使用aop通知调用的时候会先生成一个拦截器链**

（3）适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式，SpringMVC中HandlerAdater是用到了适配器适配Controller

（4）**代理模式：**Spring的AOP功能用到了JDK的动态代理和CGLIB动态代理

（5）**模板方法：**将相同部分的代码放在父类中，不同的代码放入不同的子类中来解决代码重复的问题。比如 jdbcTemplate, JmsTemplate, onRefresh

（6）策略模式：例如Resource的实现类，针对不同的资源文件，实现了不同方式的资源获取策略

（7）**观察者模式：**一个对象状态改变时通知所有依赖的对像，Spring事件驱动模型，监听器，ApplicationListener。

（8）**单例模式：**spring中的bean默认都是单例的

桥接模式：可以根据客户的需求能够动态切换不同的数据源。

**原型模式**：可通过作用域方式改bean为 prototype

装饰者模式：BeanWrapper

委托者模式：delegate

### 16、Spring中的Bean是线程安全的么？

这要结合Bean的作用域来讨论：

（1）对于prototype作用域的Bean，**每个线程都创建一个新对象，不存在Bean共享**，因此不会有线程安全问题。

（2）对于singleton作用域的Bean，如果单例Bean是一个无状态Bean(就是没有实例变量的对象，不能保存数据)，那么这个单例Bean是线程安全的。比如Controller类、Service类和Dao等。而**有状态的Bean 不是线程安全的。**

解决：

**将有状态的bean的作用域由“singleton”改为“prototype”。**

**采用ThreadLocal，为每个线程提供一个独立的变量副本**，不同线程只操作自己线程的副本变量

### 17、自动装配@Autowired/@Resource

​	自动装配：由容器自动负责把需要的对象引用赋予各个对象

一、基于xml配置，共有5种自动装配：可在xml配置文件<bean>中定义"autowire"属性开启自动装配

（1）no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。

（2）byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。

 ```
cutomer的属性名称是person，Spring会将bean id为person的bean通过setter方法进行自动装配。
<bean id="cutomer" c1ass="com.xxx.xxx.Cutomer" autowire="byName " />
<bean id="person" c1ass="com.xxx.xxx.Person" />
 ```

（3）byType：根据bean的类型进行自动装配。**若有两个Bean会报错，可用quelitype指定要注入的**

```
cutomer的属性person的类型为Person，spirng会将Person类型通过setter方法进行自动装配。
<bean id="cutomer" c1ass="com.xxx.xxx.Cutomer" autowire="byType" />
<bean id="person" class="com.xxx.XXx.Person" />
```

（4）constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。bean与构造器参数的类型形同，则进行自动装配，否则导致异常。

```
cutomer的属性person的类型为Person，spirng会将Person类型通过setter方法进行自动装配。
<bean id="cutomer" c1ass="com.xxx.xxx.Cutomer" autowire="byType" />
<bean id="person" class="com.xxx.xxx.Person" />
```

（5）autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。

二、基于注解的方式@Autowired：**可在字段，setter方法，**构造函数上使用

​	使用@Autowired注解来自动装配指定的bean。首先在容器中查询对应类型的bean：

​	如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；

​	**如果查询的结果不止一个，那么@Autowired会根据名称来查找；**

​	**如果上述查找的结果为空，那么会抛出异常。解决方法：使用required=false。**

注：@Autowired和@Resource区别

(1) **@Autowired默认是按照类型装配注入的，找到多个会按名字找，找不到报错。默认情况下它要求依赖对象必须存在（可以设置它required属性为false）**，@Qualifier("")可选择要注入的类。

(2) **@Resource默认是按照名称来装配注入的**，找不到与名称匹配的bean会按照类型来装配注入，找不到报错，找到多个报错。

### 18、Spring常用注解

```text
@Component：标注一个普通的Spring Bean类。 
@Controller：标注一个控制器组件类。 
@Service：标注一个业务层组件类。 
@Repository：标注一个dao持久层组件类。
尽量考虑使用@Controller，@Service，@Repository代替通用的@Component

@SuppressWarnings("unchecked") 没用使用也不警告，使开发者能看到一些他们真正关心的警告。从而提高开发者的效率
@Transactional(rollbackFor=Exception.class)，里面的方法抛出异常，数据库里面的数据也会回滚。加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚。如果不配置，只会在遇到RuntimeException的时候才会回滚
```



## 2、SpringMVC

### 1、什么是Spring MVC 

是基于MVC设计模式的请求驱动类型开发的轻量级Web框架，将web层解耦成Model，View和Controller。使逻辑更清晰，方便组内开发人员之间的配合。

### 2、SpringMVC解决中文乱码问题

#### 1）解决 POST 请求中文乱码问题

修改项目中web.xml文件，filter过滤器 <filter>和<filter-mapping>

```xml
  <filter>
    	<filter-name>CharacterEncodingFilter</filter-name>
    	<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    	<init-param>
      		<param-name>encoding</param-name>
      		<param-value>UTF-8</param-value>
    	</init-param>
    	<init-param>
     		 <param-name>forceEncoding</param-name>
      		<param-value>true</param-value>
   		 </init-param>
  </filter>
  <filter-mapping>
    	<filter-name>CharacterEncodingFilter</filter-name>
   		 <url-pattern>/*</url-pattern>
  </filter-mapping>
```

#### 2）解决 Get 请求中文乱码问题

修改tomcat中server.xml文件，tomcat8解决了

```xml
<Connector URIEncoding="UTF-8" port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" />
```

### 3、SpringMvc核心流程

![在这里插入图片描述](/20210122113150692.png)

具体步骤：

第一步：客户端（浏览器）发送请求到 前端控制器/中央控制器(DispatcherServlet) （ 在 web.xml 中部署描述）

第二步：DispatcherServlet 根据请求信息交给处理器映射器（HandlerMapping）

第三步：处理器映射器 根据用户URL请求找到对应的 处理器（Handler/controller页面控制器，由xml配置/注解进行查找），并将 Handler与一堆 HandlerInterceptor（拦截器）封装到 HandlerExecutionChain 执行链对象中，通过这种策略模式，很容易添加新的映射策略

第四步：前端控制器 根据执行链请求处理器适配器（HandlerAdapter）

第五、六步：HandlerAdapter会根据具体 Handler 进行处理业务逻辑，Handler 执行完成给 HandlerAdapter 返回ModelAndView

第七步：HandlerAdapter给 前端控制器 返回 ModelAndView （springmvc的一个底层对象，Model 是返回的数据对象模型，View 是逻辑视图名）

第八步：前端控制器 请求视图解析器（ ViewResolver）去进行视图解析 （根据逻辑视图名 查找实际的 View)），通过这种策略很容易更改视图解析器

第九步： 视图解析器 向 前端控制器 返回 实际的View

第十步：前端控制器 对View进行渲染视图，将模型数据modle填充到request域（View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...））

第十一步：前端控制器 将响应返回给客户端（浏览器）

### 4、SpringMVC常用的注解

@RequestMapping：处理请求路径的映射，可用于类或方法上。在类上表示类中的所有的响应方法都是以该地址作为父路径

@RequestBody：接收http请求的json数据，将json转换为java对象

@ResponseBody：将方法返回对象转化为 **json对象响应给客户端。返回页面时不能加。**

@RestController注解相当于@ResponseBody ＋ @Controller

@GetMapping 等价于@RequestMapping(value="/users",method=RequestMethod.GET)

@PostMapping 

### 5、注解的原理

**所有注解本质上是继承了 Annotation 接口的接口（Annotation 中的原话）**，其具体实现类是JDK动态代理生成的代理类。当通过反射获取注解时返回动态代理对象，然后通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法，该方法会从memberValues这个Map中查询出对应的值，而memberValues的来源是java常量池。

### 6、Spring MVC的异常处理 

可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。

### 7、controller是不是单例模式

是单例模式，多线程时有线程安全问题，解决：在控制器里需要可变状态量时，可以使用ThreadLocal 为每个线程单独生成一份变量副本，互不影响。



## 3、Mybatis

### 1、什么是Mybatis

是一个半自动ORM（对象关系映射）框架，内部封装了JDBC，加载驱动、创建连接、创建statement等繁杂的过程，开发者只需要关注编写SQL语句，灵活度高。

通过xml 文件或注解实现接口绑定，将java对象和 sql的动态参数进行映射生成最终的sql语句，由mybatis框架执行sql并将结果映射为java对象并返回。

半自动ORM：需要手动编写sql来完成。Hibernate是全自动ORM(javaBean和数据库映射)，可以根据对象关系模型直接获取查询的关联对象

### 2、#{}和${}的区别**

**${}是字符串替换，是拼接符，**把${}直接替换成变量的值，不会加单引号，有sql注入风险；

**#{} 是预编译处理，是占位符（?），**会调用PreparedStatement的set方法来赋值，可以防止SQL注入，提高系统安全性。

模糊查询like：

```java
//在Java代码中添加sql通配符： 
string wildcardname = “%smi%”;
list<name> names = mapper.selectlike(wildcardname);
 
 <select id=”selectlike”>
  select * from foo where bar like #{value}
 </select>
//sql语句中拼接通配符，会引起sql注入
string wildcardname = “smi”;

select * from foo where bar like "%"${value}"%"
```

sql注入：利用系统没对传入参数检查的漏洞进行攻击获取后台数据，传入：1'and 1=1  ===》 where id=' 1'and 1=1'

### 3、Dao接口的工作原理

Dao接口（即Mapper 接口）的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理对象，**代理对象会拦截接口方法，根据类的全限定名+方法名（拼接字符串作为map的key值），唯一定位到一个MapperStatement对象并调用执行器执行所代表的sql，然后将sql执行结果返回**。


一个mapper.xml 对应一个Dao接口：接口的全限名：即映射文件中namespace的值；接口的方法名：即映射文件中Mapper的Statement的id值；接口方法内的参数：即传递给sql的参数。

Mapper接口里的方法是不能重载的，因为是使用 全限名+方法名 的保存和查找的。

旧版本的Mybatis的namespace是可选的，新版本是必须的。不同的Xml映射文件，配置了namespace则id可以重复；没有配置namespace则id不能重复

Xml映射文件要求：

​	Dao接口方法名和mapper.xml中id相同，namespace即是Dao接口的类路径。；
​	Dao接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType、resultType的类型相同；

### 4、实体类中的属性名和表中的字段不同

解决方案：

1、写 SQL 语句的时候 写别名

2、在MyBatis的全局配置文件中开启 **驼峰命名规则** ,要求：数据库字段中含有下划线。

```xml
<!-- 开启驼峰命名规则，可以将数据库中下划线映射为驼峰命名,列如 last_name 可以映射为 lastName-->
<configuration>
    
    <settings>
        <setting  name="mapUnderscoreToCamelCase"  value="true"/>
         <setting name="aggressiveLazyLoading" value="true"/>
    </settings>   
    .....
</configuration>
```

在SpringBoot的application配置文件中：

```yml
mybatis.configuration.mapUnderscoreToCamelCase=true
#若数据库中没有下划线，要关闭mybatis-plus的驼峰，在springboot 中：
mybatis-plus:
 configuration:
 	map-underscore-to-camel-case: false
```

3、在Mapper映射文件中不用 resultType，使用 **resultMap 自定义** 映射

```xml
<resultMap type="com.atguigu.pojo.Employee" id="myMap">
    <!-- 映射主键 -->
	<id column="id" property="id"/>
    <!-- 映射其他列 -->
    <result column="last_name" property="lastName" />
    <result column="email" property="email" />
    <result column="salary" property="salary" />
    <result column="dept_id" property="deptId" />
</resultMap>
```

### 5、Mybatis如何进行分页

Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页。若要完成物理分页功能，可在sql内写带有物理分页的参数或使用分页插件。

   分页插件的基本原理：使用Mybatis提供的插件接口，在**插件的拦截方法里拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。**

### 6、插件运行原理及如何编写插件

Mybatis仅支持编写针对ParameterHandler（sql参数转化）、ResultSetHandler（接收结果集）、StatementHandler（设置参数）、Executor（调度执行sql）这4种接口的插件

原理：**使用JDK的动态代理**，为需要拦截的接口生成代理对象，当执行插件方法时会执行 InvocationHandler的invoke()方法，拦截指定需要拦截的方法后执行

编写插件：实现Mybatis的Interceptor拦截器接口并重写**intercept()方法，然后写注解并指定要拦截的接口和方法，最后在配置文件或配置类中配置这个插件。**

```java
@Intercepts({@signature(type = statementHandler.c1ass，method = "query", args ={statement.class，Resu1tHandler.class}),
				@signature(type = statementHand1er.c1ass，method = "update"，args ={statement.c1ass})})
@component
invocation.proceed()//执行具体的业务逻辑
```

### 7、Mybatis支持延迟加载的原理

Mybatis仅支持关联查询（association（一对一）和collection（一对多））的延迟加载，在Mybatis配置文件中开启：lazyLoadingEnabled=true

原理：使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法

### 8、Mybatis的一级、二级缓存

适用于缓存：经常查询并且不经常改变的；不适用于缓存：数据的实时性很重要的数据

（1）一级缓存: 基于 PerpetualCache 的 HashMap **本地缓存**，其存储作用域为 Session（sqlsession），**默认打开一级缓存**。

（2）二级缓存存储作用域为 Mapper(Namespace)，并且可**自定义存储源**，如 Ehcache。默认不打开二级缓存，可在映射文件中配置开启。

二级缓存的使用:

​	1)、开启全局二级缓存配置: <setting name="cacheEnabled" value="true"/>

​	2)、去sql映射文件中配置使用二级缓存:<cache></cache>  可以select标签设置useCache= "true"

​	3)、**使用二级缓存的属性类要实现Serializable序列化接口**(可用来保存对象的状态)

注：每个增删改标签默认: flushCache="true": (一级二级都清除)，查询标签默认false，所有select语句会被缓存；默认使用LRU（最近最少使用的）算法回收

缓存失效情况 :

​	缓存作用域不同(一级缓存 Session/二级缓存Namespaces)

​	作用域相同，查询条件不同（Id，结果集，Sql语句，参数值 都相同才是完全相同的查询）

​	当某一个作用域 增删改 操作后，缓存更新。如果开启了二级缓存，则根据配置判断是否刷新。用commit()，close()，clearcache()等方法时会清空一级缓存。（sqlSession. clearCache( ) ;只是清除当前session的一级缓存）

**先查二级缓存：**

<img src="/1254583-20171029185910164-1823278112.png" alt="img" style="zoom:150%;" />

### 9、Mybatis动态sql

Mybatis可以在Xml映射文件内以标签的形式编写动态sql，执行原理是**根据表达式的值 完成逻辑判断 并动态拼接sql的功能**。

Mybatis提供了9种动态sql标签：trim | where | set | **foreach | if** | choose | when | otherwise | bind。

### 10、如何获取自动生成的(主)键值

insert 方法总是返回插入的行数

```java
// <insert /> 标签中添加useGeneratedKeys="true"等属性，类中的名
<insert id=”insertname” usegeneratedkeys=”true” keyproperty=”id”>
   insert into names (name) values (#{name})
</insert>
//方法二：在 <insert /> 标签内添加<selectKey />标签
```

### 11、mapper中如何传递多个参数

1）每个形参前**使用@Param命名参数**

2）xml中#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数

3）用map或Java对象封装

### 12、关联查询

```xml
<resultMap id="myEmp" type="com.node.bean.Emp">
        <id column="id" property="id"/>
        <result column="name" property="name"/>
        <result column="age" property="age"/>  <!--其他不写的列会自动封装，但推荐全写-->
        <association property="dept" javaType="com.node.bean.Dept">  	<!-- 一对一查询 -->
            <id column="dId" property="id"/>     <!--列名重复用别名,有别名就只能用别名-->
            <result column="deptName" property="deptName"/>
        </association>		
   	 <!-- 一对多，分步查询和懒加载 -->
    	<collection property="student" ofType="com.lcb.user.Student">  
            <id property="id" column="s_id"/>  
            <result property="name" column="s_name"/>  
        </collection>        
</resultMap> 
 <select id="selectEmpAndDept" resultMap="myEmp">
SELECT e.id,e.name,e.age,e.deptId,d.id dId,d.deptName FROM t_emp e JOIN t_dept d ON e.deptId=d.id WHERE e.id=#{id}
</select>

<!--  全局配置文件置懒加载   -->
<setting name="lazyLoadingEnabled" value="true"/>
<setting name="aggressiveLazyLoading" value="false"/>
```



# Java 高级 面试题

## 1、Linux 常用服务类相关命令

常用基本命令 - 进程类，centos 6 和 centos 7 及以上命令有些不同

### 1、service（centos 6）

```bash
service 服务名 start/restart/reload/stop/status

#centos7也可用，只不过服务较少
ll /etc/init.d/服务名     #查看服务的方法

chkconfig --list     	#查看服务是否开机自启动 chkconfig -list l grep XXX   
chkconfig -level 5 服务名 on/off        #设置开机自启动
```

### 2、运行级别 (centos6)

![image-20201011165012754](/image-20201011165012754.png)

Linux系统有7种运行级别(runlevel): **常用的是级别3和5**

运行级别0:系统停机状态，系统默认运行级别不能设为0，否则不能正常启动

运行级别1:单用户工作状态，root权限，用于系统维护，禁止远程登陆

运行级别2:多用户状态(没有NFS),不支持网络

**运行级别3:完全的多用户状态(有NFS),登陆后进入控制台命令行模式**

运行级别4:系统未使用，保留

**运行级别5: X11控制台，登陆后进入图形GUI模式**

运行级别6:系统正常关闭并重启，默认运行级别不能设为6,否则不能正常启动.

### 3、Systemctl ( centos7 )

```bash
systemctl start/restart/reload/stop/status 服务名(xxx.service/xxxd)

cd /usr/lib/systemd/system			#查看服务的方法
systemctl --type service        	#查看每个服务名和当前状态

systemctl list-unit-files |grep xxx   #查看服务是否开机自启动
systemctl enable/disable xxxx.service			 #设置开机自启动，设置不了就用centos6的命令
```

### 4、打包解压

tar -xzvf file.tar.gz 		解压 .tar.gz/ .tar （z和tar.gz相关，没有z和tar相关）

tar -czvf file.tar.gz  *.file 		将 .file结尾的文件打包命名成file.tar.gz

unrar e file.rar 		解压rar

unzip file.zip 		解压zip

zip file.zip *.file 		打包成zip

tar -tvf file.tar			查看 file.tar 的内容而不提取它

## 2、git分支相关命令

### 1、分支

1、创建分支

**git branch <分支名>**

git branch -v 查看分支

2、切换分支

**git checkout <分支名>**

**创建切换一步完成: git checkout -b <分支名>**

3、合并分支

**先切换到主干 git checkout master**

**git merge <分支名>**

4、删除分支

先切换到主干 git checkout master

**git branch -D <分支名>**

### 2、Git 工作流程

 master 分支上线，如果 master 出问题，会创建一个 hotfix 分支进行解决 bug ，解决完后合并到 master 分支和 develop 分支，保持一个同步，有新的分支开发完成就会和 develop 分支合并，然后创建一个 release 分支进行测试，完成后在合并到 master 和 develp ，保持一致。

<img src="/image-20201011170001264.png" alt="image-20201011170001264" style="zoom:80%;" />



## 3、Redis缓存

### 1、容灾备份持久化的类型

#### 1）RDB 

1）什么是 RDB 

​	Redis DataBase，在指定的**时间间隔**内将内存中的**数据集快照（Snapshot）写入磁盘**，它恢复时是将**快照文件直接读到内存**里。

![image-20201011173047980](/image-20201011173047980.png)

2）RDB 备份/持久化是如何执行的

​	**fork一个子进程，先将数据集写入临时文件，写入成功后，再用这个临时文件替换之前的文件，用二进制压缩存储**。

3）什么是 fork 
	在Linux程序中，**fork()产生和父进程完全相同的子进程**，出于效率考虑，Linux中引入了**写时拷贝技术**，一般情况**父进程和子进程会共用同一段物理内存**，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。

4）RDB 保存的文件

​	在 redis.conf 的配置文件中，默认保存文件的名称叫 dump.rdb

<img src="/image-20201011172804040.png" alt="image-20201011172804040" style="zoom:150%;" />

​	rbd 文件的保存路径也可以修改，默认为 Redis启动命令行所在目录下

<img src="/image-20201011172839107.png" alt="image-20201011172839107" style="zoom:150%;" />

5）RDB 保存的策略

<img src="/20210122125000647.png" alt="在这里插入图片描述" style="zoom: 50%;" />

​	15 分钟 1 次添加 key 的操作，5 分钟 10 次添加 key 的操作，1 分钟 10000 次添加 key 的操作都会触发保存策略。
6）RDB 的备份
​	先通过 config get dir 查询 rdb文件的目录
​	将 *.rdb 的文件拷贝到别的地方
7）RDB 的恢复
​	关闭 Redis
​	先把备份文件拷贝到拷贝到工作目录下
​	启动 Redis，备份数据会直接加载

**8）优缺点**

优点：**主进程不进行任何IO操作确保了redis高性能**；RDB比AOF**更加节省磁盘空间，恢复速度更快效率更高**。aof是可读的日志文本，可以处理误操作

缺点：最后一次持久化后的数据可能丢失，适用于对数据恢复的完整性不很敏感业务。aof默认最多丢失一秒数据。

#### 2）AOF 

Append Only File，以**日志的形式来追加每个更改操作**(读操作不记录)，恢复：Redis重启时根据日志文件的内容将写指令从前到后执行一-次

2）AOF 默认不开启，需要手动在配置文件中配置

<img src="/20210122125844358.png" alt="在这里插入图片描述" style="zoom:80%;" />

4）AOF 和 RDB 同时开启，redis 听谁的
	**系统默认取AOF的数据，对于主从同步主从刚连接的时，进行全量同步（RDB），之后进行增量同步(AOF)。**
5）AOF 文件故障备份
	备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。
6）AOF 文件故障恢复
	如遇到AOF文件损坏，可通过redis-check-aof --fix appendonly.aof 进行恢复
7）**AOF 同步策略**

​	每修改同步，每次Redis的写入都会立刻记入日志。
​	**每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。默认策略**
​	不主动同步，把同步时机交给操作系统。

<img src="/20210122130314737.png" alt="在这里插入图片描述" style="zoom: 50%;" />

8）**aof 的rewrite重写机制来压缩**
	AOF追加方式文件越来越大时，文件的大小超过所**设定的阈值**时启动重写机制（**内容压缩**，只保留可以**恢复数据的最小指令集**），具体：会fork出一条新进程（也是先写临时文件最后再rename)，将新进程内存中的数据用Set命令重写了一个新的aof文件（并没有读取旧的aof日志文件），这点和快照有点类似。
9）何时重写
	重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定的阈值。

<img src="/20210122131019360.png" alt="在这里插入图片描述" style="zoom: 50%;" />

Redis 会记录系统载入或者上次重写完毕时 AOF 大小，设为 base_size，如果 AOF当前大小 >=  base_size +base_size*100%  (默认)且 >=64mb (默认)的情况下，Redis会对AOF进行重写。

### 2、Redis单线程线程模型

**Redis基于响应式模式(Reactor)开发的文件事件处理器（file event handler）**。这个文件事件处理器，它是单线程的，采用IO多路复用机制来同时监听多个Socket，每次从队列中取出一个Socket给事件分派器，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。

文件事件处理器的结构包含4个部分：多个Socket、I0多路复用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等)。Redis 单线程快的原因：

1）纯内存操作（Redis主要消耗内存资源）

2）采用了非阻塞I/O多路复用机制（有一个文件描述符同时监听多个文件描述符是否有数据到来）

3) 单线程避免了多线程的频繁上下文切换带来的性能问题

4）合理高效的数据结构

### 3、redis集群方案

#### 1）主从模式

一个master主机与多个slave从机，主节点负责写操作，从节点负责读操作。优点：读写分离，主节点的数据会自动复制给从节点，分担主节点的压力。缺点：**一旦主节点宕机，不能自动切换到从服务器上。**

#### 2）哨兵模式

本身也是主从模式，但是添加了哨兵功能，可以对主节点进行监控，一旦主节点挂掉就在从节点中进行投票选举（多数）。优点：主机可以自组切换。缺点：**在选举期间无法确定主从，无法工作**

#### 3）Cluster模式

数据通过数据分片的方式分割到不同的master节点上，实际分配到不同的hash槽，每个master节点中存储的数据都不一样。在每个分片下实现的也是主从模式，实现的是一种去中心化控制，从节点只会拉取主节点的备份数据，不会参与数据的存取操作。当主节点宕机，就会启动从节点

Redis Cluster（集群）是一种**服务端分片（Sharding）技术**，3.0版本开始正式提供。**采用哈希槽(hash  slot)来实现**（没有使用一致性哈希(Consistency Hashing)）。一共分成16384个槽。将请求发送到任意节点。去中心化的架构，**每个节点互为主从**，支持动态扩容。

方案说明：

**通过hash函数映射，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384个槽位**

数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)

同一分片多个节点间的数据不保持强─致性

读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点

扩容时需要需要把旧节点的数据迁移一部分到新节点

在redis cluster架构下，每个redis要放开两个端口号，一个是6379，另外一个就是加1 的端口号16379。

**16379端口号是用来进行节点间通信的**，也就是cluster bus的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。

#### 4）客户端分片模式

Redis Sharding **客户端分片**，是Redis Cluster出来之前，业界普遍使用的集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动 jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool
优势在于非常简单，服务端的Redis实例彼此独立。但客户端sharding不支持动态增删节点。

### 4、Redis的主从复制

总：**①从机接入后，从机给主机发送sync指令。②主机立刻进行存盘操作，发送RDB文件给从机。③从机收到RDB文件进行全盘加载。④之后主机的每次写操作，都会立刻发送给从机，从机执行相同的命令，保证主从数据一致性。**

通过执行slaveof命令或设置 slaveof 选项，让一个服务器去复制另一个服务器的数据。

**全量复制:**

(1)  主节点会**fork子进程进行RDB持久化**（全量数据快照），该过程是非常消耗性能的。

(2）主节点通过网络将RDB文件发送给从节点

(3)  **从节点清空老数据、载入新RDB文件的过程是阻塞的**，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗

**增量复制:**

（1）复制偏移：**主从节点，分别会维护一个复制偏移量 offset**

（2）复制积压缓冲区︰**主节点内部维护了一个固定长度的、先进先出(FIFO)队列作为复制积压缓冲区**，当复制量过大超过缓冲区长度时，将执行全量复制。

（3）服务器运行ID(runid)：**每个Redis节点，都有其运行ID**，运行ID由节点在启动时自动生成，从节点会将主节点的运行ID存起来。从节点Redis断开重连的时候，就是根据运行ID来判断同步的进度：

如果从节点保存的runid与主节点现在的runid相同，主节点会尝试使用部分复制 (到底能不能部分复制还要复制积压缓冲区的情况)；

如果不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。

<img src="/image-20210908232439491.png" alt="image-20210908232439491" style="zoom:67%;" />

### 5、数据结构及使用场景

常用5种数据类型：命令不区分大小写，而Key是区分大小写的

1. String字符串：使用 set key value 命令。**常用在分布式锁**（stringRedisTemplate的SET参数代替了SETNX+EXPIRE实现了原子性）、INCR命令点赞/累加功能（计数器）、共享Session、限速等。QPS>500 数据库搞不定要使用缓存。

   redis底层是用C语言写，会构建了一个**动态字符串**，String 源码中：有三个变量：**字符数组，数组的空闲长度free，已使用长度len**（最后一个是空字符不计算）。每次存时会空间预分配SDS，len < 1M则多开辟与已使用大小len相同长度的空闲free空间，len >= 1M则多开辟1M长度的空闲free空间，直至满足大小。快速获取字符串长度len，防止内存溢出free。

2. Hash哈希：指reids 键值对的值又是一个hash结构，可以用来存放用户信息，比如早期实现购物车。

   元素数量小于512且所有元素长度小于64用zipList。多了用hash表，数组+链表 ：单链表、没有用红黑树；有rehash优化。

3. List列表：LPUSH key value [value...]，用来存储多个有序的字符串。可以做简单的消息队列的功能(守护进程 Supervisor Yum，普通队列、阻塞队列)。

   先zipList压缩链表，内存连续，节约指针内存。元素过多采用双向链表（加了头、尾节点、len等）

4. Set集合：集合中是无序、不重复元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，QQ内推可能认识的人，微信的抽奖程序。

   底层用了inset（元素少），多了用hash表。

5. zset/Sorted Set排序集合（跳跃表） ：Sorted Set 多了一个权重参数 Score，元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。

   **zset有序，set无序，数据少时用zipList，多用跳跃表**

reids的string结构的key和value两者的最大长度限制都为512MB。其他类型List/set/hash为2^32-1个。

##### 2）redis的 rehash过程

java的HashMap需要一次全部拷贝，数据大的话是个耗时的操作。Redis为了追求高性能，不能堵塞服务，所以采用了渐进式rehash策略

渐进式rehash会在rehash的同时，保留新旧两个hash结构，查询时会同时查询两个hash结构，然后在后续的定时任务及操作指令中，渐进地将旧hash的内容一点点地迁到新的hash结构中。当搬迁完成了，就会使用新的hash结构取而代之，旧数据结构自动删除。

ConcurrentHashMap 采用的扩容策略，多线程协同式rehash，写阻塞，读可以读。

### 6、跳跃表

可以对**有序链表**进行近似二分查找的**数据结构**。和平衡树性能相似：O(log n)、有序。

使用跳表的原因：**skiplist 比平衡树实现简单；Redis只涉及内存读写，不涉及磁盘IO（不用方便磁盘预读的数据结构）**

<img src="/image-20210914232057808.png" alt="image-20210914232057808" style="zoom:67%;" />

```
例： level0    1---------->5
	level1    1---->3---->5
	level2    1->2->3->4->5->6->7->8
要找键为6的元素，在level0中直接定位到5，然后再往后走一个元素就找到了
概念：层(level[])：层数越多访问越快（索引越细）、 前进/后退指针、 跨度(span)
```

**代码实现的跳表：**一个节点拥有多个指针，指向不同的节点，如上图

### 7、Redis的热点key

1）如何发现：

1. 凭借经验，进行预估：例如提前知道了**某个活动的开启，那么就将此Key作为热点Key**
2. Redis自带命令查询：Redis4.0.4版本提供了redis-cli –hotkeys就能找出热点Key。（要先把内存淘汰设置为allkeys-lfu或者volatile-lfu，否则会返回错误。进入Redis中使用config set maxmemory-policy allkeys-lfu即可）

2）热点key解决方案：

1. 服务端缓存：利用Redis自带的消息通知机制来保证数据一致性，reids客户端对热点Key 建立一个监听，当Key有更新操作的时，服务端也随之更新
2. 备份热点Key：将热点Key+随机数，**将key分配到多个节点中**。这样访问热点key的时候就不会全部命中到一台机器上了

### 8、Redis并发竞争key的解决方案

1. 分布式锁+过期时间
2. 利用消息队列



## 4、MySQL数据库

### 1、数据库的常用范式

第一范式（1NF）：指表的**列不可再分，**同一列中不能有多个值。如：电话号码字段不可分为固定电话和移动电话值。无重复的列
第二范式（2NF）：在 1NF 的基础上，还包含两部分的内容：**一是表必须有一个主键**（每个实例或行必须可以被唯一地区分）；二是表中**非主键列必须完全依赖于**主键，不能只依赖于主键的一部分	(身份证–>姓名，姓名部分函数依赖于(学号和身份证)。肥胖指数完全函数依赖于（身高和体重））

第三范式（3NF）：在 2NF 的基础上，**消除**非主键列对主键的**传递依赖**，**非主键列必须直接依赖于主键**
BC范式（BCNF）：在 3NF 的基础上，消除属性（主属性和非主属性）对 关系键/码 的**部分函数依赖**。

### 2、逻辑架构和存储引擎

 **缓存是给读信息用的，缓冲是给写信息用的**

![image-20210901160020354](/image-20210901160020354.png)

![img](/1174710-20190128200647649-2138221098.png)

MySQL服务器逻辑架构从上往下可以分为三层：

（1）第一层：连接层，处理客户端连接、授权认证等。

（2）第二层：服务器层，负责sql语句的分析、解析复杂sql、优化、缓存以及内置函数的实现。连接先访问连接池，再访问缓存，有缓存锁

（3）第三层：存储引擎层，负责MySQL中数据的存储和提取。**MySQL中服务器层不管理事务，事务是由存储引擎实现的**。MySQL支持事务的存储引擎有InnoDB、NDB Cluster等，其中InnoDB的使用最为广泛；其他存储引擎不支持事务，如MyIsam（mysql8.0废弃了）、Memory等。

### 3、InnoDB与MyISAM的区别

**（1）事务：MyISAM不支持事务，是MySQL5.5.5之前默认存储引擎；InnoDB支持事务**（5.5.5之后默认存储引擎）

**（2）锁级别：InnoDB存储引擎支持行级锁和表级锁，**默认情况下使用行级锁，但只有通过索引进行查询数据，才使用行级锁，否就使用表级锁。
						**MyISAM和MEMORY存储引擎采用的是表级锁；**
						BDB存储引擎使用的是页面锁，但也支持表级锁；

**（3）主键和外键：**MyISAM **可以没有任何索引、主键，一定没外键**；InnoDB一定有主键（没设置用唯一索引当，没唯一用自动生成主键），支持外键

一个表只能有一个主键，主键不可以为空， 建立主键的同时也会建立一个唯一性索引，主键可以包含多个属性，如联合主键

**（4）索引结构：**MyISAM 和 InnoDB 都使用**B+树索引**，MyISAM使用的是**非聚簇索引，主键索引和辅助索引的Data域都是保存数据行地址。**InnoDB主键一定是聚簇索引（数据和索引存一起），**主键索引的数据域存储的是该行数据，辅助索引的数据域存储主键的值**，InnoDB最好是用自增主键，插入数据时维持B+树结构

使用辅助索引需要二次查找回表操作：首先检索辅助索引获得主键，然后用主键到主索引中检索获得数据记录。

不建议过长的字段作为主键：辅助索引的数据域存储主键的值，主键字段过长会导致辅助索变大，主键索引变辅助索引也跟着会变。

（5）表的具体行数：

① MyISAM：保存有表的总行数，如果使用 select count() from table 会直接取出出该值，不需要进行全表扫描。
② InnoDB：没有保存表的总行数，如果使用 select count() from table 需要会遍历整个表，消耗相当大。

（6）MyISAM 读取速度快、占用资源比较少

### 4、ACID的实现原理***

1）原子性是通过MySQL的**undo log回滚日志**来实现的，MySQL 执行写操作之前，会把相反sql记录到 undo log 日志里，回滚便利用undo log中insert会执行delete相反操作。

2)  一致性是通过事务的原子性、持久性和隔离性来保证的，代码保证业务数据的一致性。

3）Innodb事务的隔离级别是**基于undo log的MVVC，readview和锁机制实现的：**

① MVCC（Multi-Version Concurrency Control，**多版本并发控制）实质是保存数据在某个时间点的快照**来实现的，只在 **可重复读 和 读已提交 两个隔离级别下才会工作，读写锁就不冲突了**（ 读未提交总是读取最新的数据行，无需使用 MVCC。读序列化要对所有读取的行都加锁，单纯 MVCC 无法实现）

MVCC是通过在每行数据中都有隐藏列来实现的：

**trx_id：**存储每次对某条聚簇索引记录修改时的**事务id**，每开始一个新的事务，都会自动递增产生一个新的事务ID。

**roll pointer：回滚指针**，修改一次生成一个版本，会有版本链，**回滚指针指向undo log回滚日志记录的上一个版本**，上条指向了更上条的undo log，从而形成了undo log的版本链。(插入操作没有这个属性，没有上一个版本)

<img src="/image-20210908004635149.png" alt="image-20210908004635149" style="zoom:67%;" />

但是具体恢复到哪个版本，需要根据ReadView确定：

读已提交和可重复读的区别就在于它们生成ReadView的策略不同。
**readView维护当前活动的事务id（未提交的事务）**，递增排序生成一个集合

当访问数据时，会将事务id与readview对比：如果在readview的左边(比readview都小，已经提交)，可以访问，其实就是比较回滚日志的事务id；

如果在readview的右边或者就在readview中，则没提交，不可以访问，则获取回滚指针，取上版本重新对比

读已提交隔离级别的事务在每次查询的开始都会生成一个独立的ReadView；可重复读隔离级别之后的读都复用第一次的ReadView，去版本链中读值。

Mysql的MVCC通过版本链，实现多版本并发读写。并可通过比较版本解决快照读的幻读问题，但当前读的幻读MVCC并不能解决，要通过临键锁来解决。**通过ReadView生成策略的不同实现不同的隔离级别。**

**快照读：**数据的读取将由 cache(原本数据) + undo(事务修改前的数据) 两部分组成；**当前读：**通过锁机制来保证读取的数据是最新版本

② 锁机制

**排它锁（写锁）解决脏读，update/insert/delete会自动获取排它锁**
**共享锁（读锁）解决不可重复读。读写锁都是悲观锁/行级锁**
**Mvcc解决快照读的幻读问题，临键锁/间隙锁解决当前读的幻读**

4)  持久性的依靠**redo log重做日志**实现，数据库宕机了，只需要读取 redo log 里面的数据，就可以恢复。

redo log实现上物理日志，**采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志**

**① 为什么不直接将缓冲数据写到磁盘？**

缓冲区刷**脏数据是以数据页为单位**，事务也可能会涉及不同的页面，**刷盘会产生很多随机IO**，redo log是追加操作**，所以redo log落盘是顺序IO**，redo log写入磁盘更快捷。

② 什么时候刷盘？

redo log写满了，check point 需要向前推进，推进的区间涉及到的脏页需要刷到磁盘中

pool溢出，内存不够了

刷新频率由 innodb_flush_log_at_trx_commit变量来控制的。

③ **redolog写入过程？**

当数据发生修改时，先在 redo log 里面记录本次操作，然后再修改缓冲区中的数据，之后设置redolog 状态为 prepare ，生成 bin log主从复制用的日志，并写入磁盘，redo log 状态为 commit，在事务提交时，会对redo log进行刷盘，缓冲区可以设定不刷盘。

④ 在事务提交期间发生了崩溃？

若redo log 是commit状态，则直接提交。若redo log 是 prepare状态，判断 bin log，若bin log 完整，就提交事务，否则回滚。

#### **1）binlog redolog undolog区别？**

redolog是**物理日志，持久性，引擎层**。

**undolog是逻辑日志，原子性，在存储引擎层。可以用于回滚，同时可以提供（MVCC）**

**binlog二进制文件，逻辑日志，主要使用场景有两个，分别是主从复制和数据恢复，在服务层。**

逻辑日志：记录sql语句
物理日志：记录的就是数据页变更

#### 2）事务备份的checkoutpoin机制

<img src="/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIwMjI1OTEzMDE5" alt="这里写图片描述" style="zoom: 67%;" />

检查点checkpoint技术的核心就是把缓冲池中的脏页刷新到磁盘，保证交易数据的持久性。

checkpoint机制目的是解决以下几个问题：

1、数据库发生宕机时，因为Checkpoint之前的页都已经刷新回磁盘。只需对Checkpoint后的重做日志进行恢复，这样就大大缩短了恢复的时间。（利用LSN）

2、缓冲池不够用时，根据LRU算法，将脏页刷新到磁盘

3、重做日志不可用时，将缓冲池中的脏页至少刷新到当前重做日志的位置刷新脏页。（脏页：内存中的数据与磁盘上的数据不一样则成为脏页。）

### 5、数据库中的锁机制**

锁机制基本原理：事务修改数据库前需要获得相应的锁。没获取到锁的事务想修改数据要等当前事务提交或回滚后释放锁才行。

锁的种类：

按锁的粒度划分：表级锁（冲突多，速度快）、行级锁（冲突少，速度慢）、页级锁（折中）
按锁的类型划分：共享锁（S锁、读锁）、排它锁（X锁、写锁）
按锁的使用策略划分：乐观锁、悲观锁
1、表级锁、行级锁、页级锁：

表级锁：最大粒度的锁级别，发生锁冲突的概率最高，并发度最低，但开销小，加锁快，不会出现死锁；
行级锁：最小粒度的所级别，**发生锁冲突的概率最小，**并发度最高，**但开销大，加锁慢，会发生死锁；**
页级锁：锁粒度界于表级锁和行级锁之间，对表级锁和行级锁的折中，并发度一般。开销和加锁时间也界于表锁和行锁之间，会出现死锁；

2、InnoDB的**行锁有两种类型**：

共享锁（S锁、读锁）：多个事务可以对同一数据行共享一把S锁，但**只能进行读不能修改**
排它锁（X锁、写锁）：锁定期间其他事务不能再获取这部分数据行的锁（共享锁、排它锁），只能写

select * from table where ? lock in share mode; (普通select，不用加锁，快照读)

select * from table where ? for update/insert/delete; (加X锁，当前读，不能读/修改数据)

3、InnoDB的表锁与意向锁：

InnoDB允许行锁和表锁共存，两者锁定范围不同会相互冲突。当加表锁时，要先遍历该表判断是否排他锁，低效。**故用意向锁来检测表锁和行锁的冲突。**

**意向锁也是表级锁**，分为读意向锁（IS锁）和写意向锁（IX锁）。当**事务要在记录上加上行锁时，则先在表上加上对应的意向锁。之后事务如果想锁表，只要先判断是否有意向锁存在，存在则可快速返回该表不能启用表锁，否则就需要等待，提高效率。**

4、InnoDB行锁的实现与临键锁：

InnoDB的**行锁是通过给索引上的索引项加锁**来实现的。只有**通过索引检索数据，才能使用行锁，否则将使用表锁。**

**在InnoDB中，为了解决幻读的现象，引入了临键锁(next-key)/间隙锁**。根据索引划分为一个个左开右闭的区间。当进行范围查询的时候，若命中索引且能够检索到数据，则锁住记录所在的区间和它的下一个区间。其实，临键锁(Next-Key) = 记录锁(Record Locks) + 间隙锁(Gap Locks)

间隙锁：**当使用范围查询，innodb会对范围内的数据加锁，锁的是一个范围/间隙(GAP)，其中不存在的数据也会锁上。**当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，造成在锁定的时候无法插入锁定键值范围内的任何数据。如：锁135，24没有的也加锁，不能插入了。解决：逻辑删除，不是真实删除，避免产生间隙锁。
记录锁：当使用唯一索引且记录存在的精准查询时，锁一条记录

##### 1）事务的并发控制

MVCC：

乐观锁：一种思想，当线程去拿数据的时候，认为别的线程不会修改数据

时间戳：时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存

悲观锁：当线程去拿数据的时候，总假设别的线程会去修改数据，所以它每次拿数据的时候都会上锁，别的线程去拿数据的时候就会阻塞。读写锁，写者优先于读者，唤醒时优先考虑写者。

**一张表的并发量和什么有关？【CPU核数、连接数、表的互斥访问数】并发数量大致是多少？MySQL服务器的最大并发连接数是16384。一个分表后的数据库实例能顶住多大的并发请求（500左右）**

### 6、MySQL索引

索引：是一种减少查询所需遍历行数，加快查询性能的**数据结构**。（一个表最多16个索引，最大索引长度256字节）

优势：**查询检索效率高**，降低数据库 Io成本；对数据排序，降低cpu 排序成本；

劣势：**写操作时索引也要更新，速度变慢；磁盘占用空间更多**。

原理：将无序的数据变成有序的查询，倒排表。

#### 1）需要创建索引

创建索引：CREATE INDEX idx_age_deptid_name ON emp(age,deptid,NAME)

1. 主键**自动建立唯 一 索引**
2. WHERE语句中**频繁作为查询条件**的字段
3. 查询中与其它表**关联的字段**（外键）
5. **group by或order by**中使用的字段（groupby中其实已经做了一次排序了，更消耗性能）
7. 单键/组合索引，选择**组合索引**

#### 2）不要建立索引

1. **表记录太少**：查询速度提升不大，但写操作（INSERT、UPDATE和DELETE）速度变慢；磁盘占用空间更多；
2. **经常增删改的表**：写操作（INSERT、UPDATE和DELETE）速度显著变慢；
3. **过滤性不好的字段**（只含A、B两种情况，比如性别），搜索的范围还是很大
4. where条件中用不到的字段不需要

#### 3）索引的分类

①普通索引：最基本的索引，没有任何限制
	唯一索引：数据值必须唯一，**允许有空值，可以有多个NULL值**。如果是组合索引，则列值的组合必须唯一。
	主键索引：一种特殊的唯一索引，不允许有空值。
	全文索引：建立倒排索引，并只支持从CHAR、VARCHAR或TEXT类型，用于替代效率较低的like 模糊匹配，鸡肋，用ES
	组合索引：索引可以覆盖多个数据列，创建组合索引时应该将**最常用的列放在最左边，匹配时用最左原则**。

②**聚簇索引**：数据和索引放在一起存储，**表中数据存储的物理顺序与索引顺序一致**，一个基本表最多只能有一个聚簇索引。聚和非聚都是B+树。
	**非聚簇索引**：叶子节点存的**是数据行地址**不是数据，要二次查询，表中数据的物理顺序与索引顺序不一致，一个基本表可以有多个聚簇索引。

**主键索引和唯一索引：**

主键索引一定是唯一的。

**一个表只能创建一个主键，但可创建多个唯一索引。**

**唯一性索引列允许空值， 而主键列不允许为空值。**

**唯一索引和普通索引**：

查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足 条件的记录

唯一索引，查找到第一个满足条件的记录后，就会停止继续检索

####  4）为什么使用B+Tree作为索引

常见的索引的数据结构有：B+Tree（平衡的多路查找树）、Hash索引。

* 二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。
* 平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。
* 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了	AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。
* B树，范围查询父子节点间横跳，回旋查找；**而B+树 叶子节点双向链表结构，范围查询效率高。非叶子节点不存数据，出入更大，树的深度更小；**

##### 1、Hash索引

即hash表，索引是hash值存储，MySQL只有Memory存储引擎支持hash索引，是Memory默认索引类型。等值查询一次hash算法即可定位

hash索引的缺点：

Hash索引仅能满足等值的查询，**不能满足范围查询、排序**。因为数据计算Hash值后小关系就可能发生变化了。
当创建组合索引时，**不能只使用组合索引的部分列进行查询**。因为hash索引是把多个列数据合并后再计算Hash值。
当发生Hash碰撞时，Hash索引不能避免表数据的扫描。因为仅仅比较Hash值是不够的，需要比较实际的值以判定是否符合要求。

##### 2、平衡多路查找树

B+Tree索引：是Innodb和Myisam存储引擎的索引类型。在查询速度比不上Hash索引，但是更适合范围查询、排序等

大量数据存储的查询场景下，索引本身也很大，不可能全部存储在内存中，因此**索引往往以索引文件的形式存储在磁盘上**。相对于内存存取，磁盘I/O存取的消耗要高几个数量级，故**索引的数据结构要尽量减少查找过程中磁盘I/O次数。二叉树的深度过大不能使用，这时要使用平衡多路查找树。**

**局部性原理与程序预读：**

考虑到磁盘I/O效率低，每次都会预读，即使只需要一个字节，磁盘也会顺序向后读取一定长度的数据放入内存。**局部性原理：因为程序运行期间所需要的数据通常比较集中，故当一个数据被用到时，其附近的数据也通常会马上被使用。**预读可以提高I/O效率。**预读是整页整页读的。**当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

**B树和B+树利用了磁盘预读原理，将一个节点的大小设为等于一个页**，即每次新建节点时，直接申请一个页的空间，这样就实现了每个节点只需要一次I/O就可以完全载入。B树中一次检索最多需要h-1次I/O（根节点常驻内存），时间复杂度为O(h)=O(logdN)。一般实际应用中，节点出度d（宽度）是非常大的数字，通常超过100，因此h非常小。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，磁盘IO的次数也就更少了。

##### 1）B-树

B-Tree中的减号只是分隔符，B-Tree或B~Tree实际上指的都是B树。

定义：

1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。向上取整 
3. 所有叶子节点都在同一层，且不包含其它关键字信息 
4. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
5. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
       　　7. ki(i=1,…n)为关键字，且关键字升序排序。 
             　　8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

3阶B-Tree的结构：

![img](/424830-20190326150706037-1390683676-1631702010831.png)

每个节点占用一个盘块（页）的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。

查找关键字29，需要3次磁盘I/O操作和3次内存查找操作。由于内存中的关键字（节点内部）是一个有序表结构，可以利用**二分法查找**提高效率。

##### 2）B+树

B+树是B树的一种优化，使其更适合实现外存储索引结构。B+树元素自底向上插入，这与二叉树恰好相反。

![img](/424830-20190326153010069-1321587548.png)

**B+Tree相对于B-Tree的不同点：**

B+树减少磁盘IO：每个非叶子节点只存储关键字和指向下个节点的指针（指的是磁盘块的偏移量），**比B树少了data数据域**，每个节点可存储更多的key值(节点出度更大），**降低B+Tree的高度，I/O读写次数也就降低了**(少1/3)；数据都存储在叶子结点上；所有叶子节点都通过指针相连，相当于**环形双向链表**（有头尾前后指针），很适合范围查询。

B+树的查询效率更加稳定：任何关键字的查找必须从根结点到叶子结点。所有关键字**查询的路径长度相同**，故查询效率相当。

**B树只适用于随机检索，不适用于顺序检索，而B+树适用于顺序检索和随机检索；两者都可用于文件的索引结构。**

**Mysql索引中B+树通的高度通常为2~4层**：

InnoDB存储引擎中页的大小为16KB，主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。

![image-20210831221250199](/image-20210831221250199.png)

#### 5）常见索引失效

非**最左前缀原则**：树是分层级的，前面一层命中了才能命中下一层。不一定用到全部索引，但要从左连起来用。**过滤性最好的字段放在组合索引最左边**。

​      cba其实也全部用到了索引，优化引擎会判断。

**like 的前导模糊查询**：like '%XX'	不能使用索引；like  'XX%'	可以使用索引

**负向条件查询**：!=、<>、not in、not exists、not like，is not null 不能使用索引 ；优化成 in 查询可以使用索引

**索引列做任何操作（计算、函数**、(自动or手动)类型转换）：abs(a) =3，phone=13800001234  不能， phone='13800001234'  可以

**范围条件右边的列不能使用索引**（前面的数有确定的值后面索引才能用到二分查找确定）：where a = 3 and b > 4 and c = 5	使用到a和b， c不能。**尽量把范围查询的字段放在索引的最后面**

当MySQL中字段为int时，where num=‘111‘ 与111都可使用索引，当字段为varchar时，where num=‘111‘ 可以使用索引，而111 不可以使用索引

#### 6) 索引下推

索引下推 其实就是指将（服务层）负责的事情，交给了（引擎层）去处理。

对于联合索引，判断条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录**。目的是为了减少回表次数，也就是要减少IO操作**

没有用索引下推：

![image-20220721145741834](/image-20220721145741834.png)

用了索引下推：

如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。

![image-20220721145816738](/image-20220721145816738.png)

#### 7）索引优化、SQL优化和表结构优化

优化指南：创建并使用正确的索引；只返回需要的字段；批量提交，减少交互次数

**索引优化，索引原则：**

1) 注意哪些适合索引哪些不适合索引，组合索引失效的情况；

2) 更新十分频繁、数据区分度不高的列不宜建立索引；explain 中的 type 最好能到达 ref 级别，至少要达到 range 级别；

3) 使用前缀索引：用列的前缀代替列名作为索引，短索引可以节省磁盘空间和I/O操作。但缺点是不能用于 ORDER BY 和 GROUP BY，覆盖索引 操作。

4) 利用**覆盖索引**来进行查询操作（**查询只需从索引中就能够取得而不必从数据表中读取。select 查询的字段都在索引中**），避免回表；

5) 利用索引下推减少回表的次数

**SQL语句优化：**

1) **减少请求的数据量：只返回必要的列**，用具体的字段列表代替 select * 语句

2) **优化深度分页的场景**，利用延迟关联或者子查询：对于 limit(m, n)分页查询，越往后翻页（即m越大）SQL的耗时越长

**延迟关联：通过使用覆盖索引查询返回需要的主键，再根据主键关联原表获得需要的数据**

3) 多张大数据量的表进行JOIN连接查询，最好先过滤再JOIN：减少不必要的 IO 操作

4) **小表驱动大表**，即小的数据集驱动大的数据集：in后面跟的是小表（先查小表，结果作为大表的查询条件），exists后面跟的是大表。

5) 优化Group by，使用where子句替换Having子句：having只会在检索出所有记录之后才会对结果集进行过滤

​			on、where、having这三个都可以加条件的子句，on是最先执行，where次之，having最后

6）尽量使用Join代替子查询： MySQL不需要在内存中创建临时表

7）union（句子 union 句子）、in、or 都能够命中索引，但推荐使用 in：**in 一次查询**后在 in 的集合里筛选。or随后面条件增多**执行的效率下降，in不会**

8）使用union all 替换 union：union会去重（相当于distinct），先union all 取交集，再对获取的结果进行排序操作

**数据库优化：**

首先尽可能将磁盘IO转化为内存IO（快100倍）。主要针对减少磁盘IO的参数做优化：比如使用 query_cache_size （缓存结果集）调整查询缓存的大小，使用 innodb_buffer_pool_size 调整缓冲区的大小；数据库IO操作的时候是以 page 的方式，如果我们每行记录所占用的空间量减小，就会使每个 page 中可存放的数据行数增大，减少page ，降低 IO 操作次数

1）**数据类型的选择：**

​	对于整数的存储，在数据量较大的情况下，**建议区分开 TINYINT / INT / BIGINT 的选择，因为三者所占用的存储空间也有很大的差别**

​	对于定长字段，建议使用char(n) 类型，不定长字段尽量使用 varchar （不存的时候不占空间）

​	非万不得已不要使用 TEXT，DOUBLE 数据类型

2）表结构设计：典型的反范式设计

适当拆分：表中存在类似于 TEXT 或者是很大的 varchar 类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们可以将其拆分到另外的独立表中，以减少常用数据表所占用的存储空间。既减少物理 IO 次数，也能大大提高内存中的缓存命中率。

**适度冗余：**被频繁引用且只能通过 Join连接 2张（或者以上）大表的方式才能**得到的独立小字段，会造成大量不必要的 IO（每行都很多），**完全可以通过空间换取时间的方式来优化。不过，冗余的同时需要确保数据的一致性，确保更新的同时冗余字段也被更新。

3）**尽量不使用null：**尽量确保 默认值不是 NULL，数字可以默认0，字符串默认""

1. **NOT IN子查询在有NULL值的情况下返回永远为空结果，查询容易出错。**
2. 索引问题，单列索引无法存储NULL值，where对null判断会不走索引。
3. 如果在两个字段进行拼接（CONCAT函数），首先要各字段进行非null判断，否则只要任意一个字段为空都会造成拼接的结果为null
4. 如果有 Null column 存在的情况下，count(Null column)需要格外注意，null 值不会参与统计。
5. **Null列需要更多的存储空间：需要一个额外的字节作为判断是否为NULL的标志位**

### 7、explain的执行计划

执行计划：SQL语句经过查询**分析器后得到**的 **抽象语法树 和 相关表的统计信息** 作出的一个**查询执行顺序的方案**，这个方案是由查询优化器自动分析产生的。由于是动态数据采样统计分析出来的结果，所以可能会存在分析错误的情况，也就是存在执行计划并不是最优的情况。   **explain+sql语句 ：**

![img](/2018112215033993.png)

id：**SQL执行顺序的标识**，有几个select 就有几个id，查询趟数越少越好。id值越大优先级越高，越先被执行，id值相同，从上往下依次执行

select_type：查询的类型，区分普通查询、联合查询、子查询等复杂的查询

**type：查询使用的类型**。依次从好到差：system>const>eq_ref>ref>range>index>ALL，除了all之外，其他的 type 类型都可以使用到索引。**最好能到达 ref 级别，至少要达到 range 级别**。

​	system：表中只有一行记录，系统表

​	consts：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。

​	eq_ref：唯一索引扫描，匹配一条记录。不是主键，可能会回表查询

​	ref：非唯一索引扫描，有多个匹配行

​	range：对索引进行范围检索，in，between，<，>。

​	index：遍历所有索引，一般是使用了覆盖索引或者是利用索引进行了排序分组。

​	all：全表扫描

**key：实际使用哪个索引来优化对该表的访问**，索引和查询的select字段重叠则覆盖索引

key_len：实际上用于优化查询的索引长度，即索引中使用的字节数。通过这个值，可以计算出一个多列索引里实际使用了索引的哪写字段。

rows：大致估算此处查询需要读取的行数。越少越好

**extra：其他的一些额外信息：**

​	using index：使用覆盖索引
​	using temporary**：用临时表保存中间结果。通常是因为 group by （order by ）的列上没有索引，**也有可能是因为同时有group by和order by，但group by和order by的列又不一样
​	using filesort：MySQL可以用 索引 或 filesort（文件排序，基于快排实现的外部排序，性能较差）对查询结果进行排序，当数据量很大时，**没有用到索引排序，**filesort将会对CPU产生很大压力

​	临时表和filedort优化：filedort从业务看字段是否用到排序，不用排序的不用加入索引中，要的话看怎么加索引好。临时表看是否有意义，需要的话数据体量尽量降低。

### 8、MySQL的主从复制**

1、原理：

<img src="/image-20211016202407281.png" alt="image-20211016202407281" style="zoom:67%;" />

**MySQL主从复制主要由三个线程完成：**Slave( **SQL** thread、**I/O** thread)，master(Binlog **dump** thread)
注：若是一主两从，主有两个Binlog dump 线程，每个从有两个线程；

**主库会将所有变更记录到binlog二进制日志文件中，当binlog有变动时，主节点的log dump线程读取其内容并发送给从节点；从节点I/o线程接收binlog内容，并将其写入到relay log 中继日志末端；从节点的SQL线程读取relay log文件内容在从机上重新执行一遍，最终保证主从数据库的一致性。**

注︰主从节点使用binglog文件+ position偏移量来定位主从同步的位置，从节点会保存已收到的偏移量，如果从节点宕机重启，则会从偏移量的位置发起同步。
**主从复制是异步且串行化的（主库并行从库串行化），因此Slave和Master的数据存在延迟，只能保证数据的最终一致性。**主库挂了的话就数据丢失了，故有：

全同步复制：主库写入binlog后强制同步日志到从库，**所有的从库都执行完成后才返回给客户端**，但性能会受到严重影响。解决主从同步延时问题。

半同步复制：和全同步不同的是，从库写入日志成功后返回ACK确认给主库，主库收到**一个从库的确认就认为写操作**完成。解决主库数据丢失问题

**2、读写分离/主从复制的好处：**

**负荷分摊；读写分离，缓解X锁和S锁争用；从库可配置MyISAM引擎，提升查询性能以及节约系统开销；增加冗余，备份主服务器数据，提高可用性。**
3、binlog日志文件的格式：

（1）基于语句的复制（Statement-Based）：默认格式为Statement-Based，在从服务器上执行主服务器上同样的SQL语句。效率较高。

优点：① 因为记录的SQL数据库操作语句，所以**占用更少的存储空间**。 insert、update、create、delete等操作。对于select、desc等类似的操作并不会去记录。
			② binlog日志文件记录了所有的改变数据库的语句，所以此文件可以作为数据库的审核依据。
缺点：① **不安全，不是所有的改变数据的语句都会被记录**。对于非确定性的行为不会被记录。例如：对于 delete 或者 update 语句，如果使用了 limit 但是并没有 			order by 就不会被记录。② 对于没有索引条件的update，insert……select 语句，必须锁定更多的数据，降低了数据库的性能。
（2）基于行的复制（Row-Based）：把改变的内容复制过去，而不是把命令在从服务器上执行一遍，从mysql5.0开始支持；
（3）混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。

4、mysql和redis主从复制的区别

相同：都是一个master，多个slave，集群都是异步复制的
不同：复制内容：mysql的主从复制是从接入点开始，主机之前的数据，从机不会复制，但是redis是从头开始备份，主机之前的数据，从机也会获得

​			原理区别：mysql从机要写入中继日志，读写分离有延迟；redis主机直接和从机沟通；

5、主服务器怎么确定从服务器同步完成了呢？同步失败了怎么办？

判断：看主从同步状态，Slave_IO_Running 和 Slave_SQL_Running 两个线程的状态，YES表示完成

失败原因：表结构不一样，数据原本不一样，同步过去就报错了。

失败了：在从数据库中，先停止从库，使用SET全局sql_slave_skip_counter跳过这一个错误事件，从下一个事件组开始。启动从库

### 9、分库分表**

**读写分离解决的是数据库读写操作的压力，分库分表可以分散数据库的存储压力，并提升数据库的查询效率。**

1、**垂直拆分**：

1）垂直分表：**按照字段拆分。一般会将常用的字段放到一个表中，将不常用的字段放到另一个表中。**

优点：1）避免IO竞争减少锁表的概率。因为字段占用的空间更大使得IO操作增多且数据量大需要的读取时间长。

​			2）可以更好地提升热门数据的查询效率。

2）垂直分库：按照业务模块的不同，将表拆分到不同的数据库中，适合业务之间的耦合度非常低、业务逻辑清晰的系统。

优点：降低业务中的耦合，方便对不同的业务进行分级管理；可以提升IO、数据库连接数、解决单机硬件存储资源的瓶颈问题
3）垂直分库/分表的缺点：主键出现冗余，需要管理冗余列；事务的处理变得复杂；仍然存在单表数据量过大的问题
2、**水平拆分**：

1）水平分表：**在同一个数据库内，把同一个表的数据按照一定规则拆分到多个表中。**

优点：解决了单表数据量过大的问题；避免IO竞争并减少锁表的概率
2）水平分库：把同一个表的数据按照一定规则拆分到不同的数据库中，不同的数据库可以放到不同的服务器上。

优点：解决了单库大数据量的瓶颈问题；IO冲突减少，锁的竞争减少，某个数据库出现问题不影响其他数据库，提高了系统的稳定性和可用性
3）水平分表/分库的缺点：分片事务一致性难以解决；跨节点JOIN性能差，逻辑会变得复杂；数据扩展难度大，不易维护

3、**分库分表存在的问题的解决：**

（1）**事务的问题**：

① **方案一：使用分布式事务：**

优点：由数据库管理，简单有效。
缺点：性能代价高，特别是shard越来越多。
② 方案二：程序与数据库共同控制。将一个跨多个数据库的分布式事务分解成多个仅存在于单一数据库上面的小事务，并交由应用程序来总体控制各个小事务。

优点：性能上有优势；
缺点：需要在应用程序在事务上做灵活控制。如果使用了spring的事务管理，改动起来会面临一定的困难。
（2）**跨节点 Join 的问题：**

解决该问题的普遍做法是**分两次查询实现**：在第一次查询的结果集中找出关联数据的id，根据这些id发起第二次请求得到关联数据。

（3）跨节点count，order by，group by，分页和聚合函数问题：

由于这类问题都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作，解决方案：与解决跨节点join问题的类似，**分别在各个节点上得到结果后在应用程序端进行合并**。和 join 不同的是每个结点的查询可以并行执行，因此速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。

4、**分库分表后，ID键的处理：**

分库分表后不能每个表的ID都是从1开始，所以**需要一个全局ID：**

（1）UUID：优点：本地生成ID，不需要远程调用，全局唯一不重复。缺点：占用空间大，不适合作为索引。
（2）数据库自增ID：需要一个专门用于生成主键的库，每次服务接收到请求，先向这个库中插入一条没有意义的数据，获取一个数据库自增的ID，利用这个ID去分库分表中写数据。	优点：简单易实现。		缺点：在高并发下存在瓶颈。
（3）Redis生成ID：优点：不依赖数据库，性能比较好。	缺点：引入新的组件会使得系统复杂度增加
（4）Twitter的snowflake算法：是一个64位的long型的ID，其中有1bit是不用的，41bit作为毫秒数，10bit作为工作机器ID，12bit作为序列号。
（5）美团的Leaf分布式ID生成系统

### 10、分区

**分区就是将表的数据按照特定规则分割存放在不同的区域，在查询数据的时候，只需对存储相应数据的区域进行查询，不需要对表数据进行全部的查询，提高查询的性能。同时如果表数据特别大，也可以将数据分配到不同的磁盘，利用多个磁盘，也能够提高磁盘的IO效率**。需要注意分区字段必须放在**主键或者唯一索引**中、每个表最大分区数为1024；常见的分区类型有：Range分区、List分区、Hash分区、Key分区

（1）Range分区：按照连续的区间范围进行分区
（2）List分区：按照给定的集合中的值进行选择分区。
（3）Hash分区：基于用户定义的表达式的返回值进行分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式。
（4）Key分区：类似于按照HASH分区，区别在于Key分区只支持计算一列或多列，且key分区的哈希函数是由 MySQL 服务器提供。

分区方便管理，对于失去保存意义的数据，通过删除对应的分区比detele删除效率更高；在某些场景下单个分区表的备份恢复会更有效率。

### 11、主键用自增ID还是UUID

（1）自增ID：字段长度较 UUID 会小很多，占用空间小。缺点：容易被其他人查到业务量。数据迁移时或表合并时麻烦。高并发竞争自增锁压力
（2）UUID：通用唯一标识码，UUID是基于当前时间、计数器和机器的硬件标识。
一般情况下，**MySQL推荐使用自增ID，因为在MySQL的 InnoDB 存储引擎中，主键索引是聚簇索引，B+树的叶子节点按照顺序存储了主键值及数据，若主键索引是自增ID，只需要按顺序往后排列即可，若是UUID，ID是无序的，在数据插入时会造成大量的数据移动，产生大量的内存碎片，造成插入性能的下降**

### 12、慢查询优化

**慢查询记录响应时间超过阈值的sql（默认10秒，可以通过参数设置），Mysql慢查询默认不开启，开启：**set global slow_query_log=1 ，但重启mysql失效，要再my.cnf配置中开启。看slow_query_log日志。

慢查询的统计主要由运维在做，优化针对三个方向来的：

分析sql 语句，看看是否加载了额外的数据，select * 额外的字段。

**explain分析sql 语句的执行计划，然后获得其使用索引的情况，使得语句可以尽可能的命中索引和使用较高效率的索引。**

如果对sql 语句的已经无法优化，表中的数据量太大的话可以进行**横向或者纵向的分表**。

### 13、MySQL的其他名词

1、视图View

视图是由基本表导出的表，其内容由查询定义。视图是一个虚拟表，数据库中只存储视图的定义，不存储视图对应的数据，在对视图的数据进行操作时，系统根据视图的定义去操作相应的基本表。

视图的优点：简化了操作；安全性，用户只能查询和修改能看到的数据；缺点：性能差，数据库必须把对视图的查询转化成对基本表的查询。

2、存储过程Procedure

SQL语句需编译后存储在数据库中，存储过程就是一组为了完成特定功能的SQL语句集，用户通过制定存储过程的名字并给定参数来调用它。

优点：标准组件式编程；避免了非授权用户对数据的访问，保证了数据的安全。

3、触发器Trigger

触发器是与表有关的数据库对象，当触发器所在表上出现指定事件并满足定义条件的时候，将执行触发器中定义的语句集合。触发器可以确保数据的完整性。

4、游标Cursor

游标，就是游动的标识，可以充当指针的作用，使用游标可以遍历查询数据库返回的结果集中的所有记录，但是每次只能提取一条记录，即每次只能指向并取出一行的数据，以便进行相应的操作。

### 14、MySQL语句

SQL语句书写顺序select、from、join on、where、group by、having、order by、limit 

**执行顺序：from、join on、where、group by、having、select、order by、limit**

查询字段要与group by中的字段相同或为函数（max，sum）

**inner和outer都可以省略**

![image-20210923173631712](/image-20210923173631712.png)

### 15、查询方式

JDBC提供了Statement、PreparedStatement 和 CallableStatement三种方式来执行查询语句，都是接口。

继承关系：

<img src="/image-20210926181814175.png" alt="image-20210926181814175" style="zoom: 80%;" />

1、**Statement：**

普通的不带参的查询SQL

**每次的执行都需要编译SQL**

支持批量操作

${ }，sql注入：

2、**PreparedStatement：**

**支持可变参数的SQL，一个占位符 ? 只能对应一个值**

会预编译，会被缓冲，虽然会被再次解析，但不会被再次编译，**编译一次，多次执行，**多次重复执行的语句，使用PreparedStament效率会更高

添加了处理 IN 参数的方法

安全性好，**有效防止Sql注入等问题**

支持批量操作

#{ } ,

3、**CallableStatement：**

支持调用存储过程，**提供了对输入/输出参数(IN/OUT)的支持**

有 PreparedStatement 的功能

### 16、truncate与delete

**delete可加 where 删除对应的行（不加删全部）；truncate会删全部行**

delete是DML，**truncate是DDL。truncate 比 delete（一行一行的删）速度快，是通过删除表（drop）然后重建表实现的**。执行速度: drop> truncate > delete。 drop table 会删除表结构及其数据。 truncate table与delete都保留表结构

**delete 出现错误可以回滚ROLLBACK；truncate无法回滚**。

delete可以返回被删除的记录行数，truncate不能。**truncate后索引重新设置为初始大小；delete使用删除前的顺序。**

如果一个表的**主键（InnoDB）作为了另一个表的外键**，则truncate无法删除这个表中的数据，无论这个外键是否存在，这是由于drop表限制的。而delete可以，只要这个表的主键在另一个表的外键中不存在即可。

### 17、DDL与DML

DDL：数据库定义语言，creat datebase (if not exists) db;  drop datebase (if exists) db;	alter;	creat table (if not exists)  tb(字段1 类型 [约束]，……)

DML：数据库操纵语言，insert into tb(字段1，字段2)  values(值1，值2),(值11，值22); 	delete from tb where id is null;

update tb set 字段1=值1,字段2=值2； select * from tb;	



# 项目面试题

## 1、redis 在项目中的使用场景

| 数据类型 | 使用场景                                                     |
| -------- | ------------------------------------------------------------ |
| String   | 接口保护，什么时候**封锁一个 IP 地址** （某一个IP地址在某一段时间内访问的特别频繁，那有可能这个IP可能存在风险）<br/>使用 **Incrby** 命令记录当前IP访问次数，累加 |
| Hash     | **存储用户信息**[ id, name , age] <br />Hset( key ,field, value) <br />Hset( key ,id, 101)<br />Hset( key ,name, admin)<br />Hset( key ,age, 23)<br />修改案例---------<br />Hget(userKev,jd)+<br/>Hset(userKey,id,102)<br/>不建议使用String 类型存储,，String拿到对象值之后需要反序列化，若只需修改id ， name, age 也反序列化了，没意义<br/>Set(userKey;用信息的字符串)<br/>Get(userKey) |
| List     | 实现最新消息的排行，还可以利用 List 的 **push** 命令，将任务存在list集合中，同时使用 **pop** 将任务从集合中取出。<br/>Redis - List 数据类型来**模拟消息队列**。[**电商中的秒杀**就可以采用这种方式来完成一个秒杀活动]。 |
| Set      | 可以**自动排重**。比如说微博中将每个人的**好友存在集合**( Set) 中，这样求两个人的共通好友的操作。我们只需要求交集即可。 |
| Zset     | 以某一个条件为权重，进行**排序**。京东:商品详情的时候，都会有一个综合排名，还可以按照价格进行排名 |

## 2、Elasticsearch 与 solr 的区别

他们都是基于 Lucene 搜索服务器基础上开发，一款优秀的，**高性能**的企业级搜索服务器，【他们都是基于分词技术构建的**倒排索引**的方式进行查询】

开发语言：Java

Solr：2004年诞生 ；	ES：2010年诞生（ES 更功能强大）

区别：

1、当**实时建立索引**的时候，solr 会产生 **io 阻塞**，而 es 不会，es 查询性能要高于 solr

2、在不断**动态添加数据**的时候，solr 的**检索效率**会变得低下，而 es 没有什么变化

3、Solr 利用 **zookeeper** 进行分布式管理，而 es 自带有分布式系统的管理功能，Solr 一般都要部署到 web 服务器上，比如 tomcat，启动 tomcat 的时候需要配		置 tomcat 和 solr 的 关联 【 **Solr 的本质，是一个动态的 web项目**】

4、Solr支持更多格式的数据 【xml、json、csv 】等，而 es 仅**仅支持 json** 文件格式

5、Solr 是传统搜索应用的有利解决方案，但是 es 更加适用于新兴的是是搜索应用，单纯的对**已有的数据**进行检索， solr 效率更好，高于 es

6、 Solr 官网提供的功能更多，而 es 高级功能都有第三方插件完成

SolrCloud 集群图：

![image-20201011124454764](/solr.png)

Elasticsrarch ：集群图

![image-20201011124527754](/image-20201011124527754.png)

## 3、单点登录

单点登录：一处登录，处处运行 。前提：单点登录多使用在分布式系统中

![](/dandian.png)

京东：单点登录是将 token 放入到 cookie 中。将浏览器的 cookie 禁用，则在登录京东则失效，无论如何登录不了

## 4、购物车实现过程

购物车：

​	1、购物车跟用户的关系 ？

​				a）一个用户必须对应一个购物车【一个用户不管买多少商品，都会存在属于自己的购物车中】

​				b）单点登录一定要在购车前

​	2、跟购物车有关的操作有那些？

​					a）添加购物车

​							用户未登录状态

​										添加到什么地方，未登录将数据保存到什么地方？

​											Redis ---京东

​											Cookie ----存在 Cookie 的 Local Storage 中【如果浏览器禁用Cookie】

​							用户登录状态

​										Redis 缓存中 【读写速度快】,用 Hash：

​											    Hset(key,field,value)

​												Key：user:userId:cart

​												Hset(key,skuId,value);

​										存在数据库中 【Oracle，mysql】，保证数据安全性

​				b）展示购物车

​						用户未登录状态

​								直接从 cookie 中 取得数据展示即可

​						用户登录状态

​								用户一旦登录，必须显示数据库/redis + cookie 中的购物车的数据

​									

## 5、消息队列

### 1、消息队列的作用

作用：异步通信提高系统性能、流量削峰、应用解耦。

### 2、项目中使用

 在分布式系统中如何处理高并发的？

​		由于在高并发的环境下，来不及同步处理用户发送的请求，则会导致请求发生阻塞，比如说大量的 insert，update 之类的请求同时到达数据库 MySQL, 直接导致无数的行锁表锁，甚至会导致请求堆积过多，从而触发 too many connections (  链接数太多 ) 错误，**使用消息队列 异步通信 可以解决 **

1、异步

![](/2.png)

2、并行

![](/3.png)

3、排队

![image-20201014101838047](/4.png)



4、电商中的使用场景：这是没有用消息队列的，要同步运行。改进：成功支付后使用 消息队列 通知即可

![image-20201014101858126](/6.png)

5、消息队列的弊端

​		消息的不确定性： **延迟队列 和 轮询技术**来解决问题即可。

​		推荐使用 activemq ，环境都是 Java 适环境而定的

## 6、高并发系统的设计与实现**

在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。

* 缓存：大型网站一般主要是“读”，使用缓存不单单能够提升系统访问速度、**提高并发访问量，也是保护数据库、**保护系统的有效方式。在大型“写”系统中，比如累积一些数据批量写入，内存里面的缓存队列（生产消费），以及HBase写数据的机制等等也都是通过缓存提升系统的吞吐量或者实现系统的保护措施。甚至消息中间件也可以认为是一种分布式的数据缓存。
* 降级：服务降级是当服务器压力剧增的情况下，对一些服务和页面有策略的降级以**保证核心任务的正常运行。如：某些服务不处理或延迟处理，或者简单处理**
* 限流：限流可以认为服务降级的一种，一旦达到的**需要限制的阈值**，就限制系统的输入和输出流量以达到保护系统的目的。比如：**延迟处理，拒绝处理，部分拒绝处理等。**

**提高并发量经验：复杂的业务逻辑采用异步或多线程解决，数据库（数据缓存的使用），JVM性能的调优，服务的负载均衡，网络带宽，CDN资源加速，选择高性能的RPC框架**等都可以有效的提高并发量。之后再谈降级，限流。

## 7、常见的限流算法

常见的限流算法有计数器、漏桶和令牌桶算法。

令牌桶算法：**以一个恒定速度往桶里放入令牌，支持预热发放令牌**，请求处理则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。和漏桶不同，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，可以处理瞬时流量。

漏桶算法：这个桶可以固定水流出的速率。当桶满了之后，多余的水将会溢出，然后就拒绝请求。

## 8、秒杀并发情况下库存为负数问题

问题：减库存之前查询库存，之后update：在并发情况下，两个进程同时select出来的都>0，然后都会执行update

```
select quantity from products WHERE id=3;
update products set quantity = ($quantity-1) WHERE id=3;
```

解决：

1. for update显示加排他锁，效率低

   ```
   select...lock in share mode #共享锁
   select...for udpate #排他锁
   select quantity from products WHERE id=3 for update;/select quantity from products WHERE id=3 lock in share mode;
   update products set quantity = ($quantity-1) WHERE id=3;
   ```

2. 把update语句写在前边，先把数量-1，之后select出库存如果>-1就commit，否则rollback。

```
update products set quantity = quantity-1 WHERE id=3;
select quantity from products WHERE id=3 for update;
```

   **先执行了update，所以id=3的行被加了行锁，只有commit/rollback是才会被释放**

3、update语句在更新的同时加上一个条件

```
quantity = select quantity from products WHERE id=3;
update products set quantity = ($quantity-1) WHERE id=3 and queantity = $quantity;
```

**这样虽然select语句没有加锁，但是因为mysql的事务隔离级别是可重复读**，所以其他事务的修改不会影响到select的结果(加过排他锁的数据行在其他事务中是不能修改数据的，但可以直接通过select …from…查询数据，但是读取的是其他事务修改之前的老数据)


