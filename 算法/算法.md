---
typora-copy-images-to: images
typora-root-url: images
---





# 算法

本算法题解在易于理解的前提下寻求最优解，一个题可能会列出多个解，代码重要的地方会用 // 标记。

牛客网：

​	类名为Main。使用集合，工具类先导入：import java.util.*;		java.lang包有 Integer,String 之类的，无需手动导入

​	题目给了变量条件就可不验证了。**10^9**为十亿没有超过int范围，**但乘积有可能为long，会溢出为负数，用 long 定义**。

​	Scanner：sc.nextLong()。 while(sc.hasNext()){}。接收String类型时，sc.next()碰到空格、回车符会终止扫描， 而 nextLine()只在回车符的时终止录入。

​	要注意输入/输出的时候的类型。

leetCode：

​	类名不能改

## 数学问题

### 公倍数和公因数

性质：**两个自然数的乘积等于这两个自然数的最大公约数和最小公倍数的乘积。**

​		   相邻两数的最大公因数为1，最小公倍数为n*(n-1)

辗转相除法：先用较大的数除以较小的数，如果有余数，则用较小的数除以余数，按照这样的方法一直除下去到余数为0为止，最后的除数就是最大公因数

```java
if(a<b) a=b+a-(b=a);
while(b != 0) {
  int c = a%b;    //不是除
  a = b;
  b = c;
 }
return a;  //不是b
```

短除法：

<img src="/image-20210915214859631.png" alt="image-20210915214859631" style="zoom:67%;" />

### 质数（素数）

性质：每一个数都可以分解成质数的乘积。质数+合数=自然数

质数又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。

#### 204 计数质数

给定一个数字 *n*，求小于 *n* 的质数的个数。

题解：j 遍历到sqrt{n}  即可。因为 n 如果不是素数，那么至少有一个因子是小于等于 sqrt{n} 的（反证法，都大于根号n，则结果大于n)

厄拉多塞筛法（埃氏筛法）。比如求20以内质数的个数，从第一个质数2开始遍历，2是第一个质数,然后把20以内所有2的倍数划去.下一个质数3,然后把3所有的倍数划去.3后面紧跟的数即为下一个质数5,再把5所有的倍数划去.以此类推

不是当前数之前质数的倍数，则当前数是质数

```java
	//超时
    public int countPrimes2(int n) {
        if(n<3) return 0;
        int num=1;
        boolean flag=false;
        for(int i=3;i<n;++i){
            flag=false;
            for(int j=2;j*j<=i;++j){  //小于根号i
                if((i%j)==0) {
                    flag=true;
                    break;
                }               
            }
            if(!flag) num++;
        }
        return num;
    }
    public int countPrimes(int n) {
        if(n<3) return 0;  
        int num=0;
        boolean[] flag=new boolean[n];
        for(int i=2;i<n;++i){
            if(!flag[i]){
                num++;
                for(int j=2*i;j<n;j+=i){
                    flag[j]=true;  //合数
                }
            }
        }
        return num;
    }
```

### 数学运算

#### 29 两数相除

给定两个整数，被除数 `dividend` 和除数 `divisor`。将两数相除，要求不使用乘法、除法和 mod 运算符。结果为32 位有符号整数，溢出返回边界值，除数不为 0

题解：dividend/divisor。可以想到用减法来代替除法。注意点：

① 做减法前要先把两数转化为同符号数，这里要注意-2147483638溢出情况。

最后结果的正负：根据除法的性质，两个数同号则正, 异号则负来判断，这点可以通过最高位异或结果是否是负数：（(dividend >>> 31) ^ (divisor >>> 31)) == 1，也可直接 (dividend^divisor )<0判断

②一次次减是不可行的，可以用位运算，位运算相当于除法，但每次除以2^n。把一个dividend（被除数）先除以2^n，n最初为31，不断减小n去试探,当某个n满足dividend >= divisor*2^n 时，表示我们找到了一个足够大的，离结果最近的2^n，我们就可以用dividend减去2^n个divisor，将得到的结果再继续以上步骤。

③ 最后注意结果溢出情况：-2147483638/-1 时会溢出

```java
 public int divide(int dividend, int divisor) {
        if(dividend==Integer.MIN_VALUE&&divisor==-1) return Integer.MAX_VALUE; 
        int res=0
        boolean flag=(dividend^divisor)<0;  //一正一负
        long a=Math.abs((long)dividend);
        long b=Math.abs((long)divisor);
        for(int i=31;i>=0;--i){
            if(a>=(b<<i)){
                res+=(1<<i);  //2^i
                a-=(b<<i);
            }
        }
        return flag?-res:res;
    }
```

##### 166 分数到小数

给定两个整数，分别表示分数的分子 和分母，以 字符串形式返回小数 。如果小数部分为循环小数，则将循环的部分括在括号内

题解：分数是有理数，有可能是无限循环小数，但不可能是无限不循环小数，无限不循环小数是无理数。分数：被除数/除数。

本题的关键是处理无限循环小数，要先找其循环节：用哈希表记录所有被除数的下标，如果出现了重复的被除数，则证明出现了循环，把左括号塞到记录的下标位置，右括号放在最后

这题不用上题的 a^b<0，a=0,b=-1是输出是 -0，但通不过。因为 "0".equals("-0") 是false，0== -0 是true

```java
public String fractionToDecimal(int numerator, int denominator) {
        long a=numerator,b=denominator;  //防止溢出
        StringBuilder sb=new StringBuilder();
        if(a>0&&b<0||a<0&&b>0) sb.append("-");  //否则 -0.xxx 会被变为 0.xxx
        a=Math.abs(a);
        b=Math.abs(b);
        sb.append(a/b);
        if(a%b==0) return sb.toString();  //能整除
        Map<Long,Integer> map=new HashMap<>();  
        sb.append(".");
        while((a=(a%b)*10)>0&&!map.containsKey(a)){
            map.put(a,sb.length());
            sb.append(a/b);
        }
        if(a==0) return sb.toString();  //有限小数
        return sb.insert(map.get(a).intValue(),"(").append(")").toString(); //循环小数
    }
```

#### 415 字符串相加***

给定两个由数字组成的字符串，求它们相加的结果。

题解：相加运算是从后往前进行的。长度较短的数字前面填 0，以便后续计算

```java
 //long l1=Long.parseLong(num1);相加会溢出
 public String addStrings(String num1, String num2) {
        StringBuilder sb=new StringBuilder();
        int i=num1.length()-1,j=num2.length()-1,z=0; 
        while(i>=0||j>=0){
            int x=i>=0?num1.charAt(i)-'0':0;
            int y=j>=0?num2.charAt(j)-'0':0;
            z=x+y+z;
            sb.append(z%10); //不用+"",
            z=z/10;
            i--;
            j--;
        }
        if(z==1) sb.append("1"); //1
        return sb.reverse().toString();
    }
```

#### 43 字符串相乘**

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积(字符串)，`1 <= num1.length, num2.length <= 200`，不能用内置API 将String 转 int

普通：

<img src="/d24bf3174a878890e1273fbe35426ecdfa932c33efb464ed3602f4d149ed343a" alt="img" style="zoom: 67%;" />

优化： `num1` 位数为 M， `num2` 位数为 N， `num1 x num2` 的结果 最大总位数为 **M+N**，最少M+N-1

<img src="/image-20220425171858348.png" alt="image-20220425171858348" style="zoom: 33%;" />

```java
 public String multiply(String num1, String num2) {
        if(num1.equals("0")||num2.equals("0")) return "0";
        int len1=num1.length(),len2=num2.length(),sum;
        int[] res=new int[len1+len2];
        for(int i=len1-1;i>=0;--i){   //从右向左
            for(int j=len2-1;j>=0;--j){
                sum=res[i+j+1]+(num1.charAt(i)-'0')*(num2.charAt(j)-'0');
                res[i+j+1] = sum%10;  //不用加了，sum已经加了
                res[i+j] +=sum/10;  //要加
            }
        }
        StringBuilder ans=new StringBuilder();
        for(int i=0;i<len1+len2;++i){
            if(i==0&&res[i]==0) continue;
            ans.append(res[i]);
        }
        return ans.toString();
    }
```

#### 50 pow(x,n)**

实现计算 `x` 的 `n` 次幂函数（即，`x^n` ，n为整数，可正可负）

题解：快速幂解析（二进制角度）： 

![image-20220503121644910](/image-20220503121644910.png)

```java
 //一次循环乘一个x，超时
    public double myPow2(double x, int n) {
        if(x==0.0) return 0;
        double res=1.0;
        long b=Math.abs((long)n);
        while(b>0){
            res*=x;
            b--;
        }
        return n>0?res:1/res;
    }
    //每次循环乘x^2
    public double myPow(double x, int n) {
        if(x==0.0) return 0.0;
        double res=1.0;
        long b=Math.abs((long)n);
        while(b>0){
            if((b&1)==1) res*=x;
            x*=x;  //x=x*x
            b>>=1;
        }
        return n>0?res:1/res; 
    }
```

#### 69 x的平方根*

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。由于返回类型是整数，小数部分将被 **舍去**

```java
 //50ms
    public int mySqrt2(int x) {
        if(x==1) return 1;
        for(int i=1;i<=x;++i){
            if(i>x/i) return i-1;
        }
        return 0;
    }
  //二分法，1ms
   public int mySqrt(int x) {
        int l=0,r=x,mid=0;
        if(x==0||x==1) return x;
        while(l<=r){
            mid=(l + r)>>1;
            if(mid<x/mid) l=mid+1;   //除法防止溢出，注意除数为0情况    
            else if(mid>x/mid) r=mid-1;
            else return mid;
        }
        return r;
  }
```

#### 118 杨辉三角

生成「杨辉三角」的前 *`numRows`* 行

<img src="/image-20220606193320236.png" alt="image-20220606193320236" style="zoom:50%;" />

```java
 public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res=new ArrayList<>(rowIndex + 1);
        for(int i=0;i<numRows;++i){
            List<Integer> path=new ArrayList<>();
            for(int j=0;j<=i;++j){
                if(j==0||j==i) path.add(1);
                else path.add(res.get(i-1).get(j-1)+res.get(i-1).get(j));
            }
            res.add(path);
        }
        return res;
    }
```

##### 119 杨辉三角Ⅱ

返回「杨辉三角」的第 `rowIndex` 行

题解：直接根据上题：res.get(rowIndex)，也可以由数学方法：第n行第i个：`C(n,i) = n*(n-1)*...(n-i+1)/i!`

```java
 public List<Integer> getRow(int rowIndex) {
        List<Integer> res = new ArrayList<>(rowIndex + 1);
        long cur = 1;  //防溢出
        res.add(1);
        for (int x = rowIndex, y = 1; y <=rowIndex; --x, ++y) {  //从c(rowIndex,1)开始         
            cur = cur  * x / y;
            res.add((int) cur);
        }
        return res; 
    }
```

### 数字处理

#### 8 字符串转换整数

小于 `−2^31` 的整数应该被固定为 `−2^31` ，大于 `2^31 − 1` 的整数应该被固定为 `2^31 − 1` 

```java
public int myAtoi(String s) {
        long y=0;  //和int最大最小比较
        boolean flag=false;
        int len=s.length(),idx=0;
        while(idx<len&&s.charAt(idx)==' '){ //去前导空格，中间的空格不用
            idx++;
        }
        if(idx==len) return 0;
        char first=s.charAt(idx);
        if(first=='-'){
            flag=true;
            idx++;
        }else if(first=='+') idx++;
        else if(first>'9'||first<'0') return 0;
        while(idx<len){
            char c=s.charAt(idx);
            if(c>'9'||c<'0') return flag?-(int)y:(int)y;
            if(!flag && y*10+c-'0'>Integer.MAX_VALUE) return (int)Integer.MAX_VALUE;
            if(flag&& -(y*10+c-'0')<Integer.MIN_VALUE) return (int)Integer.MIN_VALUE;
            y=y*10+c-'0';
            idx++;
        }
        return flag?-(int)y:(int)y;
    }
```

#### 7 整数反转*

给一个 32 位的有符号整数 x ，返回将 x 中的数字反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 ，就返回 0。

```java
 //2ms
    public int reverse2(int x) {
        long a=x;   //防止取绝对值时溢出
        a=Math.abs(a);
        StringBuilder sb=new StringBuilder(a+"");
        if(x<0) sb.append("-");
        long res=Long.parseLong(sb.reverse().toString()); //防止前面有0，或者溢出
        if(res>Integer.MAX_VALUE||res<Integer.MIN_VALUE) return 0;
        return (int)res;
    }
    //0ms
     public int reverse(int x) {
        int y = 0;
        while (x != 0) {
            if (y > 214748364 || y < -214748364) {
                return 0;
            }
            y = y * 10 + x % 10; //类似计算器取数，java中对负数取模的结果也是负数。-8 % 5 = -3
            x = x / 10;
        }
        return y;
    }
```

#### 504 七进制数

将十进制数转为七进制数

题解: 十六进制（X进制） 9FA8C 转换成十进制：9FA8C = 9×16^4 + 15×16^3 + 10×16^2 + 8×16^1 + 12×16^0 = 653964（十进制）
十进制转为八进制：

<img src="/image-20220228094650812.png" alt="image-20220228094650812" style="zoom: 80%;" />

```java
	//API
        return Integer.toString(num,7);
	//
     public String convertToBase7(int num) {
         if(num==0) return "0";
        StringBuilder sb=new StringBuilder();
        boolean flag=num<0;
        if(flag) num=Math.abs(num);  //负数先转正数
        while(num!=0){
            sb.append(num%7);
            num/=7;
        }
        if(flag) sb.append("-");
        return sb.reverse().toString();
    }
```

##### 进制转换**

接受一个十六进制的数（如：0xAA），输出该数值的十进制表示。且输出结果小于int范围

```java
//Api
int h = Integer.parseInt("123ABC", 16);    // 16进制转10进制
//
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        while(sc.hasNext()){
            String s=sc.nextLine();
            String a=s.substring(2);
            char[] arr=a.toCharArray();
            int len=arr.length;
            int res=0;
            for(int i=0,j=len-1;i<len;++i,--j){
                res+=cnt(arr[j])*Math.pow(16,i);  //不能用16^i算。+= 会强转为左边类型，但res=res+..不强转，会报错
            }
            System.out.println(res+"");
        }
    }
    public static int cnt(char s){   //也可以不写方法，直接Integer.valueOf(ch[i])-55/48
        return "0123456789ABCDEF".indexOf(s);
    }
}
```

##### 168 excel表列名称

给一个整数 ，返回它在 Excel 表中相对应的列名称

输入：n = 28		输出："AB"

题解：和正常 0~25 的 26 进制相比，本质上就是每一位多加了 1。假设 A == 0，B == 1，那么 AB = 26 * 0 + 1 * 1，而现在 AB = 26 * (0 + 1) + 1 * (1 + 1)，所以只要在处理每一位的时候减 1，就可以按照正常的 26 进制来处理

```java
public String convertToTitle(int n) {
       if(n<=0) return "";
       StringBuilder sb=new StringBuilder();
       while(n>0){
           --n;
           sb.append((char)(n%26+'A'));
           n/=26;
       }
       return sb.reverse().toString();
    }
```

#### 172 阶乘后的零

给定一个非负整数，判断它的阶乘结果的结尾有几个 0

题解：每个尾部的 0 由 2 × 5 = 10 而来，所以就可以抛去其他数据 ，专门看2、5 以及其倍数
`如10！ = 【2*4*5*6*8*10】，10！ = 【2*（2*2）*5*（2*3）*（2*2*2）*（2*5）】`，2肯定比5多，只需要判断每个累乘的数有多少个 5 的因子即可

因子规律就是每隔 5 个数，出现一个 5，每隔 25 个数，在之前基础上多个 5，每隔 125 个数，再多个 5... 以此类推。最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...

```java
   //溢出
    public int trailingZeroes2(int n) {
        if(n<2) return 0;
        long res=1; //13阶乘超过int范围，30阶乘超过long
        int ans=0;
        for(int i=1;i<=n;++i){
            res*=i;
        }
        while(res>0){  //找一个数每位
            if(res%10==0) ans++;
            else break;
            res=res/10;
        }
        return ans;
    }
	//方法2
    public int trailingZeroes(int n) {
        int res=0;
        while(n>0){
            res+=n/5;
            n=n/5;
        }
        return res;
   }
```

#### 326 3的幂*

判断一个数字是否是 3 的次方。

题解：在 int 范围内 3 的最大次方是 3 ^19 = 1162261467，如果 *n* 是 3 的整数次方，那么 1162261467 除以 *n* 的余数一定是零

```java
 //16ms,通用法
    public boolean isPowerOfThree2(int n) {
        if(n<1) return false;
        if(n==1) return true;
        boolean flag=false;
        for(int i=0;i<n;++i){
            if(Math.pow(3,i)>n){
                if(Math.pow(3,i-1)==n)flag=true;
                break;
            }
        }
        return flag;
    }
    //9ms
    public boolean isPowerOfThree(int n) {
       return n>0 && Math.pow(3,19)%n==0;
    }

//若是2，4的幂还可以用位运算，2的幂
	 public boolean isPowerOfTwo(int n) { 
     	return (n>0)&& (n&(n-1))==0;
	}
//4的幂，如果 n & (n - 1) 为 0，那么这个数是 2 的次方。如果这个数也是 4 的次方，那二进制表示中 1 的位置必须为奇数位。可以把 n 和二进制的 0101...101（即十进制下的 1431655765）做按位与，如果结果不为 0，那么说明这个数是 4 的次方
  public boolean isPowerOfFour(int n) { 
      System.out.println(Integer.parseInt("01010101010101010101010101010101",2));
      return n>0 && (n&(n-1))==0 && (n&1431655765)!=0;
  }
```

### 随机域取样

#### 384 打乱数组

给定一个数组，要求实现两个指令函数。第一个函数“shufflfflffle”可以随机打乱这个数组，第二个函数“reset”可以恢复原来的顺序。

题解：Fisher-Yates 洗牌算法，有正向和反向两种写法。题目要求每次调用 `shuffle` 时等概率返回某个方案，或者说每个元素都够等概率出现在每个位置中。n个数排列组合的排列方案为 n!。等效的对于下标 x 而言，`我们从 [x,n−1] `中随机出一个位置与 x 进行值交换，当所有位置都进行这样的处理后，我们便得到了一个公平的洗牌方案。

```java
    int[] origin=null;  
    public Solution(int[] nums) {
        origin=nums;
    }  
    public int[] reset() {  //重置回原来的
        return origin;
    } 
    public int[] shuffle() {  //打乱
        int[] res=origin.clone();  //不能直接=origin，传的是地址，改变原来的
        Random r=new Random();
        int len=origin.length;
        for(int i=0;i<len;++i){
            swap(res,i,i+r.nextInt(len-i));
        }
        return res;
    }
    public void swap(int[] res,int i,int j){
        int tem=res[i];
        res[i]=res[j];
        res[j]=tem;
    }
```

#### 528 按权重随机选择

给定一个数组，数组每个位置的值表示该位置的权重，要求按照权重的概率去随机采样

题解：权重前缀和（即到每个位置为止之前所有数字的和）+ 二分

<img src="/image-20220305143320877.png" alt="image-20220305143320877" style="zoom:67%;" />

```java
//         idx: [0, 1, 2, 3]
//           w: [1, 2, 3, 4]
//			概率:[1/10,2/10...]
// index_range: [1, 3, 6, 10]
// 1. 首先我们把权重转换成前缀和的形式index_range
// 2. 我们随机生成[1, 10]中的数字target,不是[0,10]
// 3. 使用二分的方法来查找target在index_range中对应的索引即可
	int[] sum=null;
    int len=0;
    public Solution (int[] w) {
        len=w.length;
        sum=new int[len];
        sum[0]=w[0];
        for(int i=1;i<len;++i){
            sum[i]=sum[i-1]+w[i];
        }
    }  
    public int pickIndex() {
        int tem=(int)(Math.random()*sum[len-1])+1;
        int l=0,r=len-1,mid=0;
        while(l<r){
            mid=(r+l)>>1;
            if(sum[mid]<tem) l=mid+1;
            else r=mid;
        }
        return l;
    }
```

#### 382 链表随机节点

给定一个单向链表，要求设计一个算法，可以随机取得其中的一个数字。

题解1：遍历链表，将链表存到数组中，假设数组的长度为 length，`返回[0,length−1]中`的一个随机数，从数组中取出这个数字。时间复杂度和空间复杂度都为 O(n)

题解2：大数据流中的随机抽样，当内存无法加载全部数据时，如何等概率地从包含未知大小的数据流中随机选取k个数据。可用 蓄水池抽样：遍历一次链表，当遇到第 i 个数时，以 1/i 的概率选择这个节点覆盖掉之前的节点选择。时间复杂度：O(n)，空间复杂度：O(1)

证明：k 成为答案的充要条件为「在遍历到 k 时被选中」并且「遍历大于 k的所有元素时，均没有被选择（没有覆盖 k）」

<img src="/image-20220305164353566.png" alt="image-20220305164353566" style="zoom:80%;" />

```java
	ListNode h=null;
    Random r=new Random();
    public Solution(ListNode head) {
        h=head;
    }   
    public int getRandom() {
        ListNode tem=h;
        int i=1,res=0;
        while(tem!=null){
            if(r.nextInt(i)==0) res=tem.val;  //第i个数时，1/i机率这个数
            tem=tem.next;
            i++;
        }
        return res;
    }
```

### 基本方法/变量

####  小美的评分计算器

评价体系是1-5星，评分的计算是对该商家的所有客户的星级评价做求一个平均，然后去尾法显示小数点后的一位即可，例如平均得分是3.55，则显示的是3.5。

输入：包含5个整数，依次分别表示商家获得1星到5星的评价数量，每一种评价的数量都不大于1000。

输出：仅包含一个保留一位的小数，表示商家在客户端上显示的评级

```java
 public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int[] a=new int[5];
        for(int i=0;i<5;++i){
            a[i]=sc.nextInt();
        }
        double d=(0.0+a[0]+a[1]*2+a[2]*3+a[3]*4+a[4]*5)/(a[0]+a[1]+a[2]+a[3]+a[4]); //int除法会缺失精度，某个要先转double
       // int x=(int)d*10;double res=x/10.0;  //小数点后还是有.10000。要用字符串拼接
        int res1=(int)d;
        int res2=(int)((d-res1)*10);  //要括号，不然就先转int再乘10了
        System.out.println(res1+"."+res2);
    }
```

#### 不一样的逆序数

如果一个数的4倍恰好是它的逆序数，那么称这两个数是新定义下的逆序对。接下来给定一正整数n，问：不超过n的正整数中有多少对新定义下的逆序对？

```java
//第一对逆序对就是2178和8712，从它开始往n遍历，遍历不用到n，只需要到n/4即可
 public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        List<String> list=new ArrayList<>();
        if(n < 8712){  //题中2178是第一个
            System.out.println(0);
        }else{
           for(int i=2178;i<=n/4;++i){
                int rev = reverse(i);
                if(4*i == rev){
                    list.add(i + " " + rev);
                }
            }
            System.out.println(list.size());
            for(String s:list){ 
                System.out.println(s);
            }
        }
    }
    // 对数字num进行逆序
    private static int reverse(int num){  //重要，也可用sb的reverse()
        int res = 0;
        while(num > 0){
            res = res*10 + num%10;     //重要
            num /= 10;
        }
        return res;
    }
}
```

#### 字符串替换

给一个仅由小写字母x和y组成且长度不超过 100000 的字符串，每次可以将字符串中的一个xy替换成字符串yyx，至少要替换多少次才能让字符串中不存在子串xy

```java
 public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String s=sc.next();
        int num=0,res=0;
        for(int i=s.length()-1;i>=0;--i){  //xyxyy ==>xy yyyyx.本质是“x”向后移,‘y’成倍增加
            if(s.charAt(i)=='y') num++;
            if(s.charAt(i)=='x') {
                res=(res+num)%1000000007;
                num=(num*2)%(1000000007);
            }
        }
        System.out.println(res);
    }
```



## 位运算

 位运算符号包括：“∧”按位异或（相等0，不等1）、“&”按位与（都为1才为1）、“|”按位或、“∼”取反、“<<” 算术左移和“>>”算术右移。位运算只能用于数字之间，结果也是数字，不能 false^fasle。

特性：0s 和 1s 分别表示只由 0 或 1构成的二进制数字

```java
x ^ 0s = x 		x & 0s = 0 		x | 0s = x
x ^ 1s = ~x 	x & 1s = x 		x | 1s = 1s
x ^ x = 0 		x & x = x 		x | x = x

a ^ b ^ a = b
//按位操作和 == 一定要加括号
(n&1)==1 			取最后一位，判断是1还是0，判断奇偶。
(n&1) 和 n=n>>1	    取n二进制的每一位。也可 n >>=1，但 >>= 间不能有空格
n&(n-1)				将原来的最右边的1变为0
n=n&(n-1)			二进制中1的数量
n&(-n) 				得到最右边的1，即只留最右边的1，其他都为0，例：11110100，取负：00001100，按位与：00000100
//字符串对应的二进制01数组
ans |= 1<<(s.charAt(i)-'a');
```

#### 89 格雷编码

n位格雷码序列，每个整数都在范围 `[0, 2n - 1]` 内，一个整数在序列中出现 **不超过一次**，每对 **相邻** 整数的二进制表示 **恰好一位不同** ，且**第一个** 和 **最后一个** 整数的二进制表示 **恰好一位不同**

```java
// 0   1
// 0   1
// 00  01   11  10    
//  0   1    3   2     
// 000  001  011  010  110 111  101  100 
//  0    1    3    2    6   7    5    4
//下一个数组的后一半：对称反转+2的n-1次方，即最前面加一
   public List<Integer> grayCode(int n) {
        List<Integer> res=new ArrayList<>();
        res.add(0);
        int a=1;
        for(int i=1;i<=n;++i){
            for(int j=res.size()-1;j>=0;--j){
                res.add(a+res.get(j));
            }
            a<<=1;
        }
        return res;
    }
```

#### 461 汉明距离

给定两个十进制数字，求它们二进制表示的汉明距离（即不同位的个数）

```java
 public int hammingDistance2(int x, int y) {
        int res=0;
        while(x!=0 || y!=0){
            res+=(x&1)==(y&1)?0:1;
            x=x>>1;
            y=y>>1;
        }
        return res;
    }
    //对两个数进行按位异或操作，统计有多少个 1 即可。
    public int hammingDistance(int x, int y) {
        int tem=x^y;
        int res=0;
        while(tem!=0){
            res+= tem&1;
            tem >>=1;
        }
        return res;
    }
```

#### 190 颠倒二进制位

给定一个十进制整数，输出它在二进制下的翻转结果。

```java
public int reverseBits(int n) {
        int res=0;
        for(int i=0;i<32;++i){
            res<<=1;
            res+=n&1;
            n>>=1;            
        }
        return res;
    }
```

#### 136 只出现一次的数

给定一个整数数组，这个数组里只有一个数次出现了一次，其余数字出现了两次，求这个只出现一次的数字。

```java
// x ∧ x = 0 和 x ∧ 0 = x
public int singleNumber(int[] nums) {
    int res=0;
    for(int i:nums){
        res^=i;
    }
    return res;
}
```

#### 338 二进制中1的数量

给定一个非负整数 *n*，求从 0 到 *n* 的所有数字的二进制表达中，分别有多少个 1

```java
  //位运算，1ms
   public int[] countBits(int n) {
        int[] res=new int[n+1];
        for(int i=1;i<=n;++i){
            int a=i,num=0;
            while(a!=0){
                a=a&(a-1);  //最右的1转为0
                num++;
            }
            res[i]=num;
        }
        return  res;
    }
    //api,107ms
    public int[] countBits3(int n) {
        int[] res=new int[n+1];
        for(int i=0;i<n+1;++i){
            res[i]=Integer.toString(i,2).replaceAll("0","").length();
        }
        return res;
    }
    //动态规划，2ms
     public int[] countBits(int n) {
      int[] result = new int[n + 1];
      for(int i = 1; i <= n; i++){
        if ((i & 1) == 0){
          result[i] = result[i >> 1];  //偶数为折半数的1数量
        }else {
          result[i] = result[i - 1] + 1; //奇数为上个偶数+1
        }
      }
      return result;
    }
```

## 排序算法

#### 164 最大间距

给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。

 题解：快速排序、归并排序 都要 O(Nlog N) 的时间复杂度。基数排序复杂度 O(d(n + k))，其中 n 是数组的长度，k 是基数排序使用的进制数，d 是每个元素最多的有效位数。基数排序是线性复杂度算法。

```java
    int len;
    public int maximumGap(int[] nums) {
        len=nums.length;
        if(len<=1) return 0;
        int res=0;
        sort(nums);
        for(int i=0;i<len-1;++i){
            res=Math.max(res,nums[i+1]-nums[i]);
        }
        return res;
    }
    public void sort(int[] nums){
        int max=nums[0],digit=0,idx=0;
        List<Integer>[] arr=new ArrayList[10];  //比二维数组节省内存
        for(int i=0;i<10;++i){
            arr[i]=new ArrayList<>();
        }
        for(int n:nums){    //找最大数
            max=Math.max(n,max);
        }
        for(int n=1;max/n>0;n*=10){ //从个位开始排
            //放入
            for(int i:nums){
                digit=(i/n)%10;
                arr[digit].add(i);
            }
            //取出
            idx=0;
            for(int i=0;i<10;++i){
                if(!arr[i].isEmpty()){
                    for(int j=0;j<arr[i].size();++j){
                        nums[idx++]=arr[i].get(j);
                    }
                    arr[i].clear();
                }
            }
        }
    }
```

#### 215 数组中第k个最大的元素

题解：快速选择一般用于求解 k-th Element 问题，可以在 *O*(*n*) 时间复杂度，*O*(1) 空间复杂度完成求解工作。快速选择的实现和快速排序相似，不过只需要找到第 *k* 大的枢（pivot）即可，不需要对其左右再进行排序

最快的是自己写的堆排序

```java
//冒泡35，选择30
//堆排序1，从小到大排，后面的先排好
    public int findKthLargest(int[] nums, int k) {
        int len=nums.length;
        int tem=0;
        maxheap(nums);
      for(int i=len-1;i>=len-k;--i){
           tem=nums[i];
            nums[i]=nums[0];
            nums[0]=tem;
            adjust(nums,0,i);
      }
       return nums[len-k];
    }
    public void maxheap(int[] num){
        for(int i=(num.length-2)>>1;i>=0;--i){
            adjust(num,i,num.length);
        }
    }
    public void adjust(int[] num,int k,int len){
        int tem=0;
        for(int i=(k<<1)+1;i<len;i=(i<<1)+1){
            if(i+1<len&&num[i]<num[i+1]) i=i+1;
            if(num[i]>num[k]) {
                tem=num[k];
                num[k]=num[i];
                num[i]=tem;
                k=i;
            }else{
                break;
            }
        }
    }
//调Api  Arrays.sort(nums);2
//调Api.pro  5
     public int findKthLargest6(int[] nums, int k) {
        int len=nums.length;
   //相当于大根堆设置个数，或者用小根堆加if (queue.size() > k) queue.poll(); 每次把最小的弹出
        PriorityQueue<Integer> pq=new PriorityQueue<>(k,(a,b)->b-a);
        for(int i=0;i<len;++i){
            pq.add(nums[i]);
        }
        for(int i=0;i<k-1;++i){
            pq.poll();          
        }
        return pq.peek();
    }
//快速11，从小到大排，基准元素先排好
   public int findKthLargest8(int[] nums, int k) {
        int len=nums.length;
        int l = 0, r = len - 1, target = len- k;
        while (l < r) {
            int mid = quickSort(nums, l, r);
            if (mid == target) {
                return nums[mid];
            }
            if (mid < target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            } 
         }
        return nums[l];
    }
    public static int quickSort(int[] arr,int l,int r){
              int i=l;
              int j=r;
    		  int base=arr[l]; //哨兵元素，基准元素
              while (i<j){
              while (i<j&&arr[j]>=base){j--;}  //i写在j的下一行保证最后i停的位置要满足 arr[i]<=arr[left],
              while (i<j&&arr[i]<=base){i++;} //等于肯定要放要不第一次不走
              arr[i]=arr[j]-arr[i]+(arr[j]=arr[i]);
    		 }
              //最后i=j相遇
              arr[l]=arr[i];
              arr[i]=base;
            return i;
    }
```

#### 347 前k个高频元素

给你一个整数数组 `nums` 和一个整数 `k`

```java
  //普通11
    public int[] topKFrequent2(int[] nums, int k) {
        Map<Integer,Integer> map=new HashMap<>(16);    //要快一点
        for(int n:nums){
            map.merge(n,1,Integer::sum);// map.put(n,map.getOrDefault(n,0)+1);//value算个数，merge方法要快
        } 
        List<Map.Entry<Integer,Integer>> list=new ArrayList<>(map.entrySet());
        Collections.sort(list,(a,b)->b.getValue().compareTo(a.getValue()));  //list.sort((a,b)->...));
        int[] arr=new int[k];
        for(int i=0;i<k;++i){
            arr[i]=list.get(i).getKey();
        }
        return arr;
    }
//流15
     public int[] topKFrequent3(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>(16);
        for (int n : nums) {
            map.merge(n,1,Integer::sum);
        }
        return map.entrySet()
                  .stream()
                  .sorted((m1, m2) -> m2.getValue() - m1.getValue())
                  .limit(k)
                  .mapToInt(Map.Entry::getKey)   //直接写map返回的是object类型
                  .toArray();  //.collect(Collectors.toList())
    }
//堆10
     public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>(16);
        for (int n : nums) {
            map.merge(n,1,Integer::sum);
        }
        Queue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>(k,(o1, o2) -> o2.getValue() - o1.getValue());
        for (Map.Entry<Integer, Integer> e : map.entrySet()) {
            queue.offer(e);                   
        }
        int[] arr=new int[k];
        for (int i = 0; i <k; i++) {
            arr[i] = queue.poll().getKey();
        }
        return arr;
}
```

## 二分法

利用二分法的都是大小排好的数据，利用普通的遍历也可做，但二分法时间复杂度更低

二分模板：

```java
public int bSearch(int[] nums, int target) {
    int l = 0,r = nums.length - 1, mid = 0;
    while (l <= r) {    //等于
        mid = (l+r) >> 1;
        if (nums[mid] == target) return mid;
        if (nums[mid] < target) l = mid + 1;
		else r = mid - 1;
    }
    return -1;
}
```

#### 33 搜索旋转排序数组

一个按升序排列的不重复的整数数组，将其绕中间某个数旋转后形成新数组，写一个O(lgn)复杂度的算法找target是否在给定的旋转后的数组中，没有的话返回 -1

题解：一般的遍历复杂度是O(n)，使用二分法才能达到题目要求。

即将数组对半分，一定有一个是全部有序的，另一个是部分有序。先判断哪个部分是有序的（当前中点它的值小于等于右端，那么说明右区间是排好序的；反之左区间是排好序的），再判断target在哪个部分在用二分法，就这样循环.

```java
public int search(int[] nums, int target) {
        int l=0,r=nums.length-1,mid;
        while(l<=r){
            mid=(l+r)>>1;
            if(nums[mid]==target) return mid;
            else if(nums[mid]<nums[r]){   //右端有序
                if(target>nums[mid]&&target<=nums[r]) l=mid+1;
                else r=mid-1;
            }else{
                if(target<nums[mid]&&target>=nums[l]) r=mid-1;  //等于情况
                else l=mid+1;
            }
        }
        return -1;
}
```

##### 81 搜索旋转排序数组Ⅱ

一个按非降序排列的可重复的整数数组，将其绕中间某个数旋转后形成新数组，如：

[0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后变为 [4,5,6,6,7,0,1,2,4,4]

题解：10111 和 11101 这种。中点和左端的数字相同，并不能确定是左区间全部相同，还是右区间完全相同，分不清到底是前面有序还是后面有序，此时 l++ 即可。相当于去掉一个重复的干扰项

```java
public boolean search(int[] nums, int target) {
        int l=0,r=nums.length-1,mid;
        while(l<=r){
            mid=(l+r)>>1;
            if(target==nums[mid]) return true;
            if(nums[mid]==nums[l]) l++;
            else if(nums[mid]>nums[l]){
                if(target>=nums[l]&&target<nums[mid]) r=mid-1;
                else l=mid+1;
            }else{
                if(target<=nums[r]&&target>nums[mid]) l=mid+1;
                else r=mid-1;
            }
        }
        return false;
    }
```

##### 153 旋转排序数组中最小值

数组元素不重复

题解：为什么不用左边界：因为l<r，所以最后一轮肯定是(r,r+1)，那么mid 肯定是取值l，当判断条件是mid与l比时 会出现与自身比 造成出现等于情况，不好判断；第二是会有[1,2,3,4]这种情况，那么左边界不好处理。所以判断条件时mid 与 r比 这样肯定是不同的两个数比。然后每次进入无序的那部分找出最小值

```java
public int findMin(int[] nums) {
        int l=0,r=nums.length-1,mid;
        while(l<r){  //不用等于
            mid=(l+r)>>1;
            if(nums[mid]<nums[r]) r=mid;
            else l=mid+1;
        }
        return nums[l];
    }
```

##### 154 旋转排序数组中最小值Ⅱ

可能会有重复元素

```java
public int findMin(int[] nums) {
        int l=0,r=nums.length-1,mid;
        while(l<r){
            mid=(l+r)>>1;
            if(nums[mid]==nums[r]) r--;
            else if(nums[mid]<nums[r]) r=mid;
            else l=mid+1;
        }
        return nums[l];
    }
```

#### 34 在排序数组中查找元素**

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

```java
public int[] searchRange(int[] nums, int target) {
        int[] res=new int[2];
        res[0]=bSearch(nums,target,true);
        res[1]=bSearch(nums,target,false);
        return res;
    }
    public int bSearch(int[] nums,int target,boolean flag){		//flag为true找左边界 false找右边界
        int l=0,r=nums.length-1,mid,ans=-1; 
        while(l<=r){
            mid=(l+r)>>1;
            if(nums[mid]>target) r=mid-1; 
            else if(nums[mid]<target) l=mid+1;
            else{
                ans=mid;
                if(flag) r=mid-1;
                else l=mid+1;
            }
        }
        return ans;
    }
```

#### 162 寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。找到峰值的索引。数组可能包含多个峰值，返回 **任何一个峰值** 所在位置即可。必须实现时间复杂度为 `O(log n)`

题解：用二分法，nums[i] > nums[i+1]，则在i之前一定存在峰值元素；反之，则在i+1之后一定存在峰值元素

```java
public int findPeakElement(int[] nums) {
        int l=0,r=nums.length-1,mid;
        while(l<r){  //不用等于，结果在跳出循环得出
            mid=(r+l)>>1;
            if(nums[mid]>nums[mid+1])  r=mid;
            else l=mid+1;
        }
        return l;
    }
```

#### 875 爱吃香蕉的珂珂*

每个小时，她将会选择一堆香蕉（数组某个数），从中吃掉 k 根。  返回她可以在 h 小时内吃掉所有香蕉的最小速度 k。`piles.length <= h <= 109`

```java
 public int minEatingSpeed(int[] piles, int H) {
        int maxVal = 1;
        for (int pile : piles) {
            maxVal = Math.max(maxVal, pile);
        }
        int left = 1; // 速度最小
        int right = maxVal; // 速度最大
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (calculateSum(piles, mid) > H)  left = mid + 1;  //耗时太多，速度太慢了
			else  right = mid;
        }
        return left;
    }
    private int calculateSum(int[] piles, int speed) {
        int sum = 0;
        for (int pile : piles) {
            sum += pile % speed == 0 ? pile / speed : pile / speed + 1;// 向上取整
        }
        return sum;
    }
```





## 分治法

分治问题由“分”（divide）和“治”（conquer）两部分组成，通过把原问题分为子问题，再将子问题进行处理合并

利用著名的主定理 （Master theorem）求解分治：

*T*(*n*) = *aT*(*n*/*b*) + *f* (*n*)，a个规模为n/b的子问题，分解和合并的时间复杂度是f(n)

归并排序时间复杂度为 *O*(*n* log *n*)

另外，自上而下的分治可以和 memoization 结合，避免重复遍历相同的子问题。如果方便推

导，也可以换用自下而上的动态规划方法求解。

#### 241 为运算表达式设计优先级

给定一个只包含加、减和乘法的数学表达式，求通过加括号可以得到多少种不同的结果。

![image-20220225155736417](/image-20220225155736417.png)

题解：利用分治思想，我们可以把加括号转化为，对于每个运算符号，先执行处理两侧的数学表达

式，再处理此运算符号。注意边界情况，即字符串内无运算符号，只有数字

<img src="/image-20220225155005597.png" alt="image-20220225155005597" style="zoom:50%;" />

```java
public List<Integer> diffWaysToCompute(String expression) { //有重复的
        List<Integer> list=new ArrayList<>();
        int len=expression.length();
        for(int i=0;i<len;++i){
            char cur=expression.charAt(i);
            if(!Character.isDigit(cur)){
                List<Integer> left=diffWaysToCompute(expression.substring(0,i));
                List<Integer> right=diffWaysToCompute(expression.substring(i+1,len));
                merge(left,right,cur,list);
            }                     
        }
        if(list.isEmpty()) list.add(Integer.parseInt(expression));  //边界情况,只有数字了 
        return list;
    }
    public void merge(List<Integer> left,List<Integer> right,char cur,List<Integer> list){
        for(int i:left){
            for(int j:right){
                if(cur=='+') list.add(i+j);
                if(cur=='*') list.add(i*j);
                if(cur=='-') list.add(i-j);
            }
        }
    }
//从上到下用分治处理 +memoization，不如直接从下到上用动态规划处理
```

#### 逆序对距离之和***

给定一个1到n的排列，求出这个序列中所有逆序对的距离和。下标 i,j 的距离为∣i−j∣，逆序对是指序列中一对下标 i,j 满足i<j且ai​>aj​ 

输入：第一行数字n表示排列长度,接下来一行n个数字表示这个排列,1≤n≤100000
输出：一个数字表示答案

解析：类似归并排序，left与right中的元素都已排序，合并时如果遇到left[i] > right[j]，则不仅仅表明i, j是一个逆序对，i + 1, j也是，i + 2, j也是 ...，

dis += left[i] - right[j] + left[i + 1] - right[j] + ... + left[m] - right[j]。即dis += sum(left[i] ... left[m]) - right[j] * (m - i+1)

```java
public class Main {    
    static long res = 0;  //要用long类型
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        int[] temp=new int[n];
        for(int i = 0; i < n; i++) {
          arr[i] = sc.nextInt();   
        }
        mergeSort(arr, 0, arr.length - 1,temp);
        System.out.println(res);
    }
    public static void mergeSort(int[] arr, int l, int r,int[] temp) {
        if (l = r)  return;  //一个就不再分了
        int m = (r+l)>>1;
        mergeSort(arr, l, m,temp);   
        mergeSort(arr, m + 1, r,temp);
        if(arr[m] > arr[m+1]) {    //可不用
            merge(arr, l, m, r,temp);
        }
    }
    private static void merge(int[] arr, int l, int m, int r,int[] temp) {
        int i = l, j = m + 1, t = 0;
        while (i <= m && j <= r) {
           // temp[t++]=arr[i]<=arr[j]?arr[i++]:arr[j++]; 
            if (arr[i] > arr[j]) {  // 新产生了m-i+1逆序对 ,j到 m 的前面算过了（j往后走说明i>j）               
                int k = i;
                while(k <= m) {
                    res += (arr[k++] - arr[j]);   //1 到 n 的排列，这会导致 逆序对距离之和 = 逆序对元素差的和？
                }
                temp[t++] =arr[j++];
            } else {
                temp[t++] = arr[i++];
            }
        }
        while(i <= m) {
            temp[t++] = arr[i++];
        }
        while(j <= r) {
            temp[t++] = arr[j++];
        }
        //复制到原数组
		t=0;i=l;
        while(i<=r){
           arr[i++] = temp[t++];
        }
    }
}
```





## 贪心

#### 12 整数转罗马数字**

输入: num = 1994
输出: "MCMXCIV"

![image-20220415154110238](/image-20220415154110238.png)

```java
public String intToRoman(int num) {
        //将数字的基本组成元素和特殊的列举出来，像990这种就不用列举
        String[] s={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
        int[] arr={1000,900,500,400,100,90,50,40,10,9,5,4,1}; 
        StringBuilder sb=new StringBuilder(); //比String效率高
        int idx=0;
        while(num>0){
            while(num>=arr[idx]){  //取=
                num-=arr[idx];
                sb.append(s[idx]);
            }
            idx++;
        }
    return sb.toString();
}
```

##### 13 罗马数字转整数

题解：建立一个HashMap来映射符号和值，然后对字符串从左到右遍历，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。用switch case 代替map存键值会比map更快

```java
public int romanToInt(String s) {
        Map<Character,Integer> map=new HashMap<>();
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        int res=0,len=s.length();
        for(int i=0;i<len-1;++i){
            int cur=map.get(s.charAt(i));
            if(cur>=map.get(s.charAt(i+1))){
                res+=cur;
            }
            else res-=cur;
        }
        res+=map.get(s.charAt(len-1));
        return res;
    }
//switch代替map
 public int getValue(char c) {
        switch(c) {
            case 'I': return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
            default: return 0;
        }
    }
```

#### 45 跳跃游戏*

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。

题解：只需要在一次 **跳跃** 完成时，更新下一次 **能跳到最远的距离**。

```java
public int jump(int[] nums) {
        int res=0,len=nums.length,end=0,max=0;
        for(int i=0;i<len-1;++i){
            max=Math.max(max,i+nums[i]);
            if(i==end){
                end=max;
                res++;
            }
        }
        return res;
    }
```

##### 55 跳跃游戏

判断你是否能够到达最后一个下标

```java
 public boolean canJump(int[] nums) {
        int len=nums.length,end=0,max=0;
        for(int i=0;i<len;++i){
            max=Math.max(max,i+nums[i]);
            if(i==end) end=max;
            if(end>=len-1) return true; 
        }
        return false;
    }
```

#### 134 加油站**

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。给定两个整数数组 `gas` 和 `cost` ，如果可以绕一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 是 **唯一** 的。

题解：

1. 先判断总gas要大于等于总cost，总（gas- cost）和找最低点共用一次遍历
2. 再就是找总（gas-cost）的最低点，不管正负
3. 找到最低点后，如果有解，那么解就是最低点的下一个点，因为总（gas-cost）是大于等于0的，所以前面损失的gas从最低点下一个点开始都会拿回来别管后面的趋势是先加后减还是先减后加，最终结果是能填平前面的坑的

gas  = [1,2,3,4,5] cost = [3,4,5,1,2]。从0点出发的到达各个点时 总（gas-cost）图

<img src="/image-20220620001441468.png" alt="image-20220620001441468" style="zoom:50%;" />

```java
 public int canCompleteCircuit(int[] gas, int[] cost) {
        int len=gas.length,sumRes=0,minRes=Integer.MAX_VALUE,minidx=0;
        for(int i=0;i<len;++i){
            sumRes+=gas[i]-cost[i];  //总剩余
            if(sumRes<minRes) {
                minRes=sumRes;
                minidx=i;
            }
        }
        return sumRes>=0?(minidx+1)%len:-1;
    }
```

#### 发工资*

每个月至少发m元工资，现一共有n种不同的面额，对于面额为xi的钞票，有yi张,，并且每一个钞票面额都能整除所有比它大的面额,，且每一张钞票不能找零。

输入：第一行包括两个正整数n,m(1 <= n <= 20, 1 <= m <= 10^9)n,m
接下来的n行, 每行两个正整数xi, yi(1 <= xi <= 10^9, 1 <= yi <= 10^6), 即面额和该面额所拥有的钞票数量   

输出：一个整数，表示最多能支付多少个月工资。

排序+贪心(较小的饼干对应较小的胃口)

```java
		Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(),m = sc.nextInt();
        int[][] arr= new int[n][2];
        for (int i = 0; i < n; i++) {
            arr[i][0] = sc.nextInt();
            arr[i][1] = sc.nextInt();
        }
        Arrays.sort(arr,(a,b)->b[0]-a[0]);  //二维数组排序，重要
        int res = 0;
		int index=-1;  //记录面额小于工资的起始下标
		//先处理面额大于工资
        for (int i = 0; i < n; i++) {
            if (arr[i][0] >= m) {
                res += arr[i][1];
            } else {
                index = i; 
                break;
            }
        }
		//面额小于工资的
        while(index!=-1){   //面额都比工资大则不走
            int v = m;  //剩余工资
            //面额小于剩余工资且数量有，用贪心
            for (int i = index; i < n; i++) {
                while(arr[i][1]>0&&v>=arr[i][0]){  
                    v-=arr[i][0];
                    arr[i][1]--;
                }
            }
            if(v>0){   //每种面额充足可以不用写，不充足就会有这种情况
                //面额大于剩余工资，从最小的开始，找出最小的大于剩余工资的面额
                for (int i = n-1; i >= index ; i--) {
                    if(arr[i][1]>0&&arr[i][0]>=v){  //不是while
                        v-=arr[i][0];
                        arr[i][1]--;
                        break;
                    }
                }
            }
            if(v<=0){
                res++;
            } else {   //v还大于0说明面额不够了，直接退出
                break;
            }
        }
        System.out.println(res); 
```

#### 头条校招

一场考试包含3道题目，难度从小到大分别为a,b,c，且这3道题能满足条件：a<=b<=c；b-a<=10；c-b<=10。出题人一共出了n道题目。现在把这n道题分布到若干场考试中（1场或多场，**每道题都必须使用且只能用一次**），但有一些考试可能没法凑够3道题，请计算出最少还需要再出几道题吗？

排序+贪心

```java
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int[] a = new int[n];
    for (int i = 0; i < n; i++) {
        a[i] = sc.nextInt();
    }
    Arrays.sort(a);
    int t = 1;   //当前考试的题数，充当分隔符
    int cnt = 0;  //缺的题目数
    for (int i = 1; i < n; i++) {  //从1开始，将a[i]放入
        if(t < 3) {
            if(a[i] - a[i-1] <= 10)
                t++;
            else if(t == 1 && a[i] - a[i-1] <= 20) {
                cnt ++;
                t = 3;
            } else {   //放不进这场
                cnt += 3 - t;
                t = 1;   //重置t
            }
        } else
        t = 1;  // 一场考试题已满，重置
    }
    cnt += 3 - t;  //最后一场也要算
    System.out.println(cnt); 
}
```

### 分配问题

#### 135分发糖果

按要求分发：每个孩子至少分配到 1 个糖果。评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。至少需要准备多少颗糖果

Input: [2,1,3,3,3,2]

Output: [2,1,2,1,2,1]
题解：**把所有孩子的糖果数初始化为 1**；先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。

贪心（在每次遍历中，只考虑并更新相邻一侧的大小关系）

```java
public int candy(int[] ratings) {
        int len=ratings.length,res=0;
        int[] dp=new int[len];
        Arrays.fill(dp,1);
        for(int i=1;i<len;++i){
            if(ratings[i]>ratings[i-1]) dp[i]=dp[i-1]+1;
        }
        for(int i=len-2;i>=0;--i){
            if(ratings[i]>ratings[i+1]&&dp[i]<=dp[i+1]) dp[i]=dp[i+1]+1;
            res+=dp[i+1];
        }
        res+=dp[0];
        return res;
    }
```

##### 238 除自身以外数组的乘积

给一个整数数组，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。题目保证 数组 中任意元素的全部**前缀元素和后缀的乘积**都在 **32 位** 整数范围内。不能用除法 ，O(n) 复杂度。2 <= nums.length <= 105

题解：当前位置的结果就是它左部分（前缀元素）的乘积再乘以它右部分的乘积。因此需要进行两次遍历，第一次遍历用于求左部分的乘积，第二次遍历在求右部分的乘积的同时，再将最后的计算结果一起求出来。

 左右都遍历一次  。也包含前缀积 后缀积

```java
public int[] productExceptSelf(int[] nums) {
        int l=1,r=1,len=nums.length;
        int[] res=new int[len];
        for(int i=0;i<len;++i){
            res[i]=l;
            l*=nums[i];
        }
        for(int i=len-2;i>=0;--i){
            r*=nums[i+1];
            res[i]*=r;
        }
        return res;
    }
```

##### 581 最短无序子数组

给你一个整数数组 `nums` ，你需要找出一个 最短**连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序

题解：要求O(n)。从左到右循环，记录最大值为 max，若 nums[i] < max, 则表明位置 i 需要调整，最大位置为 r; 再从右到左循环，记录最小值为 min, 若 nums[i] > min, 则表明位置 i 需要调整，记录最小位置 l

```java
  //非O(n),6ms
    public int findUnsortedSubarray2(int[] nums) {
        int len=nums.length,l=0,r=len-1;
        int[] arr=Arrays.copyOfRange(nums,0,len);
        Arrays.sort(arr);
        while(l<=r&&arr[l]==nums[l]) l++;
        while(l<=r&&arr[r]==nums[r]) r--;
        return r-l+1;
    }
    //O(n)复杂度,1ms
     public int findUnsortedSubarray(int[] nums) {
        int len=nums.length,l=0,r=0,max=Integer.MIN_VALUE,min=Integer.MAX_VALUE;
        for(int i=0;i<len;++i){
            max=Math.max(nums[i],max);
            if(nums[i]<max) r=i;
        }
        for(int i=len-1;i>=0;--i){
            min=Math.min(min,nums[i]);
            if(nums[i]>min) l=i;
        }
        return r==l?0:r-l+1;  //可能本就有序
    }
```

#### 6112 装满杯子最短时间

长度为 3 的整数数组 amount ，表示冷水、温水和热水的杯子数量。每秒钟可以装满 `2` 杯 **不同** 类型的水或者 `1` 杯任意类型的水。返回装满所有杯子所需的 最少 秒数

题解：肯定是最好每次都选两个。分两种情况，一种是有一种水特别多，那么答案就是这种水的数量。否则，一定可以匹配到只剩一杯，或匹配完

输入：amount = [3，4，4]
输出：6

```java
 public int fillCups(int[] a) {
        Arrays.sort(a);
        int sum=a[0]+a[1]+a[2];
        if(a[1]+a[0]>=a[2])sum=(sum+1)/2;
        else sum=a[2];
        return sum;
    }
```

### 区间问题

#### 56 合并区间**

请你合并所有重叠的区间，并返回 一个不重叠的区间数组。区间 [1,4] 和 [4,5] 可被视为重叠区间。

```java
public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(a,b)->a[0]-b[0]); //特殊情况溢出用(a,b)->a[0]<b[0]?-1:1
        int len=intervals.length,l,r;
        List<int[]> list=new ArrayList<>();
        for(int i=0;i<len;){
            l=intervals[i][0];
            r=intervals[i][1];
            while(i<len-1 && intervals[i+1][0]<=r){
                r=Math.max(r,intervals[i+1][1]);
                i++;
            }
            list.add(new int[]{l,r});
            i++;
        }
        return list.toArray(new int[list.size()][2]);
    }
```

##### 57 插入区间**

给你一个 **无重叠的** *，*按照区间起始端点排序的区间列表。在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 [1,2] 和 [2,3]  这种算重叠

```java
public int[][] insert(int[][] intervals, int[] newInterval) {
        int len=intervals.length,i=0;
        List<int[]> res=new ArrayList<>();
        //左边不重合的
        while(i<len && intervals[i][1]<newInterval[0]){
            res.add(intervals[i]);
            i++;
        }
        //重合的,已经是intervals[i][1]>=newInterval[0]
        while(i<len&&intervals[i][0]<=newInterval[1]){
            newInterval[0]=Math.min(intervals[i][0],newInterval[0]);
            newInterval[1]=Math.max(intervals[i][1],newInterval[1]);
            i++;
        }
        res.add(newInterval);
        //右边不重合的
        while(i<len){
            res.add(intervals[i]);
            i++;
        }
        return res.toArray(new int[res.size()][2]);
}
```

##### 435无重叠区间*

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠

很多时候可以逆向思维，找重叠区间不太好找，找不重叠区间好找一点。要多思考总结，举一反三

```java
public int eraseOverlapIntervals(int[][] intervals) {
       if (intervals.length == 0)  return 0;
        Arrays.sort(intervals,(a,b)->a[1]<b[1]?-1:1);  //二维数组不用变成包装类型,只按右端排序
        int res=1,r=intervals[0][1],len=intervals.length; //从1开始,len空间换时间
        for(int i=1;i<len;++i){
            if(intervals[i][0]>=r){ //没有重叠
                res++;                 
                r=intervals[i][1];   //只更新右端即可   
            }            
        }
        return len-res;
    }
```

#### 763划分字母区间***

字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母只出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

"ababcbacadefegdehijhklij" 划分结果为 "ababcbaca", "defegde", "hijhklij"

题解：同一个字母的第一次出现的位置和最后一次出现的位置必须出现在同一个片段，每个片段访问结束的标志是访问到下标end，没到end时若找到更大的end就更新end值，类似跳跃游戏。贪心(寻找每个片段可能的最小结束下标)

```java
class Solution {
     public List<Integer> partitionLabels(String s) {
        char[] ch=s.toCharArray();
        Map<Character,Integer> last=new HashMap<>();  //可以用int[26]数组来写
        int len=s.length();
        for(int i=0;i<len;++i){
            last.put(ch[i],i);
        }
        int st=0,e=0;
        List<Integer> list=new ArrayList<>();
         for(int i=0;i<len;++i){
             e=Math.max(last.get(ch[i]),e);
             if(i==e){
                 list.add(e-st+1);
                 st=e+1;
             }
         }
         return list;
    }
}
```

##### 不重复的最长字串**

给定一个字符串 `s` ，请你找出其中不含有重复字符的 最长子串 的长度 (子序列和字串不一样，子序列是可以不连续下标的)

```java
public int lengthOfLongestSubstring(String s) {
        int l = 0;
        int len = 0;
        HashMap<Character, Integer> map = new HashMap<>();
        for(int r=0;r < s.length();r++) {
            Integer index = map.get(s.charAt(r));
            if (index != null && index >= l) {   //有重复的且在窗口内就从重复的下一位重新算
                l= index+ 1;
            }
            map.put(s.charAt(r), r);   
            len =Math.max(len,r-l+1); 
        }
        return len;
    }
```

##### 318 最大单词长度乘积**

给定多个字母串，求其中任意两个字母串的长度乘积的最大值，且这两个字母串不能含有相同字母

题解：**如何快速判断两个字符串是否含有重复字母**？题目输入只有小写字母，可以为每个字母串建立一个长度为 26 的二进制数组，每个位置表示是否存在该字母（1存在，0不存在）。如果两个字母串含有重复数字，那它们的二进制表示的按位与不为 0。

区别于 242 字母异位词

```java
  //HashSet,1200ms
    public int maxProduct1(String[] words) {
        int res=0,len=words.length;
        if(len<2) return 0;
        for(int i=0;i<len-1;++i){
            for(int j=i+1;j<len;++j){
                if(valid(words[i],words[j]))
                res=Math.max(words[i].length()*words[j].length(),res);
            }
        }
        return res;
    }
    public boolean valid(String s1,String s2){
        Set<Character> set=new HashSet<>();
        for(int i=0;i<s1.length();++i){
            set.add(s1.charAt(i));
        }
        for(int i=0;i<s2.length();++i){
            char c=s2.charAt(i);
            if(set.contains(c)){
                return false;
            }
        }
        return true;
    }
    //模拟hashset，二进制，7ms
     public int maxProduct(String[] words) {
        int res=0,len=words.length;
        if(len<2) return 0;
        int[] nums = new int[len];   //用数组存起来每个字符串转换结果
        for (int i = 0; i < len; i++) {
            nums[i] = convert(words[i]);
        }
        for(int i=0;i<len-1;++i){
            for(int j=i+1;j<len;++j){
                if((nums[i] & nums[j])==0)
                res=Math.max(words[i].length()*words[j].length(),res);
            }
        }
        return res;
    }
    public int convert(String s){
        int ans=0;
        for(int i=0;i<s.length();++i){
            ans |= 1<<(s.charAt(i)-'a');
        }
        return ans;
    }
```

#### 406根据身高建队列**

`people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。输出正确的顺序。

输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

题解：这类题一般要排序来做，这里按h升序，k降序。 从头循环遍历 当前这个人就是剩下未安排的人中最矮的人，他的k值就代表他在剩余空位的索引值

<img src="/image-20220703230526447.png" alt="image-20220703230526447" style="zoom:50%;" />

```java
	public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people,(a,b)->{   //按降序排，保证已插入集合的大于等于当前遍历的 //
            if(a[0]!=b[0])return b[0]-a[0];
            else return a[1]-b[1];
        });
        int len=people.length;
        List<int[]> list=new LinkedList<>();
        for(int i=0;i<len;++i){
            list.add(people[i][1],people[i]);     //
        }
        return list.toArray(new int[list.size()][]); //
    }
```



## 双指针

#### 11 盛水最多的容器

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

题解：贪心+双指针。左右哪个小走哪个，因为小的已经被使用计算过了。

![img](/310548_1593145119537_3B28361A1D556FD072AB3C9435CBF686)

```java
public int maxArea(int[] height) {
        int res=0,l=0,r=height.length-1;
        while(l!=r){
            res=Math.max(area(l,r,height),res);
            if(height[l]>height[r]) r--;    //哪边短就移哪边
            else l++;
        }
        return res;
    }
    public int area(int l,int r,int[] height){
        return height[l]>height[r]?height[r]*(r-l):height[l]*(r-l);
    }
//时间和空间复杂度为：O(N)，O(1)。
只需要额外的几个变量就可以实现相关的操作的时候额外空间复杂度就是O(1).
需要额外的开辟一个与原数组同等规模的数组的话，这个时候的空间复杂度就是O(N)
一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息
```

##### 42 接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

<img src="/rainwatertrap.png" alt="img" style="zoom:80%;" />

题解：和上题一样也是看当前左右谁小，小的那边操作。

从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max对它而言是不可信的

<img src="/image-20220424105942406.png" alt="image-20220424105942406" style="zoom:80%;" />

```java
 public int trap(int[] height) {
        int l=0,r=height.length-1,lMax=0,rMax=0,res=0;
        while(l<=r){
            if(lMax<rMax){  //换成height[l]<height[r]也行，当前位置左右矮的计算存水，存水量取决于左右最大档板的高度
                lMax=Math.max(lMax,height[l]);
                res+=lMax-height[l++];             
            }else{
                rMax=Math.max(rMax,height[r]);
                res+=rMax-height[r--];
            }
        }
        return res;
    }
```

#### 27 移除元素

给你一个数组 `nums` 和一个值 `val`，你需要 原地 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

```java
  public int removeElement(int[] nums, int val) {
        int len=nums.length,idx=0;
        for(int j=0;j<len;++j){      
            if(nums[j]!=val)  nums[idx++]=nums[j];  
        }
        return idx;
    }
```

##### 283 移动0

将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

```java
public void moveZeroes(int[] nums) {
        int len=nums.length,idx=0;
        for(int j=0;j<len;++j){
            if(nums[j]!=0) nums[idx++]=nums[j];
        }
        while(idx<len) nums[idx++]=0;
    }
```

##### 26 删除有序数组中的重复项

给一个 **升序排列** 的数组 `nums` ，请原地删除重复出现的元素，不要使用额外的空间 ，返回删除后数组的新长度

双指针：前指针等两指针元素相同时才走，后指针等不同时更新数组元素

```java
public int removeDuplicates(int[] nums) {
    int len=nums.length,idx=1;
    for(int j=1;j<len;++j){  
        if(nums[j]!=nums[idx-1])  nums[idx++]=nums[j];
    }
    return idx;  //原数组[1,1,2]变为了[1,2,2]
}
```

删除无序数组重复元素且要想返回原顺序用**LinkedHashSet或者list+contains方法，再转为数组。**

##### 80  删除有序数组中的重复项Ⅱ***

给一个 **升序排列** 的数组 `nums` ，请你 原地删除重复出现的元素，使每个元素 最多出现两次

```java
public int removeDuplicates(int[] nums) {
   		int len=nums.length,idx=2;
        if(len<3) return len;
        for(int j=2;j<len;++j){
            if(nums[j]!=nums[idx-2]) nums[idx++]=nums[j];  //不是j-2，nums[j-2]被nums[idx]改了，会变的
        }
        return idx;
}
```

#### 75 颜色分类

给定一个包含红色、白色和蓝色的数组 ，原地对它们进行排序,按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。你能想出一个仅使用常数空间的一趟扫描算法吗。（在原数组上或一个变量）

题解：如果使用快速排序、归并排序，时间复杂度为 O*(*NlogN)。

若只通过一次遍历，把数组分成三个部分，考察的是「快速排序」的子过程 partition。**循环不变量** 简单说就是在循环的过程中保持不变的性质，这个性质是人为根据需要解决的任务定义的

三路快排：本质就是三个指针，头尾指针维持0，2 排好的下一个节点，中间指针用于未排序的遍历，找到未排序的就和头或尾交换

```java
 //三路快排
   public void sortColors2(int[] nums) {
        int p0 = 0,i = 0,p2 = nums.length - 1;
        while(i<=p2){
            if(nums[i]==0){
                swap(nums,i,p0);
                p0++;
                i++;
            }else if(nums[i]==2){
                swap(nums,i,p2);
                p2--;
            }else i++;
        }
    }
    private void swap(int[] nums, int i1, int i2) {
        int tmp = nums[i1];
        nums[i1] = nums[i2];
        nums[i2] = tmp;
    }
    //通用方法，三指针，p2和i其实同步的
     public void sortColors(int[] nums) {
        int p0 = 0, p1 = 0, p2 = 0,len=nums.length;
        for(int i = 0; i < len; i++) {
            if(nums[i] == 0) {
                nums[p2++] = 2;
                nums[p1++] = 1;
                nums[p0++] = 0;
            }else if(nums[i] == 1) {
                nums[p2++] = 2;
                nums[p1++] = 1;
            }else {
                nums[p2++] = 2;
            }
        }
    }
```

##### 丑数

把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

题解：是当前数之前丑数的倍数，则当前数就是丑数，且倍数只能是2，3，5

```java
//丑数也是由丑数得来的，也就是比较(2*x , 3*y, 5*z)最小的数
public static int GetUglyNumber_Solution(int index) {
       if(index<1) { return 0;}
       int[] nums=new int[index];
       int i1=0,i2=0,i3=0,top=1;
       nums[0]=1;
       while(index>top) {    
    	nums[top]=Math.min(nums[i1]*2, Math.min(nums[i2]*3, nums[i3]*5));    //三个数组合并成一个数组
       if(nums[top]==nums[i1]*2) {i1++;}
       if(nums[top]==nums[i2]*3) {i2++;}
       if(nums[top]==nums[i3]*5) {i3++;}
         top++;
         }
       return nums[index-1];
    }
```

#### 15 三数之和**

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

题解：先排序，找三个元素的排列组合：遍历+双指针。两数之和不能排序，返回的是下标

```java
public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res=new ArrayList<>();
        Arrays.sort(nums);    //不是下标，可以排序
        int len=nums.length,sum=0,l=0,r=0;
        for(int i=0;i<len-2;++i){
            if(nums[i]+nums[i+1]+nums[i+2]>0) break;  //优化，当前最小和都大于0，不用再遍历了
            if(nums[i]+nums[len-1]+nums[len-2]<0) continue;  //优化，最大和都小于0，下一个
            if(i>0&&nums[i]==nums[i-1]) continue;  //跳过相同的排列组合
            l=i+1;
            r=len-1;   
            while(l<r){
                sum=nums[i]+nums[l]+nums[r];   
                if(sum<0) l++;
                else if(sum>0) r--;
                else{
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while(l<r&&nums[l]==nums[l+1]) l++;   //跳过相同的排列组合,是while 
                    while(l<r&&nums[r]==nums[r-1]) r--;
                    l++;
                    r--;
                }
            }
        }
        return res;
    }
```

##### 18 四数之和

题解：**比三数之和多一个循环，计算时可以转为long类型防止溢出**

```java
public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res=new ArrayList<>();
        int len=nums.length,l,r;
        long sum;
        Arrays.sort(nums);
        for(int i=0;i<len-3;++i){
            if((long)nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break; //当前最小和都大于0，,用long防止溢出
            if((long)nums[i] + nums[len-1] + nums[len-2] +nums[len-3] < target) continue;
            if(i>0&&nums[i]==nums[i-1])continue;  //跳过重复排列组合
            for(int j=i+1;j<len-2;++j){
                if(j>i+1&&nums[j]==nums[j-1]) continue;  //j>i+1,保证第一个可以组合到
                l=j+1;
                r=len-1;
                while(l<r){
                    sum=(long)nums[i]+nums[j]+nums[l]+nums[r];
                    if(sum<target) l++;
                    else if(sum>target) r--;
                    else{
                        res.add(Arrays.asList(nums[i],nums[j],nums[l],nums[r]));
                        while(l<r&&nums[l]==nums[l+1]) l++;
                        while(l<r&&nums[r]==nums[r-1]) r--;
                        l++;
                        r--;
                    }
                }
            }
        }
        return res;
    }
```

##### 167 两数之和Ⅱ

给一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，找出满足相加之和等于目标数 `target` 的两个数。返回长度为 2 的整数数组 `[index1, index2]` 

```java
    //1ms，比用HashMap方法快
    public int[] twoSum(int[] numbers, int target) {
        int l=0,r=numbers.length-1,sum;
        while(l<r){
            sum=numbers[l]+numbers[r];
            if(sum==target) return new int[]{l+1,r+1};
            else if(sum>target) r--;
            else l++;
        }
        return null;
    }
```

#### 完美的序列***

完美序列满足![image-20210927215947676](/image-20210927215947676.png)，即每个数字都要大于等于前面所有数字的和。现在给定数字序列Ai，找出最长的一段连续子序列，满足它是完美的**（误区：序列中每个数据都要大于等于前面所有数字的和，而不是最后一个满足就行）**

输入：第一行一个整数n表每组数字个数，接下来一行n个整数表示序列。1≤n≤10^5，1≤T≤5，1≤Ai≤10^9

输出：最长完美的连续子序列的长度。有多组输入输出。

**题解：不满足时while中l 走，满足的话 r 走**

```Java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        while(sc.hasNext()){
          int n=sc.nextInt();
          int[] arr=new int[n]; 
          for(int i=0;i<n;++i){
              arr[i]=sc.nextInt();
          }
          int res=0,l=0,len=arr.length; 
          long sum=0;   //最好写成long类型的
          for(int r=0;r<len;++r){
              while(l<r&&arr[r]<sum){
                  sum-=arr[l++];
              }
              sum+=arr[r];
              res = Math.max(res,r-l+1);
          }
           System.out.println(res);
        }          
    }
}
```

#### 最长连续的1**

给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 ，返回仅包含 1 的最长（连续）子数组的长度

```java
   public int GetMaxConsecutiveOnes (int[] arr, int k) {       
		int l=0;  //双指针
        int zeroCnt=0;
        int res = 0;
        for(int r=0;r<arr.length;r++){
            if(arr[r]==0)    zeroCnt++;
            while(zeroCnt>k){
                if(arr[l++]==0) zeroCnt--;  //不管arr[l]是不是0都会执行判断，l会加一
            }
            res = Math.max(res,r-l+1);
        }
        return res;
    }
```





## 优先搜索

### 深度优先搜索(DFS)/递归

深度优先搜索（DFS），用先入后出的栈来实现，也可以通过与栈等价的递归来实现。

也可以用来检测环路：记录每个遍历过的节点的父节点，若一个节点被再次遍历且父节点不同，则说明有环。

#### 695 岛屿的最大面积*

给个二维矩阵 grid 。岛屿 是由一些相邻的 1 构成的组合，「相邻」要求两个 1 必须在 水平或者竖直 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。岛的面积是岛上值为 1 的单元格的数目。计算最大的岛屿面积。如果没有岛屿，则返回面积为 0。

```java
    int row=0,col=0,res=0,cnt=0;    
    public int maxAreaOfIsland(int[][] grid) {
        row=grid.length;
        col=grid[0].length;   
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
               if(grid[i][j]==1) {  //也可以用visited数组
                   cnt=0;  //重置，若是算岛屿的个数直接res++
                   recursion(i,j,grid);
                   res=Math.max(res,cnt);
               }
            }
        }
        return res;
    }
    public void recursion(int i,int j,int[][] grid){
        if(i<row && i>=0 && j<col && j>=0 && grid[i][j]==1){
            grid[i][j]=2;   
            cnt++;
            recursion(i+1,j,grid);
            recursion(i-1,j,grid);
            recursion(i,j+1,grid);
            recursion(i,j-1,grid);
        }
    }
```

##### 463 岛屿周长

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连),格子是边长为 1 的正方形

题解： 由于是行优先遍历，所以只要考虑左边、上边即可

```java
 public int islandPerimeter(int[][] grid) {
        int res = 0;
        for ( int i = 0; i < grid.length; i++ ) {
            for ( int j = 0; j < grid[0].length; j++ ) {           
                if ( grid[i][j] == 1 ) {// 遇到一个岛屿，周长+4
                    res += 4;
                    // 上边是岛屿
                    if ( i > 0 && grid[i-1][j] == 1 )  res -= 2;
                    // 左边是岛屿
                    if ( j > 0 && grid[i][j-1] == 1 )  res -= 2;
                }
            }
        }
        return res;
    }
```

##### 130 被围绕的区域**

矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充

<img src="/image-20220614194811633.png" alt="image-20220614194811633" style="zoom: 50%;" />

题解：边界连通的O比较好找，可以先对边界上的 O 特殊处理，只要把边界上的 O特殊处理了，那么剩下的 O替换成 X 就可以了。

可以从边界出发，对图进行 dfs，可寻找到和边界联通的O，把这种情况下的 O 换成 # ，待搜索结束之后，遇到 O 替换为 X；遇到 #，替换回 O即可。

```java
	int row,col;
    public void solve(char[][] board) {
        row=board.length;col=board[0].length;
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                if((i==0||j==0||i==row-1||j==col-1)&&board[i][j]=='O') dfs(board,i,j);
            }
        }
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                char c=board[i][j];
                if(c=='O') board[i][j]='X';
                if(c=='#') board[i][j]='O';
            } 
        }
    }
    public void dfs(char[][] board,int i,int j){
        if(i>=0&&i<row&&j>=0&&j<col&&board[i][j]=='O'){
            board[i][j]='#';
            dfs(board,i+1,j);
            dfs(board,i-1,j);
            dfs(board,i,j+1);
            dfs(board,i,j-1);
        }
    }
```

#### 547 省份数量**

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。给一个 n x n 的矩阵 ， isConnected`[i][j]` = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected`[i][j]`  = 0 表示二者不直接相连。返回矩阵中 省份 的数量。

 即 **求无向图中的连通域的个数**

```java
//dfs，双层循环,1ms
int len=0,res=0;
public int findCircleNum(int[][] isConnected) {
    len=isConnected.length;
    boolean[] visited=new boolean[len];
    for(int i=0;i<len;++i){
        if(!visited[i]){
            res++;
            dfs(i, isConnected, visited);
        }
    }
    return res;
}
public void dfs(int i,int[][] isConnected,boolean[] visited){         
    for(int j=0;j<len;++j){   //不能写成 j=i+1
        if(isConnected[i][j]==1 && !visited[j]){
            visited[j]=true;  //要在递归前写
            dfs(j, isConnected, visited);              
        } 
    }
}

//bfs,三层循环,2ms
public int findCircleNum2(int[][] isConnected) {
    len=isConnected.length;
    boolean[] visited=new boolean[len];
    Queue<Integer> qe=new LinkedList<>();  //注意
    for(int i=0;i<len;++i){
        if(!visited[i]){
            res++;
            qe.offer(i);
        } 
        while(!qe.isEmpty()){
            int x=qe.poll();
            for(int y=i+1;y<len;++y){   //二维数组取一半就行
                if(!visited[y] && isConnected[x][y]==1){
                    visited[y]=true;
                    qe.offer(y);
                }
            }
        }
    }
    return res;
}

//并查集,1ms
public int findCircleNum3(int[][] isConnected) {
    len=isConnected.length;
    UnionFind uf=new UnionFind(len);
    for(int i=0;i<len;++i){
        for(int j=i+1;j<len;++j){
            if(isConnected[i][j]==1)
                uf.union(i,j);
        }
    }
    return uf.cnt;
}
class UnionFind{
    int cnt;
    int[] roots;
    public UnionFind(int n){
        cnt=n;
        roots=new int[n];
        for(int i=0;i<n;++i){
            roots[i]=i;
        }
    }
    public int find(int q){ 
        if(roots[q]!=q) roots[q]=find(roots[q]);
        return roots[q];
    }
    public void union(int p,int q){
        int qRoot=find(q);   
        int pRoot=find(p);
        if(qRoot==pRoot) return ;  
        roots[pRoot]=qRoot;     //不要写成roots[p],改的是父元素
        cnt--;
    }
```

#### 417  太平洋大西洋水流问题

给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标

虽然题目要求的是满足向下流能到达两个大洋的位置，如果我们对所有的位置进行搜索，那么在不剪枝的情况下复杂度会很高。因此我们可以反过来想，从两个大洋开始向上流，这样我们只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋向上流都能到达的位置。

<img src="/image-20220704170006284.png" alt="image-20220704170006284" style="zoom:50%;" />

```java
 int row=0,col=0;
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        row=heights.length;
        col=heights[0].length;
        //记录坐标地是否到达太平洋、大西洋
        boolean[][] visitedP=new boolean[row][col],visitedQ=new boolean[row][col];
        for(int i=0;i<row;++i){
            dfs(i,0,visitedP,heights);
            dfs(i,col-1,visitedQ,heights);
        }
        for(int j=0;j<col;++j){
            dfs(0,j,visitedP,heights);
            dfs(row-1,j,visitedQ,heights);       
        }
        List<List<Integer>> res=new ArrayList<>(); 
         //遍历记录，如果都可到达即可加入结果
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                if(visitedP[i][j]&&visitedQ[i][j]){
                    res.add(Arrays.asList(i,j));   //
                }
            }
        }
        return res;
    }
    public void dfs(int i,int j,boolean[][] visited,int[][] heights){
        if(visited[i][j]) return ;
        visited[i][j]=true;
        if(i-1>=0&&heights[i-1][j]>=heights[i][j]) dfs(i-1,j,visited,heights);
        if(i+1<row&&heights[i+1][j]>=heights[i][j]) dfs(i+1,j,visited,heights);
        if(j-1>=0&&heights[i][j-1]>=heights[i][j]) dfs(i,j-1,visited,heights);
        if(j+1<col&&heights[i][j+1]>=heights[i][j]) dfs(i,j+1,visited,heights);
    }
```

#### 494 目标和**

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数。运算结果等于 `target` 的不同 **表达式** 的数目。

输入：nums = [1,1,1,1,1], target = 3
输出：5
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3

题解：这题是顺序取出算，只涉及加减法时用此方法的结果和用 39 组合总和的结果一样。若是有乘除法，不可用此法，要用回溯的全排列

```java
 int res=0,len;
    public int findTargetSumWays(int[] nums, int target) {
        len=nums.length;
        dfs(nums,target,0);
        return res;
    }
    public void dfs(int[] nums,int target,int i){
        if(i==len&&target==0){res++;return;}
        if(i==len) return ;
        dfs(nums,target-nums[i],i+1);
        dfs(nums,target+nums[i],i+1);
    }
```

##### 24点游戏

给出4个1-10的数字，通过加减乘除运算，得到数字为24就返回true，否则返回false。每个数字只允许使用一次，会有重复数字

题解：用全排列，但是不用去重了

```java
 public static void main(String[] args) throws IOException {
        Scanner sc=new  Scanner(System.in);
        while(sc.hasNext()){
            int[] num=new int[4];
            boolean[] v=new boolean[4];
            for(int i=0;i<4;i++){
                num[i]=sc.nextInt();
            }
            System.out.println(dfs(num,v,0));
        }
    }
    public static boolean dfs(int[] num,boolean[] v,double res){
        if(res==24) return true;
        for(int i=0;i<num.length;++i){
            if(v[i]) continue;
            v[i]=true;
            if(dfs(num,v,res+num[i])||dfs(num,v,res-num[i])||dfs(num,v,res/num[i])||dfs(num,v,res*num[i])) return true;
            v[i]=false;
        }
        return false; 
    }
//错误方法
public static boolean dfs(int[] num,boolean[] v,double res,int i){
        if(i==num.length&&res==24) return true;
        if(i==num.length) return false;
        if(dfs(num,v,res+num[i],i+1)||dfs(num,v,res-num[i],i+1)||dfs(num,v,res/num[i],i+1)||dfs(num,v,res*num[i],i+1)) return true;
        return false; 
    }
```

#### 数组分组**

输入int型数组，询问该数组能否分成两组，使得两组中各元素加起来的和相等，并且所有5的倍数必须在其中一个组中，所有3的倍数在另一个组中，不是5的倍数也不是3的倍数能放在任意一组，可以将数组分为空数组，能满足以上条件，输出true；不满足时输出false。

```java
public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            int[] arr=new int[n];
             for(int i=0;i<n;++i){
                arr[i]=sc.nextInt();
            }
            int sum3=0,sum5=0;
            List<Integer> list=new ArrayList<>();
            for(int i=0;i<n;++i){
                if(arr[i]%3==0) sum3+=arr[i];
                else if(arr[i]%5==0) sum5+=arr[i];
                else list.add(arr[i]);  // 存不能能整除3或者5
            }
            int target= Math.abs(sum3 - sum5);  
            System.out.println(solu(list,target,0,0));
        }
    }
    public static boolean solu(List<Integer> list,int target,int res,int i){
        if(i==list.size()) return target==res;  //重点, list里的数相加或减的值等于target即可。 sum3+x=sum5+y  ==>  target=x-y
        if(solu(list,target,res+list.get(i),i+1)||solu(list,target,res-list.get(i),i+1)) return true;
        return false;
    }
}
```

####  放苹果

把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？5，1，1和1，5，1 是同一种分法。

数据范围：0<=m<=10,1<=n<=10

```java
 public static void main(String[] args) throws Exception{
        Scanner sc = new Scanner(System.in);
        while(sc.hasNextInt()){
            int m= sc.nextInt(); // 苹果
            int n = sc.nextInt(); //盘子
            // 方法一： 动态规划
            int[][] dp = new int[m + 1][n + 1];
            for(int i = 0; i <= m; ++i){ 
                for(int j = 1; j <= n; ++j){ 
                    if(i == 0 || j == 1){
                        dp[i][j] = 1;
                    }else if(j > i){  
                        dp[i][j] = dp[i][i];
                    }else{
                        dp[i][j] = dp[i][j - 1] + dp[i - j][j];
                    }
                }
            }
            System.out.println(dp[m][n]);
            // 方法二 ：递归
            // System.out.println(count(a, b));
        }
    }
     public static int count(int m, int n){
         if(n == 1 || m == 0 ) return 1;       
         else if(n > m) return count(m, m);  // 盘子过多情况，多余的盘子不起任何作用，最大的有效盘子是 m 个
//两种情况，一种是至少一个盘子为空，一种是每个盘子上都有苹果。 情况一： 只用 n - 1个盘子; 情况二： 每个盘子里先放一个苹果，等价于 m - n个苹果放到 n 个盘子
         else return count(m, n - 1) + count(m - n, n);
     }
```



### 回溯法

**递归的向上返回 和 回溯 要区分开来，回溯是回到之前的状态**。如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态还原

注意：只用一份状态变量去搜索到符合条件的解的时候，通常会做一个拷贝。故递归终止条件的时候，有 `res.add(new ArrayList<>(path))`这样的代码。如果是 res.add(path)，  dfs+回溯 完到根节点后，只会得到几个空列表，因为 Java是值传递，引用类型在传参的过程中，复制的是变量的地址，实际上指向的是同一块内存地址。string 或 StringBuilder,toString() 加入res 的话不用

全局参数作为方法的传参会快一点， 如下：

```java
List<List<Integer>> res=new ArrayList<>();
public void dfs(int n,int k,int begin,List<Integer> path,List<List<Integer>> res){
```

#### 22 括号生成**

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效括号(左右括号必须以正确的顺序闭合) 组合。

输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]

题解：对于这类题，生成用dfs+剪枝，判断可以用栈或者string的contains方法。

<img src="/image-20211014142559601.png" alt="image-20211014142559601" style="zoom: 80%;" />

<img src="/image-20220418145836154.png" alt="image-20220418145836154" style="zoom:80%;" />

```java
    List<String> res=new ArrayList<>();
     //经典回溯，0ms 
     public List<String> generateParenthesis2(int n) {
         StringBuilder sb=new StringBuilder();
         dfs(n,0,0,sb);
         return res;
     }
     public void dfs(int n,int l,int r,StringBuilder sb){
         if(sb.length()==n*2){
             res.add(sb.toString()); //生成了一个新的字符串，相当于做了一次拷贝
             return ;
         }
         if(l<n){
            dfs(n,l+1,r,sb.append("("));
            sb.deleteCharAt(sb.length()-1);  //用的都是sb一个引用变量，要回溯
         } 
         if(r<l){     //不是n，保证括号的有效
            dfs(n,l,r+1,sb.append(")"));
            sb.deleteCharAt(sb.length()-1);
        } 
    }
    //方法2，1ms
    public List<String> generateParenthesis(int n) {
        recur("", 0, 0, n);
        return res;
    }
    public void recur(String cur, int l, int r, int n){
        if (cur.length() == n * 2) {
            res.add(cur);
            return ;
        }
        if (l < n) recur(cur+"(", l+1, r, n); //不用回溯，每次都生成新的String对象
        if (r < l) recur(cur+")", l, r+1, n);
    }
    //错误写法:
    // if (l < n){ l++;  recur(cur+"(", l, r, n);} 等效于 recur(cur+"(", ++l, r, n)  ，本层的l已改变，影响r的递归
    // recur(cur+"(", l++, r, n);
    // if (l < n){ cur+="(";  recur(cur, l+1, r, n);}
```

##### 301 删除无效括号

给一个由若干括号和字母组成的字符串 `s` ，删除最小数量的无效括号，使得输入的字符串有效

```java

```

#### 17 电话号码的字母组合**

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

![img](/200px-telephone-keypad2svg.png)

```java
	List<String> res=new ArrayList<>();
    public List<String> letterCombinations(String digits) {
        Map<Character,String> map=new HashMap<>();        
        List<String> list=new ArrayList<>();
        map.put('2',"abc");
        map.put('3',"def");
        map.put('4',"ghi");
        map.put('5',"jkl");
        map.put('6',"mno");
        map.put('7',"pqrs");
        map.put('8',"tuv");
        map.put('9',"wxyz");
        int len=digits.length();
        if(len==0)return res;
        for(int i=0;i<len;++i){
            list.add(map.get(digits.charAt(i)));
        }
        StringBuilder sb=new StringBuilder();
        dfs(list,sb,0);
        return res;
    }
    public void dfs(List<String> list,StringBuilder sb,int idx){
        if(idx==list.size()) {
            res.add(sb.toString());//不是sb对象，不用new。String也可直接放，String一变就生成新对象
            return;
        }
        for(int i=0;i<list.get(idx).length();++i){
            sb.append(list.get(idx).charAt(i));
            dfs(list,sb,idx+1);
            sb.deleteCharAt(sb.length()-1);  //回溯，用String的话就s.substring(0,idx)
        }
    }
```

##### 46 全排列***

给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案

题解：不一样的顺序算不同组合，且同一位置数字不可重复用，用visited标记

![image-20220123202151577](/image-20220123202151577.png)

```java
    List<List<Integer>> list=new ArrayList<>();
    List<Integer> path=new ArrayList<>();
    boolean[] v;
    int len;
    public List<List<Integer>> permute(int[] nums) {
        len=nums.length;
        v=new boolean[len];
        dfs(nums);
        return list;
    }
    public void dfs(int[] nums){
        if(path.size()==len) {
            list.add(new ArrayList<>(path));
            return;    //没有也行！
        }
        for(int i=0;i<len;++i){
            if(v[i]) continue;
            v[i]=true;
            path.add(nums[i]);
            dfs(nums);
            v[i]=false;
            path.remove(path.size()-1);  //用linkedlist就用path.removeLast();
        }
    }
```

##### 47 全排列Ⅱ**

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列

题解：和上题不同：数组元素可能重复，可能会有相同顺序的同样序列，用排序去重比用set去重快

```java
List<List<Integer>> list=new ArrayList<>();
    List<Integer> path=new ArrayList<>();
    boolean[] v;
    int len;
    public List<List<Integer>> permuteUnique(int[] nums) {
        len=nums.length;
        v=new boolean[len];
        Arrays.sort(nums);
        dfs(nums);
        return list;
    }
    public void dfs(int[] nums){
        if(path.size()==len) {
            list.add(new ArrayList<>(path));
            return;
        }
        for(int i=0;i<len;++i){
            if(v[i] || i>0&&nums[i]==nums[i-1]&&!v[i-1]) continue; //相同的数字且前面的数字没访问过，说明现在的数字要在相同的那个没有访问过的数字前面。这种情况已经发生过了，continue；只去除同一层重复情况，不同层的不用管
            v[i]=true;
            path.add(nums[i]);
            dfs(nums);
            v[i]=false;
            path.remove(path.size()-1);
        }
    }
```

##### 60 排列序列*

给出集合 `[1,2,3,...,n]`，其所有元素共有 `n!` 种排列。按大小顺序列出所有排列情况，给定 `n` 和 `k`，返回第 `k` 个排列。

题解：数学解法，每选出一个数就对列表做删除，因此使用双链表。在Java 中 `LinkedList` 是使用双链表实现的

![image.png](/1599280643-QsCihG-image.png)

```java
//1600ms,递归回溯，在回溯到第k个排列时就可终止
    StringBuilder sb=new StringBuilder();
    List<String> list=new ArrayList<>();
    boolean[] v;
    public String getPermutation2(int n, int k) {
        v=new boolean[n+1];
        dfs(n,k);
        return list.get(k-1);
    }
    public void dfs(int n,int k){
        if(sb.length()==n) {
            if(k==list.size()) return ;
            list.add(sb.toString());     
        }
        for(int i=1;i<=n;++i){
            if(v[i]) continue;
            v[i]=true;
            sb.append(i);
            dfs(n,k);
            v[i]=false;
            sb.deleteCharAt(sb.length()-1);
        }
    }
     //1ms,数学
     public String getPermutation(int n, int k) {
        List<Integer> nums=new LinkedList<>();
        // 先算出所有的阶乘值,计算到n即可，这里为了复用同个for循环
        int[] fac=new int[n+1];
        fac[0]=1;
        for(int i=1;i<=n;++i){
            fac[i]=fac[i-1]*i;
            nums.add(i);
        }
        //相当于在 n 个数字的全排列中找到下标为 k - 1 的那个数，因此 k 先减 1
        k--;
        for(int i=n-1;i>=0;--i){
            int idx=k/fac[i];
            sb.append(nums.remove(idx));
            k-=idx*fac[i];
        }
        return sb.toString();
     }  
```

##### 39 组合总和***

给一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 。数组 中的 同一个 数字可以 无限制重复被选取 。

题解：和上题不同：同样的数字不一样的顺序算同一种组合，且同一位置数字可重复用

```java
    List<List<Integer>> list=new ArrayList<>();
    List<Integer> path=new ArrayList<>();
    int len=0;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        len=candidates.length;
        dfs(candidates,target,0);
        return list;
    }
    public void dfs(int[] candidates,int target,int begin){
        if(target<0) return ;     //可不写，写了更快
        if(target==0) {
            list.add(new ArrayList<>(path));
            return;
        }
        for(int i=begin;i<len;++i){ //避免重复组合,写i=0的话结果是[[2,2,3],[2,3,2],[3,2,2]]，这样避免多写一个visited数组
            path.add(candidates[i]);
            dfs(candidates,target-candidates[i],i);  //每个数不能重复用的话就i+1
            path.remove(path.size()-1);   //不是i
        }
    }
```

##### 40 组合总和 **

给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用 一次 。

题解：和上题不同：数组元素可能重复，且同一位置数字不能重复使用

```java
 List<List<Integer>> list=new ArrayList<>();
    List<Integer> path=new ArrayList<>();
    int len;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        len=candidates.length;
        Arrays.sort(candidates);  //排序。类似三数之和
        dfs(candidates,target,0);
        return list;
    }
    public void dfs(int[] candidates,int target,int begin){
        if(target<0) return;
        if(target==0){list.add(new ArrayList<>(path));return;}
        for(int i=begin;i<len;++i){  //避免重复组合
            if(i>begin&&candidates[i]==candidates[i-1]) continue;//数组有重复元素，避免重复组合,i>0 会把不同层级重复的情况给去掉，i >begin 只会去掉同层级的重复，如：[1,1,2,6] 8  [1,1,6]会被去掉
            path.add(candidates[i]);
            dfs(candidates,target-candidates[i],i+1);
            path.remove(path.size()-1);
        }
    }
```

##### 77 组合*

给定两个整数 n 和 k，返回 1 … n 中所有不重复的 k 个数的组合。（[1,2]，[2,1]算是重复）

回溯+剪枝：

![image-20211023160733236](/image-20211023160733236.png)

```java
  List<List<Integer>> res=new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        List<Integer> path=new ArrayList<>();
        dfs(n,k,1,path);
        return res;
    }
    public void dfs(int n,int k,int begin,List<Integer> path){
        if(k==path.size()){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i=begin;i<=n;++i){
            path.add(i);
            dfs(n,k,i+1,path);
            path.remove(path.size()-1);
        }
    }
```

##### 78 子集*

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集。**不能** 包含重复的子集。（[1,2]，[2,1]算是重复）

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

题解：何时使用回溯：访问过的元素还会出现在下一个解中。或发现不是正确路径的时候(走不通)，要撤销选择，回退到上一个状态，继续尝试。

<img src="/image-20220517194333541.png" alt="image-20220517194333541" style="zoom:50%;" />

```java
 List<List<Integer>> res=new ArrayList<>();
    int len;
    public List<List<Integer>> subsets(int[] nums) {
        len=nums.length;
        List<Integer> path=new ArrayList<>();
        dfs(nums,0,path);
        return res;
    }
    public void dfs(int[] nums,int begin,List<Integer> path){
        res.add(new ArrayList<>(path));
        //if(begin>=len) return;   //可不加
        for(int i=begin;i<len;++i){
            path.add(nums[i]);
            dfs(nums,i+1,path);
            path.remove(path.size()-1);
        }
    }
```

#### 93 复原ip地址

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。给定一个只包含数字的字符串 `s` ，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成

<img src="/image-20220527142915723.png" alt="image-20220527142915723" style="zoom: 80%;" />

```java
List<String> res=new ArrayList<>();
    List<String> path=new ArrayList<>();
    int len;
    public List<String> restoreIpAddresses(String s) {
        len=s.length();
        dfs(s,0,4);   //一共四段
        return res;
    }
    public void dfs(String s,int begin,int remain){
        if(begin==len){
            if(remain==0) res.add(String.join(".",path));
            return ;
        }
        for(int i=begin;i<begin+3&&i<len;++i){ //每段最多选3个
            if(len-i-1>=remain*3) continue;  //剩余长度大于后面分段最大长度就剪枝
            String curS=s.substring(begin,i+1);
            if(isValid(curS)){      //当前段不满足的条件就剪枝
                path.add(curS);
                dfs(s,i+1,remain-1);
                path.remove(path.size()-1);
            }
        }
    }
    public boolean isValid(String curS){
        if(curS.length()>1&&curS.charAt(0)=='0') return false;
        int ans=Integer.parseInt(curS);
        return ans>=0&&ans<=255;
    }
```

#### 79 单词搜索**

给出一个二维字符数组和一个单词，判断单词是否在数组中出现。单词由数组相邻单元格（上下左右相邻）的字母连接而成，同一单元格的字母不能多次使用。

["A","B","C","E"]

["S","F","E","S"]

["A","D","E","E"]			

"ABCESEEEFS"

```java
	int row,col,len;
    public boolean exist(char[][] board, String word) {
        row=board.length;
        col=board[0].length;
        len=word.length();
        boolean[][] v=new boolean[row][col];
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                if(dfs(board,v,word,i,j,0)) return true;  //有一个true就满足返回
                //return dfs(board,v,word,i,j,0); //true会被后面的结果覆盖
            }
        }
        return false;
    }
    public boolean dfs(char[][] board,boolean[][] v,String word,int i,int j,int idx){
        if(idx==len) return true;
        if(i>=0&&i<row&&j>=0&&j<col&&!v[i][j]&&board[i][j]==word.charAt(idx)){
            v[i][j]=true;
            if(dfs(board,v,word,i+1,j,idx+1)||dfs(board,v,word,i-1,j,idx+1)||dfs(board,v,word,i,j+1,idx+1)
            ||dfs(board,v,word,i,j-1,idx+1)) return true;   //有一个true就满足返回
            v[i][j]=false;
        }
        return false;
    }
```

#### 51 N皇后

任何两个皇后都不能在同一行、同一列以及同一条斜线上。返回所有不同的的解决方案

点代表空白位置，Q 代表皇后

![image-20220209141209142](/image-20220209141209142.png)

```java
	List<List<String>> list=new ArrayList<>();
    int len;
    public List<List<String>> solveNQueens(int n) {
        len=n;
        char[][] path=new char[n][n];
        for(char[] ch:path){
            Arrays.fill(ch,'.');
        }
        dfs(0,path);
        return list;
    }
    public void dfs(int row,char[][] path){
        if(row==len){
           list.add(charToList(path));
           return ; 
        } 
        for(int j=0;j<len;++j){
            if(isValid(row,j,path)){
                path[row][j]='Q';
                dfs(row+1,path);   //尝试每一列  
                path[row][j]='.';   //不满足时回溯
            }
        }
    }
    public boolean isValid(int row,int col,char[][] path){
        // 检查列，不用检查行了
        for(int i=0;i<row;++i){
            if(path[i][col]=='Q') return false;
        }
         // 检查左上方
        for(int i=row-1,j=col-1;i>=0&&j>=0;--i,--j){//用&&，不用，不用int i=0,j=0;i<row&&j<col;
            if(path[i][j]=='Q') return false;
        }
        //检查右上方
        for(int i=row-1,j=col+1;i>=0&&j<len;--i,++j){
            if(path[i][j]=='Q') return false;
        }
        return true;
    }
    public List<String> charToList(char[][] path){
        List<String> ans=new ArrayList<>();
        for(char[] ch:path){
            ans.add(new String(ch));
        }
        return ans;
    }
```

#### 37 解数独

数独是每一 `行`，`列`，还有 `3*3` 的方格内数字是 1~9 不能重复。数独部分空格内已填入了数字，空白格用 `'.'` 表示。

题解：回溯：如果填充失败，那么我们需要回溯。将原来尝试填充的地方改回来。

```java
 public void solveSudoku(char[][] board) {
        boolean[][] row=new boolean[9][10];
        boolean[][] col=new boolean[9][10];
        boolean[][] box=new boolean[9][10];
        for(int i=0;i<9;++i){    //将已有的数字先置为true
            for(int j=0;j<9;++j){
                char c=board[i][j];
                int num=c-'0';
                if(c=='.') continue;
                row[i][num]=true;
                col[j][num]=true;
                box[j/3+(i/3)*3][num]=true;
            }
        }
        dfs(board,row,col,box,0,0);
    }
    public boolean dfs(char[][] board,boolean[][] row,boolean[][] col,boolean[][] box,int i,int j){
        if(j==9){
            i++;
            j=0;
            if(i==9) return true;
        }
        if(board[i][j]=='.'){
            for(int n=1;n<=9;++n){  //尝试填1-9
                if(!row[i][n]&&!col[j][n]&&!box[j/3+(i/3)*3][n]){  //可以填入
                    row[i][n]=true;
                    col[j][n]=true;
                    box[j/3+(i/3)*3][n]=true;
                    board[i][j]=(char)(n+'0');  //要先转int加再转char
                    if(dfs(board,row,col,box,i,j+1)) return true; //后面的格子一个是true就将true直接返回
                    row[i][n]=false;
                    col[j][n]=false;
                    box[j/3+(i/3)*3][n]=false;
                    board[i][j]='.';
                }
            }
        }else{  //不能填
            return dfs(board,row,col,box,i,j+1);
        }
        return false;
    }
```

##### 36 有效的数独

判断一个 `9 x 9` 的数独是否有效，数字 `1-9` 在每一行/列/3*3小宫格内只能出现一次。

题解：即遍历数组，分别判断每个数在第 i 个行，第 j 个列，第 **j/3 + (i/3)\*3**个box中是否出现过，判断是否出现过就用hash表，不用每一个都遍历整行/列。和解数独不一样，可在放入时就判断

```java
 public boolean isValidSudoku(char[][] board) {
        boolean[][] row=new boolean[9][10]; //每一行的每个数是否出现过，10是为了让下标和数字一一对应
        boolean[][] col=new boolean[9][10];
        boolean[][] box=new boolean[9][10];
        for(int i=0;i<9;++i){
            for(int j=0;j<9;++j){
                char c=board[i][j];
                if(c=='.') continue;
                int num=c-'0';       
                if(row[i][num]) return false;
                if(col[j][num]) return false;
                if(box[j/3+(i/3)*3][num]) return false;
                row[i][num]=true;
                col[j][num]=true;
                box[j/3+(i/3)*3][num]=true;
            }
        }
        return true;
    }
```

#### 迷宫问题**

其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，找到最短的路径

```java
 static List<String> list=new ArrayList<>(); 
    static List<List<String>> res=new ArrayList<>();
    static int row=0;
    static int col=0;
    public static void main(String[] args) throws Exception {
        Scanner sc=new Scanner(System.in);
        row=sc.nextInt();col=sc.nextInt();
        int[][] arr=new int[row][col];
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                arr[i][j]=sc.nextInt();
            }
        }
        Collections.sort(res,(a,b)->a.size()-b.size());
        dfs(arr,0,0);
        for(String s:res.get(0)){
             System.out.println(s);
        }
    }
    public static void dfs(int[][] arr,int i,int j){
        if(i==row-1&&j==col-1) { 
            list.add("("+i+","+j+")");
            res.add(new ArrayList<>(list));
            list.remove(list.size()-1);
            return ;
        }
        if(i>=0&&i<row&&j<col&&j>=0&&arr[i][j]==0){
            arr[i][j]=2;
            list.add("("+i+","+j+")");
            dfs(arr,i+1,j);
            dfs(arr,i-1,j);
            dfs(arr,i,j+1);
            dfs(arr,i,j-1);
            list.remove(list.size()-1);
            arr[i][j]=0;
        }
    }
```



### 广度优先搜索(BFS)

#### 934 最短的桥***

给定一个二维 0-1 矩阵，其中 1 表示陆地，0 表示海洋，每个位置与上下左右相连。已知矩阵中有且只有两个岛屿，求最少要填海造陆多少个位置才可以将两个岛屿相连。

解析：先找到其中一片岛屿，运用DFS把它标识为2，与另一片岛屿进行区分，也防止重复遍历
在1的标识过程中，收集第一片岛屿附近的海洋（最近一层的海洋0），加入队列queue
BFS搜索队列，逐层往外“填海造陆”，直到遇到第二片岛屿

<img src="/image-20220209173538118.png" alt="image-20220209173538118" style="zoom:67%;" />

```java
    int row=0,col=0;
    Queue<int[]> q=new LinkedList<>();
    public int shortestBridge(int[][] grid) {
        row=grid.length;
        col=grid[0].length;
        boolean flag=false;  //两层循环都跳出
        for(int i=0;i<row;++i){
            if(flag) break;
            for(int j=0;j<col;++j){
                if(grid[i][j]==1){
                    dfs(i,j,grid);
                    flag=true;
                    break;
                }
            }
        }
        int res=0;
        //bfs二维数组时
        int[] x={1,-1,0,0};
        int[] y={0,0,1,-1};
        //bfs模板
        while(!q.isEmpty()){
            res++;  //在for外，填一次加一次
            int len=q.size();  //写在外面
            for(int i=0;i<len;++i){  //需要知道当前遍历的层数，不需要的话就不写
                int[] tem=q.poll();
                int curx=tem[0];
                int cury=tem[1];
                for(int j=0;j<4;++j){  
                    int newx=curx+x[j];
                    int newy=cury+y[j];
                    if(newx>=0&&newx<row&&newy>=0&&newy<col){
                        if(grid[newx][newy]==2) continue;
                        if(grid[newx][newy]==1) return res;
                        q.add(new int[]{newx,newy});
                        grid[newx][newy]=2;
                    }
                }
            }
        }
        return 0;
    }
   //找到第一个岛屿并把旁边的水放入队列
    public void dfs(int i,int j,int[][] grid){
        if(!(i>=0&&i<row&&j>=0&&j<col)) return;   //注意，不写！时，写成||还要<=
        if(grid[i][j]==0) {
            q.offer(new int[]{i,j}); 
            return;
        }
        if(grid[i][j]==1){
            grid[i][j]=2;
            dfs(i+1,j,grid);
            dfs(i-1,j,grid);
            dfs(i,j+1,grid); 
            dfs(i,j-1,grid);  
        }
    }
```

#### 127 单词接龙

给定一个起始字符串和一个终止字符串，以及一个单词表，求是否可以将起始字符串每次改一个字符，直到改成终止字符串，且所有中间的修改过程表示的字符串都可以在单词表里找到。输出  **最短转换序列** 中的 **单词数目**，不存在输出0

题解：为什么用 BFS ？BFS的层数就是路径的长度。相当于权为1的迪杰斯特拉算法。

j进阶：双向BFS：分别从起点和终点执行广度优先遍历，直到遍历的部分有交集。

无向无权图：

![image-20220210105737416](/image-20220210105737416.png)

```java
 public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> set=new HashSet<>(wordList);
        if(!set.contains(endWord)) return 0;
        set.remove(beginWord);
        Queue<String> q=new LinkedList<>();
        Set<String> v=new HashSet<>();
        q.offer(beginWord);
        int step=1;
        while(!q.isEmpty()){
            int len=q.size();
            for(int i=0;i<len;++i){
                String cur=q.poll();
                if(isEndByChange(cur,endWord,q,v,set)) return step+1;
            }
            step++;
        }
        return 0;
    }
    //修改每个字符看是否与 endWord 匹配,不匹配则将下个单词放入queue中
    public boolean isEndByChange(String cur,String endWord,Queue<String> q,Set<String> v,Set<String> set){
        char[] arr=cur.toCharArray();
        for(int i=0;i<endWord.length();++i){
            char orig=cur.charAt(i); // 先保存，保证每次只改一个单词
            for(char k='a';k<='z';++k){
                if(k==orig) continue;   //
                arr[i]=k;
                String next=new String(arr);//
                if(set.contains(next)){
                    if(next.equals(endWord)) return true;
                    if(!v.contains(next)){  //
                        v.add(next);
                        q.offer(next);
                    }
                }
            }
            arr[i]=orig;
        }   
        return false;
    }
```

##### 126 单词接龙II

输出  **最短转换序列**，如果有多组，则都输出，不存在输出空集合。

思路分析：广度优先遍历+深度优先遍历（回溯）





## 动态规划DP

动态规划就是遍历物品，更新dp数组。

**解决动态规划问题要点：**1.dp函数的定义 (长度为len和len+1区别：原数组nums[i]和nums[i-1]的区别；len+1时nums[0]位置的dp符合dp公式)	 2.初始值的确定 	3.状态方程是什么（关键）

动态规划和其它遍历算法（如深/广度优先搜索）都是将原问题拆成多个子问题然后求解，他们最本质的区别是，**动态规划保存子问题的解，避免重复计算。**

**动态规划是自下而上的，即先解决子问题，再解决父问题；而递归是自上而下的，即从父问题搜索到子问题，子问题解决了再返回上去。**如果题目需求的是最终状态，那么使用动态搜索比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便。

![image-20220219174713770](/image-20220219174713770.png)

数组，字符串看长度范围，递归回溯一维数组长度一般小于100，大于100很大可能性用动态规划

### 一维动态规划

1、**斐波那契数列(兔子问题、杨辉三角**)： 0, 1, 1, 2, 3, 5, 8, 13, 21,34...... 从第三项开始，每一项都等于前两项之和。

![img](/www.cdstm.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg)

2、爬楼梯：分析如图，从第三层台阶开始，每一层台阶为前两层台阶走法之和。(理解：终点不一样，走法必定不一样)

<img src="/../../../第一季/images/20210121162632786.png" alt="在这里插入图片描述" style="zoom: 33%;" />

<img src="/image-20211015161014017.png" alt="image-20211015161014017" style="zoom:50%;" />

#### 70 爬楼梯

给定 *n* 节台阶，每次可以走一步或走两步，求一共有多少种方式可以走完这些台阶

```java
 //递归，超时
    public int climbStairs2(int n) {
        if(n<0) return 0;
        if(n==1||n==2) return n;
        return climbStairs(n-1)+climbStairs(n-2);
    }
    //动态规划，0ms
    public int climbStairs3(int n) {
        int[] dp=new int[n+1];       //n+1,可得出dp[n]
        for(int i=1;i<=n;++i){
            if(i==1||i==2) dp[i]=i;
            else dp[i]=dp[i-1]+dp[i-2]; //状态转移方程
        }  
        return dp[n];  //不是n+1  
    }
    //空间压缩。dp[i] 只与 dp[i-1] 和 dp[i-2] 有关，可用两个变量存储 dp[i-1] 和 dp[i-2]，O(n)空间复杂度优化为 O(1) 
    public int climbStairs(int n) {
        int a=1,b=2,c=0;
        if(n==1||n==2) return n;
        for(int i=3;i<=n;++i){
            c=a+b;
            a=b;
            b=c;
        }
        return c;
    }

//一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求跳上一个n级的台阶的跳法  F(n)=F(n-1)+F(n-2)+……+F(1)+1;//F(n)=F(n-1)*2;
```

#### 198 打家劫舍

假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱

[2,1,1,2]   4

题解：关注点是当前房子要不要偷。在当前房子不偷时第 n-1 间不一定被偷了，此时dp[n-1]=dp[n-2]，所以不用管第n-1有没有被偷

<img src="/image-20220213145916901.png" alt="image-20220213145916901" style="zoom:50%;" />

```java
	public int rob2(int[] nums) {
        int len=nums.length;
        int[] dp=new int[len+1];
        dp[1]=nums[0];  //初始化
        for(int i=2;i<=len;++i){
            dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i-1]);  //不偷/偷，注意是nums[i-1]
        }
        return dp[len];
    }
    //空间优化
    public int rob(int[] nums) {
       int len=nums.length,pre=nums[0],prepre=0,cur=0;
        if(len==1) return pre;
        for(int i=2;i<len+1;++i){
            cur=Math.max(pre,prepre+nums[i-1]);
            prepre=pre;
            pre=cur;
        }
        return cur;
    }
```

##### 213 打家劫舍Ⅱ**

所有的房屋都 围成一圈 ，每个房屋存放金额的非负整数数组。能够偷窃到的最高金额。要求时间O(n)，空间O(1)

题解：**环状排列**意味着第一个房子和最后一个房子中**只能选择一个偷窃**。核心原则就是：第一个和最后一个不能同时抢。方案：①不抢第一个，②不抢最后一个，这两种包含了同时都不抢情况。就可以把问题约化为两个**单排排列房间**子问题：一个是从0到n-1，另一个是从1到n

```java
public int rob(int[] nums) {
        int len=nums.length;
        if(len==0) return 0;
        if(len==1) return nums[0];
        return Math.max(helper(Arrays.copyOfRange(nums,0,len-1)),helper(Arrays.copyOfRange(nums,1,len)));
    }
    public int helper(int[] nums){
        int len=nums.length,cur=0,pre,prepre=0;
        if(len==1) return nums[0];
        pre=nums[0];
        for(int i=2;i<len+1;++i){
            cur=Math.max(pre,prepre+nums[i-1]);
            prepre=pre;
            pre=cur;
        }
        return cur;
    }
```

##### 337 打家劫舍Ⅲ

房子是一个树形结构。

题解：使用一个大小为 2 的数组来表示 `int[] res = new int[2]` 0 代表不偷，1 代表偷

```java
	public int rob(TreeNode root) {
        int[] result = robInternal(root);
        return Math.max(result[0], result[1]);
    }
    public int[] robInternal(TreeNode root) {  //递归功能是求抢与不抢当前节点的最大价值
        if (root == null) return new int[2];
        int[] result = new int[2];
        int[] left = robInternal(root.left);
        int[] right = robInternal(root.right);
        result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        result[1] = left[0] + right[0] + root.val;
        return result;
    }
```

##### 740 删除并获得点数

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后必须删除 等于 nums[i] - 1 和 nums[i] + 1 的元素。开始拥有 0 个点数。返回通过这些操作获得的最大点数。

题解：构造一个临时的数组 tem，其 以元素的值来做下标，下标对应的元素是原来的元素的个数。这样就可以变成打家劫舍的问题

举个例子：nums = [2, 2, 3, 3, 3, 4]			构造后：tem=[0, 0, 2, 3, 1];

```java
 public int deleteAndEarn(int[] nums) {
       int len=nums.length,max=0;
       if(len==1) return nums[0];
       for(int i:nums){
           max=Math.max(max,i);
       } 
       int[] tem=new int[max+1];
       for(int i:nums){
           tem[i]++;
       }
       int[] dp=new int[max+1];
       dp[1]=tem[1];
       if(max==1) return dp[1];   //[1,1,1] 越界情况
       dp[2]=Math.max(tem[2]*2,dp[1]);
       for(int i=3;i<max+1;++i){
           dp[i]=Math.max(dp[i-1],dp[i-2]+i*tem[i]);  //不删除和删除情况下最大
       }
       return dp[max];
    }
```

#### 413 等差数列划分

给定一个数组，求这个数组中连续且等差的子数组一共有多少个(**子数组** 是长度大于等于3的连续序列，包含本身)

```java
 public int numberOfArithmeticSlices2(int[] nums) {
        int len=nums.length,res=0;
        if(len<3) return 0;
        int[] dp=new int[len];
        for(int i=2;i<len;i++){
            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){
                dp[i]=dp[i-1]+1;  //状态方程，dp[i] 表示：以 nums[i] 结尾且长度大于等于 3的连续等差数列的个数
                res+=dp[i];
            }
        }
        return res;
    }
```



### 二维动态规划

#### 62 不同路径***

一个人位于一个 m x n 网格的左上角 ，每次只能向下或者向右移动一步，试图达到网格的右下角总共有多少条不同的路径

题解：排列组合：从左上角到右下角的过程中，我们需要移动 m+n-2 次，其中有 m-1 次向下移动，n-1 次向右移动。因此路径的总数，就等于从 m+n-2 次移动中选择 m-1 次向下移动的方案数，即组合数：<img src="/image-20220506181448778.png" alt="image-20220506181448778" style="zoom:80%;" />

`C（5,3）=C（5,2）=5*4/2*1=10`：

<img src="/image-20220506180634235.png" alt="image-20220506180634235" style="zoom:80%;" />

```java
 	//数学
    public int uniquePaths3(int m, int n) {
        long ans = 1;  //会溢出
        for (int x = m+n-2, y = 1; y <=m-1; --x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
 //单纯递归，类似二叉树，超时
 	public int uniquePaths4(int m, int n) {
        return dfs(0, 0, m, n);
    }
   public int dfs(int i, int j, int m, int n) {  
        if (i == m-1 || j == n-1) return 1;//等价if (i == m-1 && j == n-1) return 1; if(i>=m||j>=n) return 0;
        return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);
    }
    //记忆化递归
     public int uniquePaths(int m, int n) {
        int[][] memo = new int[m + 1][n + 1];
        return dfs(m, n, 0, 0, memo);
    }
    public int dfs(int m, int n, int i, int j, int[][] memo) {
        if (i == m-1 || j == n-1) return 1;
        if (memo[i][j] != 0) return memo[i][j];       
        return memo[i][j] = dfs(m, n, i+1, j, memo) + dfs(m, n, i, j+1, memo);
    }
    //经典dp
    public int uniquePaths2(int m, int n) {
        int[][] dp=new int[m][n];
        for(int i=0;i<m;++i){
            for(int j=0;j<n;++j){
                if(i==0||j==0) dp[i][j]=1;
                else dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
```

##### 63 不同路径Ⅱ**

现在考虑网格中有障碍物。网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。输入要求`1 <= m, n <= 100`

<img src="/image-20220508192210413.png" alt="image-20220508192210413" style="zoom: 33%;" />

题解：何时使用【回溯】，何时使用【动态规划】：

1. 首先看取值范围，递归回溯一维数组，100就是深度的极限了（何况本题是二维即：100²）
2. 如果是求走迷宫的【路径】，必然是回溯；如果是走迷宫的【路径的条数】，必然是dp

```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m=obstacleGrid.length,n=obstacleGrid[0].length;
        int[][] dp=new int[m][n];
        for(int i=0;i<m;++i){
            for(int j=0;j<n;++j){
                if(obstacleGrid[i][j]==1) dp[i][j]=0;
                else {
                    if(i==0&&j==0) dp[0][0]=1;
                    else if(i==0) dp[0][j]=dp[0][j-1]; //j>0了
                    else if(j==0) dp[i][0]=dp[i-1][0];
                    else dp[i][j]=dp[i-1][j]+dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
```

##### 64 最小路径和**	

给定一个 *m* × *n* 大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最小的路径。每次只能向右或者向下移动

题解:若是四个方向可走，可用BFS，类似迪杰斯特拉算法

```java
    //递归超时
    //记忆化递归，1ms
	Integer[][] memo; //用int的话，路径和为0时不知道有没更新
    int row,col;
    public int minPathSum2(int[][] grid) {
        row=grid.length;col=grid[0].length;
        memo=new Integer[row][col];
        return dfs(grid,0,0);
    }
    public int dfs(int[][] grid,int i,int j){  
        if(i==row||j==col) return Integer.MAX_VALUE;   
        if(i==row-1&&j==col-1) return grid[i][j];
        if(memo[i][j]!=null) return memo[i][j];
        return memo[i][j]=Math.min(dfs(grid,i+1,j),dfs(grid,i,j+1))+grid[i][j];
    }
	 //dp,2ms
    public int minPathSum3(int[][] grid) {
        int row=grid.length,col=grid[0].length;
        int[][] dp=new int[row][col];
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                if(i==0&&j==0) dp[0][0]=grid[0][0];
                else if(i==0) dp[0][j]= dp[0][j-1]+grid[0][j];
                else if(j==0) dp[i][0]= dp[i-1][0]+grid[i][0];
                else dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        return dp[row-1][col-1];
    }
    //空间压缩，一行一行更新就压缩行，dp[j-1]代表dp[i][j-1],当前dp[j]是待更新的，代表dp[i-1][j]
     public int minPathSum(int[][] grid) {
        int row=grid.length,col=grid[0].length;
        int[] dp=new int[col];
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                if(i==0&&j==0) dp[0]=grid[0][0];
                else if(i==0) dp[j]= dp[j-1]+grid[0][j];
                else if(j==0) dp[0]= dp[0]+grid[i][0];
                else dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j];
            }
        }
        return dp[col-1];
     }
```

##### 120 三角形最小路径和**

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

![image-20220607123204077](/image-20220607123204077.png)



```java
  //记忆化递归,1ms
    Integer[][] memo; //将三角形当作二维数组
    int len;
    public int minimumTotal2(List<List<Integer>> triangle) {
        len=triangle.size();
        memo=new Integer[len][len];
        return dfs(triangle,0,0);
    }
    public int dfs(List<List<Integer>> triangle,int i,int j){
        if(i==len) return 0;
        if(memo[i][j]!=null) return memo[i][j];
        return memo[i][j]=Math.min(dfs(triangle,i+1,j),dfs(triangle,i+1,j+1))+triangle.get(i).get(j);
    }
    //dp，3ms,题目要求等价于求自底向上最小和，故dp为自底向上最小路径和
    public int minimumTotal(List<List<Integer>> triangle) {
        len=triangle.size();
        int[][] dp=new int[len+1][len+1];  //最下一行为0
        for(int i=len-1;i>=0;--i){  //从最后一行开始
            for(int j=0;j<=i;++j){
                dp[i][j]=Math.min(dp[i+1][j],dp[i+1][j+1])+triangle.get(i).get(j);
            }
        }
        return dp[0][0];
    }
```

##### 矩阵中最长路径**

给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。

<img src="/image-20211109193644229.png" alt="image-20211109193644229" style="zoom: 50%;" />

```java
//普通递归超时
//DFS+记忆化，当从一个值出发，求得它的最长递增路径后，在这个递增路径上所有的值，它们的最长递增路径就已经求出来了
class Solution {
    public int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int row, col;
    public int longestIncreasingPath(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)  return 0;
        row= matrix.length;
        col = matrix[0].length;   
        int[][] memo = new int[row][col];
        int ans = 0;
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                ans = Math.max(ans, dfs(matrix, i, j, memo));
            }
        }
        return ans;
    }
    public int dfs(int[][] matrix, int row, int col, int[][] memo){//要用int类型返回之前缓存的
        if (memo[row][col] != 0) return memo[row][col];
        memo[row][col]=1;//初始为1
        for (int[] dir : dirs) {
            int newR = row + dir[0], newCol = col + dir[1];
            if (newR >= 0 && newR < row && newCol >= 0 && newCol < col && matrix[newR][newCol] > matrix[row][col]) {
                memo[row][col] = Math.max(memo[row][col], dfs(matrix, newR, newCol, memo) + 1);
            }
        }
        return memo[row][col];
    }
}
```

#### 542 01矩阵**

给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离。

BFS：距离问题要联想到BFS

<img src="/image-20220215101916115.png" alt="image-20220215101916115" style="zoom:80%;" />

dfs：

![image-20220215094845307](/image-20220215094845307.png)

```java
class Solution {
    int row=0,col=0,dis=0,res=0;
    //dfs+回溯,超时
    public int[][] updateMatrix4(int[][] mat) {
        row=mat.length;
        col=mat[0].length; 
        boolean[][] v=new boolean[row][col]; //没有会栈溢出，转圈    
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                if(mat[i][j]==1){
                    dis=0;
                    res=Integer.MAX_VALUE;               
                    recursion(i,j,mat,v);
                    mat[i][j]=res;
                }
            }
        }
        return mat;
    }
    public void recursion(int i,int j,int[][] mat,boolean[][] v){  //void/int都可以
        if(!(i>=0&&i<row&&j>=0&&j<col) || v[i][j]==true) return;
         //v[i][j]=true;  //不放这里，后面有return，就回溯不了
        if(mat[i][j]==0) {
            res=Math.min(res,dis);
            return;
        }
       /* if(mat[i][j]!=Integer.MAX_VALUE) {  //剪枝
            dis+=mat[i][j];
            res=Math.min(res,dis);
            dis-=mat[i][j];  //全局变量，要回溯
            return;
        }   */
        dis++;
        v[i][j]=true;
        recursion(i+1,j,mat,v);
        recursion(i-1,j,mat,v);
        recursion(i,j+1,mat,v);
        recursion(i,j-1,mat,v);
        dis--;
        v[i][j]=false;
    }
 //dfs+回溯+剪枝（定义一个数组，存储每一个节点已经计算出来的到附近的0的最短距离，下次递归需要用到就直接返回，俗称剪枝）
 //BFS,12ms
  public int[][] updateMatrix2(int[][] mat) {
        row=mat.length;
        col=mat[0].length;
        Queue<int[]> q=new LinkedList<>();
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                if(mat[i][j]==0) q.offer(new int[]{i,j});
                else mat[i][j]=-1;  //在原矩阵改，不是0且没访问的标记
            }
        }
        int[] x={1,-1,0,0};
        int[] y={0,0,1,-1};
        while(!q.isEmpty()){
            int[] tem=q.poll();
            //int len=q.size(); //不计层数，不用这个for循环           
            for(int j=0;j<4;++j){
                int nx=tem[0]+x[j];
                int ny=tem[1]+y[j];
                if(nx>=0&&nx<row&&ny>=0&&ny<col&&mat[nx][ny]==-1){
                    mat[nx][ny]=mat[tem[0]][tem[1]]+1;
                    q.offer(new int[]{nx,ny});
                }
            }          
        }
        return mat;
    }
    //dp,7ms,推荐
     public int[][] updateMatrix3(int[][] mat) {
        row=mat.length;
        col=mat[0].length;
        int[][] dp=new int[row][col];
        //初始化
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                dp[i][j]=(mat[i][j]==0)?0:Integer.MAX_VALUE-1;  //-1防止后面+1溢出
            } 
        }
        //先从左向右，从上往下遍历，得到左方和上方的最小值
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                if(dp[i][j]!=0){
                    if(i-1>=0) dp[i][j]=Math.min(dp[i][j],dp[i-1][j]+1);
                    if(j-1>=0) dp[i][j]=Math.min(dp[i][j],dp[i][j-1]+1);
                }
            } 
        }
        //从右向左，从下往上遍历，得到右方和下方的最小值
        for(int i=row-1;i>=0;--i){
            for(int j=col-1;j>=0;--j){
                if(dp[i][j]!=0){
                    if(i+1<row) dp[i][j]=Math.min(dp[i][j],dp[i+1][j]+1);
                    if(j+1<col) dp[i][j]=Math.min(dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
}
```

#### 221 最大正方形

给定一个二维的 0-1 矩阵，求全由 1 构成的最大正方形面

题解：对于在矩阵内搜索正方形或长方形的题型，一种常见的做法是定义一个二维 dp 数组。`dp[i][j]` 表示满足题目条件的、以 (i, j) 为右下角的正方形或者长方形的属性。对于本题，则表示以 (i, j) 为右下角的全由 1 构成的最大正方形的边长（因为遍历时从左到右从上到下） ，假设`dp[i][j]`=k 。状态转移方程：dp(i, j) = min(dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1)) + 1，如果这三个值中的最小值为 k-1，则 (i, j) 位置一定且最大可以构成一个边长为 *k* 的正方形。

![image-20220217100517592](/image-20220217100517592.png)

```java
public int maximalSquare(char[][] matrix) {
        int row=matrix.length;
        int col=matrix[0].length;
        int[][] dp=new int[row][col];
        int res=0;
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                if(matrix[i][j]=='1'){
                    if(i==0||j==0) dp[i][j]=1; //初始化
                    else dp[i][j]=Math.min(dp[i-1][j],Math.min(dp[i][j-1],dp[i-1][j-1]))+1;
                    res=Math.max(dp[i][j],res);    
                }
            }
        }
        return res*res; //求面积
    }
```

### 背包问题***

背包问题是一种组合优化的 NP 完全问题：有 *N* 个物品和容量为 *W* 的背包，每个物品都有自己的体积 w 和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为 0-1 背包问题；如果不限定每种物品的数量，则问题称为无 界背包问题或完全背包问题。

**01背包**：

` dp[i][j]` 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。

遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，如果我们不将物品 i 放入背包，那么 **`dp[i][j]= dp[i-1][j]`**；如果我们将物品 i 放入背包，假设第 i 件物品体积为 w，价值为 v，那么我们得到 **`dp[i][j] = dp[i-1][j-w] `+ v**。总时间复杂度和空间复杂度都为 *O*(*NW*)

![image-20220218172733460](/image-20220218172733460.png)

```Java
int[][] dp=new int[N+1][W+1];
for (int i = 1; i < N+1; ++i) {    //从一开始，默认N>=1
    int w = weights[i-1], v = values[i-1];
    for (int j = 0; j < w+1; ++j) {  //第一列没初始化要从0开始
        if (j >= w) {
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v);
        } else {
            dp[i][j] = dp[i-1][j];
        } 
    } 
}
return dp[N][W];
```

**空间压缩 (即作为滚动数组)**，将空间复杂度降低为 *O*(*W*)：

假设物品 i = 2，体积为 w = 2，价值为 v = 3；对于背包容量 j，我们可以得到 `dp[2][j]= max(dp[1][j], dp[1][j-2] + 3)`。这里可以发现永远只依赖于上一排 i = 1 的信息，之前算过的其他物品都不需要再使用。因此我们可以去掉 dp 矩阵的第一个维度，在考虑物品 i 时变成 **`dp[j]= max(dp[j], dp[j-w] + v)`**。

这里要注意在遍历每一行的时候必须**逆向遍历**，这样才能够调用上一行物品 i-1 时 dp[j-w] 的值；否则 dp[j-w] 的值在遍历到 j 之前就已经被更新成物品 i 的值了

```java
int[] dp=new int[W+1];
for (int i = 1; i < N+1; ++i) {
	int w = weights[i-1], v = values[i-1];
	for (int j = W; j >= w; --j) {
		dp[j] = max(dp[j], dp[j-w] + v);
	}
}
return dp[W];
```

**完全背包**：

一个物品可以拿多次。假设我们遍历到物品 i = 2，且其体积为 w = 2，价值为 v = 3；对于背包容量 j = 5，最多只能装下 2 个该物品，状态转移方程` dp[2][5] = max(dp[1][5], dp[1][3] + 3, dp[1][1] + 6)`。如果采用这种方法，假设背包容量无穷大而物体的体积无穷小，比较次数也会趋近于无穷大，远超 *O*(*NW*) 。

怎么解决这个问题呢？我们发现在 `dp[2][3] `的时候我们其实已经考虑了 `dp[1][3] 和 dp[2][1]`的情况，而在 `dp[2][1] `也已经考虑了 `dp[1][1] `的情况。如图下半部分所示，只需考虑 `dp[2][3] 即可，即 dp[2][5] = max(dp[1][5], dp[2][3] + 3)`。

故完全背包问题的状态转移方程：**`dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v)`**，与 0-1 背包问题的差别是状态转移方程中的第二个 i-1 变成了 i

![image-20220218183725526](/image-20220218183725526.png)

同样的，也可以利用空间压缩将时间复杂度降低为 *O*(*W*)。**`dp[j] = max(dp[j], dp[j-w] + v)`**

这里要注意我们在遍历每一行的时候必须**正向遍历**，因为我们需要利用当前物品在第 j-w 列的信息

```java
int[] dp=new int[W+1];
for (int i = 1; i < N+1; ++i) {
	int w = weights[i-1], v = values[i-1];
	for (int j = w; j <= W; ++j) {
		dp[j] = max(dp[j], dp[j-w] + v);
	}
}
return dp[W];
```

**个简单的口诀：0-1 背包对物品的迭代放在外层，里层的体积或价值逆向遍历；完全背包对物品的迭代放在里层，外层的体积或价值正向遍历。**

#### 416 分割等和子集

给定一个正整数数组，求是否可以把这个数组分成和相等的两部分

题解：

可以用递归回溯，如：40 组合总和

本题等价于 0-1 背包问题，设所有数字和为 sum，**我们的目标是选取一部分物品，使得它们的总和为 sum/2**。这道题不需要考虑价值，因此我们只需要通过一个布尔值矩阵来表示状态转移矩阵。注意边界条件的处理。

很多时候，状态转移方程思考的角度是「分类讨论」，**对于「0-1 背包问题」而言就是「当前考虑到的数字选与不选」**

`状态转移方程：dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];`

**一般写出状态转移方程以后，就需要考虑初始化条件，初始化的值保证状态转移能够正确完成**：`j-nums[i-1]>=0，dp[i][0] = true`(因为 j=nums[i-1]时为true)

<img src="/image-20220707160622368.png" alt="image-20220707160622368" style="zoom: 67%;" />

```java
 public boolean canPartition(int[] nums) {
        int sum=0,len=nums.length;
        for(int n:nums){
            sum+=n;
        }
        if(len<2||sum%2!=0) return false;
        sum/=2;
        boolean[][] dp=new boolean[len+1][sum+1];
        for(int i=1;i<len+1;++i){
            for(int j=1;j<sum+1;++j){
                dp[i][j]=dp[i-1][j];
                if(j>nums[i-1]){
                    dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i-1]]; //一个数不能重复使用，故要i-1
                }
                if(j==nums[i-1]) dp[i][j]=true;
            }
            if(dp[i][sum]) return true; // 提前结束，可以认为是剪枝操作
        }
        return dp[len][sum];
    }
//空间压缩
    public boolean canPartition(int[] nums) {
        int mid=0;
        for(int n:nums){
            mid+=n;
        }
        int len=nums.length;
        if(len<2||mid%2!=0) return false;
        mid=mid/2;
        boolean[] dp=new boolean[mid+1];
        for(int i=1;i<len+1;++i){
            for(int j=mid;j>0;--j){               
                if(j>nums[i-1]){
                    dp[j]=dp[j]||dp[j-nums[i-1]];
                }else if(j==nums[i-1]) dp[j]=true;
                //else dp[j]=dp[j];
            }
            if (dp[mid]) return true;
        }
        return dp[mid];
    }
```

#### 474 零和一

给定 *m* 个数字 0 和 *n* 个数字 1，以及一些由 0-1 构成的字符串，求利用这些数字最多可以构成多少个给定的字符串，字符串只可以构成一次。

Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3

Output: 4；在这个样例中，我们可以用 5 个 0 和 3 个 1 构成 [“10”, “0001”, “1”, “0”]

题解：这是一个多维费用的 0-1 背包问题。把总共的 0和1 的个数视为背包的容量，每一个字符串视为装进背包的物品

`dp[i][j][k] 表前i个字符串能够使用 j 个 0 和 k 个 1 的字符串的最大数量`

<img src="/image-20220219145708342.png" alt="image-20220219145708342" style="zoom:80%;" />



```java
  public int findMaxForm2(String[] strs, int m, int n) {
        int len=strs.length;
        if(len==0) return 0;
        int[][][] dp=new int[len+1][m+1][n+1];
        for(int i=1;i<len+1;++i){
            int[] cnt=countZeroAndOne(strs[i-1]);  //注意是i-1
            int one=cnt[1];
            int zero=cnt[0];
            for(int j=0;j<m+1;++j){   //有可能为0，从0开始
                for(int k=0;k<n+1;++k){  
                    dp[i][j][k]=dp[i-1][j][k]; // 先把上一行抄下来
                    if(j-zero>=0&&k-one>=0) dp[i][j][k]=Math.max(dp[i-1][j][k],dp[i-1][j-zero][k-one]+1);
                }
            }
        }
        return dp[len][m][n];
    }
    public int[] countZeroAndOne(String s){
        int[] cnt=new int[2];
        for(int i=0;i<s.length();++i){
            cnt[s.charAt(i)-'0']++;
        }
        return cnt;
    }
//空间压缩同样逆序，去除i，将j++变成j--
     public int findMaxForm(String[] strs, int m, int n) {
        int len=strs.length;
        if(len==0) return 0;
        int[][] dp=new int[m+1][n+1];
        for(int i=1;i<len+1;++i){
            int[] cnt=countZeroAndOne(strs[i-1]);  //注意是i-1
            int one=cnt[1];
            int zero=cnt[0];
            for(int j=m;j-zero>=0;--j){   //从0开始
                for(int k=n;k-one>=0;--k){
                    //if(j-zero>=0&&k-one>=0) 
                        dp[j][k]=Math.max(dp[j][k],dp[j-zero][k-one]+1);
                }
            }
        }
        return dp[m][n];
    }
```

#### 322 零钱兑换**

给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额

题解：纯贪心的话，每次都选最大的，但是最终结果可能是凑不齐，故不一定要选最大的。

这道题本质上是完全背包。状态方程：

`j < coin[i-1]: dp[i][j] = dp[i - 1][j]，i是硬币类型，j是金额
j >= coin[i-1]: dp[i][j] = min(dp[i][j - coint] + 1, dp[i - 1][j]), 前提是上一个状态能够凑成硬币，即不为 -1`

dfs：如 组合总和，会有很多重复，要记忆化

![image-20220221103249991](/image-20220221103249991.png)

```java
    //dp，二维
    public int coinChange3(int[] coins, int amount) {
        int len=coins.length;  //题表明len>=1
        if(amount==0) return 0;
        int[][] dp=new int[len+1][amount+1];
        for(int[] d:dp){
             Arrays.fill(d,amount+1); //或者 Integer.MAX_VALUE-1，不加1会溢出
        }   
        dp[0][0]=0;
        for(int i=1;i<len+1;++i){
            for(int j=0;j<amount+1;++j){
                dp[i][j]=dp[i-1][j];
                if(j-coins[i-1]>=0) dp[i][j]=Math.min(dp[i-1][j],dp[i][j-coins[i-1]]+1);
            }
        }
        return dp[len][amount]==amount+1?-1:dp[len][amount];
    }
    //dp,一维数组,11ms
    public int coinChange2(int[] coins, int amount) {
        int len=coins.length;   //题表明len>=1
        int[] dp=new int[amount+1];
        Arrays.fill(dp,amount+1); //或者Integer.MAX_VALUE-1
        dp[0]=0;
        for(int i=1;i<len+1;++i){
            for(int j=1;j<amount+1;++j){     //加一
                if(j-coins[i-1]>=0) dp[j]=Math.min(dp[j],dp[j-coins[i-1]]+1);
            }
        }
        return dp[amount]==amount+1?-1:dp[amount];
    }
    //dfs,34ms,还可以排序后用贪心继续优化
    int[] memo;
     public int coinChange(int[] coins, int amount) {
        int len=coins.length;   //题表明len>=1
        if(amount==0) return 0;
        memo=new int[amount+1];
        return dfs(coins,amount);
    }
    public int dfs(int[] coins, int amount){
        if(amount < 0) return -1;
        if(amount == 0) return 0;
        // 记忆化的处理，memo[n]用赋予了值，就不用继续下面的循环
        if(memo[amount] != 0) return memo[amount];
        int min = Integer.MAX_VALUE;
        for(int i = 0;i < coins.length;i++){
            int res =dfs(coins,amount-coins[i]);
            if(res >= 0 && res < min){
                min = res + 1; // 加1，是为了加上得到res结果的那个步骤中，兑换的一个硬币
            }
        }
        memo[amount] = (min == Integer.MAX_VALUE ? -1 : min);
        return memo[amount];
    }
```

### 分割问题

#### 279 完全平方数***

给定一个正整数，求其最少可以由几个完全平方数相加构成

题解：

对于分割类型题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足分割条件的位置。 

dp[i] 表示数字 i 最少可以由几个完全平方数相加构成，在数i之前一定存在着许多数x使得 x+一个完全平方数等于 i，即**x+k\*k=i(k=1,2,3...)**，即 x=i-k*k(k=1,2,3...)，因此位置 i只依赖 i - k^2 的位置，只要找到所有与i差一个完全平方数的x，然后看这些x的哪个dp[x]最小，把最小的dp[x]+1,就得到了dp[i]，即 dp[i] =1 + min(dp[i-1], dp[i-4], dp[i-9] · · · )。

数学：任何正整数都可以拆分成不超过4个数的平方和 —> 答案只可能是1,2,3,4

```java
//贪心，每次减去根号n，只能通过一半用例，没有平方约束的话可以用贪心找最少
    public int numSquares2(int n) {
        int res=0;
        while(n>0){            
            int tem=(int)Math.sqrt(n);
            n=n-tem*tem;
            res++;
        }
        return res;
    }
    //dp
    public int numSquares(int n) {
        int[] dp=new int[n+1];
        Arrays.fill(dp,Integer.MAX_VALUE); //
        dp[0]=0;      //初始化
        for(int i=1;i<n+1;++i){
            for(int j=1;j*j<=i;++j){
                dp[i]=Math.min(dp[i],dp[i-j*j]+1); //等价于min=Math.min( dp[i-j*j],min );dp[i]=min+1
            }        
        }
        return dp[n];
    }
```

#### 91 解码方法**

已知字母 A-Z 可以表示成数字 1-26。给定一个数字串，求有多少种不同的字符串等价于这个数字串。

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 
```

题解：

可以发现就是约束版的f(n) = f(n-1) + f(n-2)；边界条件：1.  0不能单独解码 	2.  两位数必须在1与26之间。 当前位只考虑自己或自己和前一个的情况，不考虑自己和后一个的情况，因为在遍历到后一个时会考虑到

![image-20220217193116934](/image-20220217193116934.png)

```java
public int numDecodings(String s) {
        int len=s.length();
        if(s.charAt(0)=='0') return 0; //不是s=="0"
        if(len==1) return 1;
        int[] dp=new int[len+1];dp[1]=1;dp[0]=1;  //使dp[2]满足方程
        for(int i=2;i<len+1;++i){
            if(s.charAt(i-1)=='0'){     //只能和前一个一起
                if(s.charAt(i-2)=='0'||s.charAt(i-2)>'2') return 0;
                else dp[i]=dp[i-2];
            }
            else if(s.charAt(i-2)=='0'||s.charAt(i-2)>'2'||s.charAt(i-2)=='2'&&s.charAt(i-1)>'6')  dp[i]=dp[i-1];  //只能自己
            else dp[i]=dp[i-1]+dp[i-2];    //两种都可以
                
            
        }
        return dp[len];
    }
```

#### 139 单词拆分/组合**

给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字符串都可以在集合内找到。

bfs：没有visit时，有很多重复计算，要记忆化

<img src="/image-20220217203723263.png" alt="image-20220217203723263" style="zoom: 80%;" />

dp：类似于完全平方数分割问题，这道题的分割条件由集合内的字符串决定。。注意对于位置 0，需要初始化值为真

<img src="/image-20220217194647043.png" alt="image-20220217194647043" style="zoom:80%;" />

```java
	 //dp，8ms
    public boolean wordBreak2(String s, List<String> wordDict) {
        int len=s.length();
        boolean[] dp=new boolean[len+1];
        dp[0]=true;
        for(int i=1;i<len+1;++i){
            for(int j=1;j<=i;++j){
                if(dp[j-1]&&wordDict.contains(s.substring(j-1,i))){
                    dp[i]=true;
                }
            }
        }
        return dp[len];
    }
 //dfs+记忆化,5ms
    int lens;
    public boolean wordBreak(String s, List<String> wordDict) {
        lens=s.length();
        boolean[] v=new boolean[s.length()];
        return dfs(s,wordDict,v,0);
    }
    public boolean dfs(String s,List<String> wordDict,boolean[] v,int cur){
        if(cur==lens) return true;
        if(!v[cur]){
            v[cur]=true;
            for(int i=cur+1;i<lens+1;++i){
                if(wordDict.contains(s.substring(cur,i))&&dfs(s,wordDict,v,i)) return true;//有一个true就返回true， 先包含再递归效率高
                // if(wordDict.contains(s.substring(cur,i))) return dfs(s,wordDict,v,i); //错误
            }
        }
        return false;
    }  
//bfs,8ms
    public boolean wordBreak3(String s, List<String> wordDict) {
        int len=s.length();
        boolean[] v=new boolean[len];  //不加visit会重复，超时
        Queue<Integer> q=new ArrayDeque<>();
        q.offer(0);
        while(!q.isEmpty()){
            int cur=q.poll();
            if(cur==len) return true;  //不是len-1
            if(v[cur]) continue;
            v[cur]=true;
            for(int i=cur+1;i<len+1;++i){
                if(wordDict.contains(s.substring(cur,i))) {
                    q.offer(i);
                }
            }
        }
        return false;
    }
```

##### 140 单词拆分Ⅱ

返回所有能拆分出的组合。

题解：

和78子集一样

dfs，不用visit数组，虽然cur相同后面会有重复遍历，但之前的组合是不同的，整个组合也就不同

![1.svg](/1651570609-wdiRpj-1.svg)

```java
	List<String> res=new ArrayList<>();
    List<String> path=new ArrayList<>();
    int len;
    public List<String> wordBreak(String s, List<String> wordDict) {
        len=s.length();
        dfs(s,wordDict,0);
        return res;
    }
    public void dfs(String s,List<String> wordDict,int cur){
        if(cur==len){
            res.add(String.join(" ",path));
            return ;
        }
        for(int i=cur;i<len;++i){
            String tem=s.substring(cur,i+1);
            if(wordDict.contains(tem)){
                path.add(tem);
                dfs(s,wordDict,i+1);
                path.remove(path.size()-1);
            }
        } 
    }
```

### 子序列/数组问题

注：按照 LeetCode 的习惯，子序列（subsequence）不必连续，子数组（subarray）或子字符串（substring）必须连续

#### 53 最大子数组和

**子数组** 是数组中的一个连续部分

题解：

状态定义：dp[i]表示以 i 结尾的连续子数组的最大和
状态转移方程：dp[i] = max(array[i], dp[i-1]+array[i])
状态转移方程的意思是：如果选择了当前元素i，而dp[i-1]为负数，表明之前的和做的是负贡献，会使得整体的和变小，因此这时候选择从array[i]重新开始计算和
压缩：每次计算得到其中一个dp[i]时，就更新当前的最大值，而dp[i]只和上一个dp[i-1]有关，仅用一个变量代替dp数组即可

```java
public int maxSubArray(int[] nums) {
        int len=nums.length,max=Integer.MIN_VALUE;
        int[] dp=new int[len+1];
        dp[0]=0;
        for(int i=1;i<len+1;++i){
            // if(dp[i-1]>0) dp[i]=dp[i-1]+nums[i-1];
            // else dp[i]=nums[i-1];
            dp[i]=Math.max(dp[i-1]+nums[i-1],nums[i-1]);
            max=Math.max(max,dp[i]);
          //  dpMax=Math.max(dpMax+nums[i-1],nums[i-1]);
          //  max=Math.max(max,dpMax);
        }
        return max;
    }
```

##### 回转寿司***

选出连续的若干盘寿司，使得这些寿司的美味值之和最大，即求环形数组/链表的连续子数组的最大和

输入：第一行一个整数T（1<=T<=10），表数据组数。每组数据占两行，第一行一个整数N（1<=N<=10^5）；第二行N个整数A[1]到A[N]（-10^4<=A[i]<=10^4）

输出：一个整数，表示连续若干盘寿司的美味值之和的最大值。

```java
/*
(1) 不考虑环形得到的最大值：即连续子数组的最大和
(2) 只考虑环形得到的最大值：数组总和减去连续子数组的最小和就等于首尾相连情况的最大值
因此最大的美味值就是(1)和(2)两种情况中大的那个。
*/
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while(t-- > 0){
            int n = sc.nextInt();
            int[] arr= new int[n];
            int cnt = 0;
            for(int i = 0; i < n; i++){
                arr[i] = sc.nextInt();
                cnt += arr[i];
            }
            // 为了降低时间复杂度，可以两种情况一起求
            int max = arr[0];
            int min = arr[0];
            int dpMax = arr[0];
            int dpMin = arr[0];
            for(int i = 1; i < n; i++){
                dpMax = Math.max(dpMax + arr[i], arr[i]);   //重要...
                max = Math.max(max, dpMax);
                dpMin = Math.min(dpMin + arr[i], arr[i]);
                min = Math.min(min, dpMin);
            }
            System.out.println(Math.max(cnt - min, max));
        }
    }
}
```

##### 最大差值

输入仅包含大写字母’E’,’F’的字符串。输出一个整数，表示（E的个数-F的个数）的最大差值

```java
//把E看成1，F看成-1。遍历数组，遇到E就+1，遇到F就-1，如果所有的E都被F平衡完了，就从0开始重新计算，即从当前位置重新开启一段子数组计算E和F的个数差值。
 public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        String s=sc.next();
        int maxSum = 0, sum = 0，tem=0;
        for(int i = 0; i < n; i++){
            if(s.charAt(i) == 'E') tem=1;
            if(s.charAt(i)  == 'F') tem=-1;           
            sum = Math.max(sum+tem, tem);
            maxSum = Math.max(maxSum, sum);
        }
        System.out.println(maxSum);
    }
```

#### 152 乘积最大子数组**

nums 的任何前缀或后缀的乘积都 **保证** 是一个 **32-位** 整数

题解：由于存在负数，会导致最大的变最小的，最小的变最大的。因此还要维护当前最小值。当负数时则max与min进行交换

```java
public int maxProduct(int[] nums) {
        int max=Integer.MIN_VALUE,dpMax=1,dpMin=1,len=nums.length;
        for(int i=0;i<len;++i){
            if(nums[i]<0){
                int tem=dpMin;
                dpMin=dpMax;
                dpMax=tem;
            }
            dpMax=Math.max(dpMax*nums[i],nums[i]);  //先交换后动态规划
            dpMin=Math.min(dpMin*nums[i],nums[i]);
            max=Math.max(max,dpMax);
        }
        return max;
    }
```

#### 300 最长递增子序列*

给定一个未排序的整数数组，求最长的递增子序列。

题解：若是求最长连续序列用哈希表

<img src="/image-20211013205132114.png" alt="image-20211013205132114" style="zoom:33%;" />

```java
public int lengthOfLIS(int[] nums) {
        int len=nums.length,res=1;
        int[] dp=new int[len+1]; //这题也可用len，主要取决于适合dp方程更简便计算
        Arrays.fill(dp,1);
        dp[0]=0;
        for(int i=1;i<=len;++i){
            for(int j=1;j<i;++j){
                if(nums[i-1]>nums[j-1])  dp[i]=Math.max(dp[i],dp[j]+1);// 等价于max=Math.max(dp[j],max);dp[i]=max+1
            }
            res=Math.max(res,dp[i]);
        }
        return res;
}
```

##### 合唱队

合唱队形是指这样的一种队形：设K位同学从左到右依次编号为 1，2…，K ，他们的身高分别为 T1，T2，…，TK ，  则他们的身高满足存在 i （1<=i<=K） 使得 T1<T2<......<Ti-1<Ti>Ti+1>......>TK 。已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

​				   身高：186 186 150 200 160 130 197 200 		

最长递增子序列：1  	 1 	1 	 2 	 2 	1 	3 	4		递减（从右到左递增区别于从左往右递减）：3 	3 	2 	3 	2	 1	 1 	1		两者相加=每个数成为合唱队的最大数后队列人数+1

```java
 public static void main(String[] args) throws Exception{
        Scanner sc = new Scanner(System.in);
        while(sc.hasNextInt()){
            int n = sc.nextInt();
            int[] arr=new int[n];
            for(int i=0;i<n;++i){
                arr[i]=sc.nextInt();
            }
            int[] dp1=new int[n];
            int[] dp2=new int[n];
            Arrays.fill(dp1, 1);Arrays.fill(dp2, 1);
            for(int i=0;i<n;++i){
                for(int j=0;j<i;++j){
                    if(arr[i]>arr[j]){
                        dp1[i]=Math.max(dp1[i],dp1[j]+1);
                    }
                 }
            }
            for(int i=n-1;i>=0;--i){
                for(int j=n-1;j>i;--j){
                    if(arr[i]>arr[j]){
                        dp2[i]=Math.max(dp2[i],dp2[j]+1);
                    }
                 }
            }
            int max=0;
            for(int i=0;i<n;++i){
                max=Math.max(max,dp1[i]+dp2[i]-1);
            }
            System.out.println(n-max);
        }
    }
```

#### 376 摆动序列

如： `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的

。返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 

<img src="/image-20220727142312184.png" alt="image-20220727142312184" style="zoom:67%;" />

```java
public int wiggleMaxLength(int[] nums) {
    int down = 1, up = 1;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i - 1])
            up = down + 1;
        else if (nums[i] < nums[i - 1])
            down = up + 1;
    }
    return nums.length == 0 ? 0 : Math.max(down, up);
}
```

#### 1143 最长公共子序列*

给定两个字符串，求它们最长的公共子序列长度

<img src="/image-20211013194803943.png" alt="image-20211013194803943" style="zoom:50%;" />

```java
 public int longestCommonSubsequence(String text1, String text2) {
        int row=text1.length();
        int col=text2.length();
        int[][] dp=new int[row+1][col+1];
        for(int i=1;i<row+1;++i){
            for(int j=1;j<col+1;++j){
                if(text1.charAt(i-1)==text2.charAt(j-1)) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[row][col];
    }
```

##### 115 不同的子序列**

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

<img src="/image-20211109214105886.png" alt="image-20211109214105886" style="zoom:50%;" />

```java
public int numDistinct(String s, String t) {
        int slen=s.length(),tlen=t.length();
        int[][] dp=new int[tlen+1][slen+1]; //可以反过来，dp要变
        for(int i=0;i<tlen+1;++i){    //加一啊
            for(int j=0;j<slen+1;++j){
                if(i==0) {dp[0][j]=1; continue;}
                if(j==0) continue;
                if(s.charAt(j-1)==t.charAt(i-1)) dp[i][j]=dp[i-1][j-1]+dp[i][j-1];
                else dp[i][j]=dp[i][j-1];
            }
        }
        return dp[tlen][slen];
}
```

### 字符串编辑

#### 72 编辑距离**

给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可以将两个字符串变成相同。

题解：`当第 i 位和第 j 位对应的字符相同时，dp[i][j]==dp[i-1][j-1]；当二者对应的字符不同时，修改的消耗是 dp[i-1][j-1]+1，删除 j 位置的消耗是 dp[i][j-1] + 1，删除 i 位置的消耗是 dp[i-1][j] + 1`

<img src="/image-20220513182739518.png" alt="image-20220513182739518" style="zoom: 67%;" />

```java
public int minDistance(String word1, String word2) {
        int len1=word1.length(),len2=word2.length();
        int[][] dp=new int[len1+1][len2+1];
        for(int i=0;i<=len1;++i){        //在同一个循环中赋值，从0开始
            for(int j=0;j<=len2;++j){
                if(i==0) dp[0][j]=j;
                else if(j==0) dp[i][0]=i;
                else if(word1.charAt(i-1)==word2.charAt(j-1)) dp[i][j]=dp[i-1][j-1];
                else dp[i][j]=Math.min(dp[i-1][j-1]+1,Math.min(dp[i-1][j]+1,dp[i][j-1]+1));
            }
        }
        return dp[len1][len2];
    }
```

#### 97 交错字符串*

给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` **交错** 组成的。

题解：动态规划，`dp[i][j]` 代表 s1 前 `i` 个字符与 s2 前 `j` 个字符能否拼接成 s3 的 `i+j` 字符

<img src="/image-20220531191326231.png" alt="image-20220531191326231" style="zoom:50%;" />

```java
public boolean isInterleave(String s1, String s2, String s3) {
        int m=s1.length(),n=s2.length();
        if(s3.length()!=m+n) return false;
        boolean[][] dp=new boolean[m+1][n+1];
        dp[0][0]=true;
        for(int i=1;i<m+1&&s1.charAt(i-1)==s3.charAt(i-1);++i) dp[i][0]=true; // 不相符就终止
        for(int j=1;j<n+1&&s2.charAt(j-1)==s3.charAt(j-1);++j) dp[0][j]=true;
        for(int i=1;i<m+1;++i){
            for(int j=1;j<n+1;++j){
                dp[i][j]=dp[i-1][j]&&s1.charAt(i-1)==s3.charAt(i+j-1)||dp[i][j-1]&&s2.charAt(j-1)==s3.charAt(i+j-1);
            }
        }
        return dp[m][n];
    }
```

#### 650 2个键的键盘

给定一个字母 A，已知你可以每次选择复制全部字符，或者粘贴之前复制的字符，求最少需要几次操作可以把字符串延展到指定长度。

题解：不同于以往通过加减实现的动态规划，这里需要乘除法来计算位置，因为粘贴操作是倍数增加的。

```java
public int minSteps(int n) {
        int[] dp=new int[n+1];
        for(int i=2;i<n+1;++i){
            dp[i]=i;  //最大取i
            for(int j=2;j<i;++j){  //两个因数:j,i/j
                if(i%j==0) dp[i]=Math.min(dp[i],dp[j]+i/j);  //复制一次，粘贴次数i/j-1。也可写成f[i] = min(f[i], f[i / j] + j)
            }
        }
        return dp[n];
    }
```

#### 10 正则表达式***

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。`'.' 匹配任意单个字符；'*' 匹配零个或多个前面的那一个元素`

题解：根据正则表达式的不同情况，即字符、星号，点号，我们可以分情况讨论来更新 dp 数组

<img src="/image-20220415125210272.png" alt="image-20220415125210272" style="zoom:80%;" />

```java
public boolean isMatch(String s, String p) {
        int slen=s.length(),plen=p.length();
        boolean[][] dp=new boolean[slen+1][plen+1];
        dp[0][0]=true;
        for(int j=1;j<=plen;++j){   //""和a*a*是true,注意边界
            if(p.charAt(j-1)=='*') dp[0][j]=dp[0][j-2];  //注意减一
        }
        for(int i=1;i<=slen;++i){
            for(int j=1;j<=plen;++j){
                if(p.charAt(j-1)==s.charAt(i-1)||p.charAt(j-1)=='.') dp[i][j]=dp[i-1][j-1]; //是'.'或者是字符（相等必定是字符）
                if(p.charAt(j-1)=='*') {    //是'*'时,题目要求j>1;
                    if (p.charAt(j-2)==s.charAt(i-1)||p.charAt(j-2)=='.') { //上一个配对
                       dp[i][j] = dp[i][j-2]||dp[i - 1][j];//匹配零个或多个，一个dp[i-1][j-2]
                    } else{        //上个不配对，只能匹配零个
                        dp[i][j] = dp[i][j - 2];
                    }
                }
            }
        }        
        return dp[slen][plen];
    }
```

##### 44 通配符匹配

'?' 可以匹配任何单个字符。'*' 可以匹配任意字符串（包括空字符串）

```java
 public boolean isMatch(String s, String p) {
        int slen=s.length(),plen=p.length();
        boolean[][] dp=new boolean[slen+1][plen+1];
        dp[0][0]=true;
        for(int j=1;j<=plen;++j){  //注意边界
            if(p.charAt(j-1)=='*') dp[0][j]=true;  //注意减一
            else break;
        }
        for(int i=1;i<=slen;++i){  
            for(int j=1;j<=plen;++j){
                if(p.charAt(j-1)=='?'|| p.charAt(j-1)==s.charAt(i-1)){
                    dp[i][j]=dp[i-1][j-1];
                }
                if(p.charAt(j-1)=='*'){
                    dp[i][j]=dp[i][j-1]||dp[i-1][j];//零个或多个
                }
            }
        }
        return dp[slen][plen];
    }
```

### 股票交易

股票交易类问题通常可以用动态规划来解决。对于稍微复杂一些的股票交易类问题，比如需要冷却时间或者交易费用，则可以用通过动态规划实现的状态机来解决

```java
//模板：
buy=Integer.MIN_VALUE;sell=0;
//交易一次
for (int i = 0; i < prices.size(); ++i) {
	buy = max(buy, -prices[i]);
	sell = max(sell, buy + prices[i]);
}
//不限制交易次数
buy = max(buy,  sell-prices[i]) 
sell = max(sell, buy + prices[i])
//买卖k次
Arrays.fill(buy,Integer.MIN_VALUE);
for(int i=0;i<len;++i){
   for(int j=1;j<k+1;++j){
		buy[j]=Math.max(buy[j],sell[j-1]-prices[i]);
		sell[j]=Math.max(sell[j],buy[j]+prices[i]);
    }
}
//不限制买卖次数，但是有手续费
buy = max(buy,  sell-fee-prices[i]) 
sell = max(sell, buy + prices[i])
//不限制买卖次数，冻结期为1天
 buy=-prices[0],freeze=sell=0;    
 for(int i=1;i<len;++i){  //从1开始
     int tem=sell;
     buy=Math.max(buy,freeze-prices[i]); //freeze是前俩天卖掉后手里最多的钱
     sell=Math.max(sell,buy+prices[i]);  //sell表示截至第i天，最后一个操作是卖时手里最多的钱
     freeze=tem;
}
```

#### 121 买卖股票的最佳时机

给定一段时间内每天的股票价格，已知你只可以买卖各一次，求最大的收益

```java
 	//类似选择排序，两个for循环，超时
   public int maxProfit2(int[] prices) { 
		for(int i=1;i<len;++i){
            for(int j=0;j<i;++j){
                dp[i]=Math.max(dp[i],Math.max(dp[j],prices[i]-prices[j]));
            }
        }
   }
    //一次遍历
   public int maxProfit(int[] prices) {
        int len=prices.length,buy=Integer.MIN_VALUE,sell=0;
        for(int i=0;i<len;++i){
            buy=Math.max(buy,-prices[i]);  //记录到i为止最低的价格
            sell=Math.max(sell,buy+prices[i]);
        }
        return sell;
    }
```

##### 122 买卖股票的最佳时机Ⅱ

买卖次数不限制，但 最多只能持有一股股票

```java
public int maxProfit(int[] prices) {
        int len=prices.length,buy=Integer.MIN_VALUE,sell=0;
        for(int i=0;i<len;++i){
            buy=Math.max(buy,sell-prices[i]);
            sell=Math.max(sell,buy+prices[i]);
        }
        return sell;
 }
```

##### 188 买卖股票的最佳时机Ⅳ

给定一段时间内每天的股票价格，已知你只可以买卖各 *k* 次，求最大的收益（你必须在再次购买前出售掉之前的股票）。

 题解：**跳出固有的思维，每次看手里持有的钱最多，每天都可能会有买和卖，买相当于减，卖相当于加，这一次是买还是卖只与上一次是买还是卖有关，滚动数组思想**。如果 *k* 大于总天数，一旦发现可以赚钱就进行买卖。如果 *k* 小于总天数，可以建立两个动态规划数组 buy 和 sell，对于每天的股票价格，buy[j] 表示在第 j 次买入时的最大收益，sell[j] 表示在第 j 次卖出时的最大收益

```java
	public int maxProfit(int k, int[] prices) {
        int len=prices.length;
        if(k>=len) return maxPro(prices);  //相当于不限制交易次数，同一天可以先卖出再买入，不写也行
        int[] buy=new int[k+1],sell=new int[k+1];
        Arrays.fill(buy,Integer.MIN_VALUE);
        for(int i=0;i<len;++i){
            for(int j=1;j<k+1;++j){
                buy[j]= Math.max(buy[j],sell[j-1]-prices[i]);
                sell[j]= Math.max(sell[j],buy[j]+prices[i]);
            }
        }
        return sell[k];
    }
     public int maxPro(int[] prices){
        int ans=0;
        for(int i=1;i<prices.length;++i){
            if(prices[i]>prices[i-1]) ans+=prices[i]-prices[i-1];
        }
        return ans;
    }
```

##### 309. 买卖股票时机含冷冻期

每次卖出之后必须冷却一天且最多只能持有一股股票，求最大的收益。尽可能多的完成交易（交易越多利润越大，因为每次都贪心）

题解：我们可以使用状态机来解决这类复杂的状态转移问题，通过建立多个状态以及它们的转移方式，我们可以很容易地推导出各个状态的转移方程。如图所示，我们可以建立四个状态来表示带有冷却的股票交易，以及它们的之间的转移方式。

![image-20220222155301257](/image-20220222155301257.png)

```java
public int maxProfit(int[] prices) {
      int len=prices.length;
        if(len<2) return 0;
        int[] s1=new int[len];
        int[] buy=new int[len];
        int[] s2=new int[len];
        int[] sell=new int[len];
        buy[0]=s1[0]=-prices[0];
        for(int i=1;i<len;++i){
            buy[i]=s2[i-1]-prices[i];  //冷却一天
            s1[i]=Math.max(s1[i-1],buy[i-1]);
            sell[i]=s1[i]+prices[i];
            s2[i]=Math.max(s2[i-1],sell[i-1]);
        }
        return Math.max(sell[len-1],s2[len-1]);
    }
//简化
 public int maxProfit(int[] prices) {
        int len=prices.length,sell=0,buy=-prices[0],freeze=0;
        if(len<=1) return sell;
        for(int i=1;i<len;++i){
            int tem=sell;
            buy=Math.max(buy,freeze-prices[i]); //freeze是前俩天卖掉后手里最多的钱
            sell=Math.max(sell,buy+prices[i]);  //sell表示截至第i天，最后一个操作是卖时手里最多的钱
            freeze=tem;
        }
        return sell;
    }
```



## 数据结构

### 数组

常用代码：

```java
//打印一维数组
System.out.println(Arrays.toString(arr));   //不是arr.toString()
//打印二维数组：
for(int i=0;i<col;++i){
    for(int j=0;j<row;++j){
        System.out.print(res[i][j]+" ");
    }
    System.out.println();
}
或者：
System.out.println(Arrays.deepToString(arr))
//赋值：
for(int[] d:dp){
    Arrays.fill(d,Integer.MAX_VALUE);
}
//复制clone()/Arrays.copyOf()，一维数组时是深拷贝，二维数组存的是的是一维数组的地址，是浅拷贝
int[] res=origin.clone(); 
int[] res=Arrays.copyOfRange(arr,0,len); 
System.arraycopy(heights, 0, tmp, 1, heights.length);//原数组，原数组起始，目标数组，目标数组起始，复制长度
```

#### 31 下一个排列**

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。**下一个排列** 是指其整数的下一个字典序更大的排列。必须原地 修改，只允许使用额外常数空间。 如果不存在下一个更大的排列，按其元素按升序排列。

题解：  题目是要找到下一个刚好比他大的排列。如：2, 6, 3, 5, 4, 1， 可以从后往前看。后两位 4, 1 不可以组成更大的排列，同理 5, 4, 1也不可以 ，直到3, 5, 4, 1这个排列才可以，因为 3 < 5。**故要从后向前要找到第一个相邻升序数字**。会发现 3, 5, 4, 1 是3开头最大的数了，所以要从后往前找第一个比3更大的数字，调换3和4的位置，得到4, 5, 3, 1这个数列 ，要生成4开头的最小的数 ，4之后的数要正序排列， 最终得到了2, 6, 4, 1, 3, 5

```java
public void nextPermutation(int[] nums) {
        int len=nums.length;
        for(int i=len-1;i>0;i--){   //第一个升序的
            if(nums[i]>nums[i-1]){  
                Arrays.sort(nums,i,len);  //快排，在原数组操作
                for(int j=i;j<len;++j){  //找到比nums[i-1]大的为止
                    if(nums[j]>nums[i-1]){  
                        int tem=nums[j];
                        nums[j]=nums[i-1];
                        nums[i-1]=tem;
                        return;
                    }
                }
            }
        }
        Arrays.sort(nums);  
        return ;
    }
```

#### 41 缺失的第一个正数

给一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。要求时间复杂度为 `O(n)` 并且只使用常数级别额外空间

题解：可以先把数组元素全放进哈希表。接下来从1- len遍历，看哪个不在哈希表中，但哈希表的空间复杂度和数组大小相关，为O(n)不符合要求。用原地哈希：让每个数字n都回到下标为n-1的家里。而那些没有回到自己家里的数字要么是根本就没有自己的家（数字小于等于0或者大于nums.size()），要么是自己的家被别人占领了（出现了重复）。没有回到自己家里的数字所待的家是因为房子i的主人i+1失踪了（数字i+1缺失）

<img src="/image-20220422152158626.png" alt="image-20220422152158626" style="zoom: 67%;" />

```java
 public int firstMissingPositive(int[] nums) {
        int len=nums.length;
        for(int i=0;i<len;++i){
          // 数字在范围内,并且当前位置的数据所在位置不对,才交换。不用i!=nums[i]-1 表示当前位置上的的数字不对，这样有重复的数字会有死循环。不用if，被交换过来的数还需要继续判断它是不是在合适的位置
            while(nums[i]>0&&nums[i]<=len&&nums[i]!=nums[nums[i]-1]){  
                swap(nums,i,nums[i]-1); //传下标。最好封装成方法，不然nums[i]=nums[nums[i]-1]; nums[nums[i]-1]=temp;nums[i]已经变了
            }
        }
        for(int i=0;i<len;++i){
            if(i!= nums[i]-1) return i+1; 
        }
        return len+1;
    }
     private void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }
```

#### 448 找到数组中消失的数

给定一个长度为 *n* 的数组，其中包含范围为 1 到 *n* 的整数，有些整数重复了多次，有些整数没有出现，求 1 到 *n* 中没有出现过的整数。

```java
//set,17ms
    public List<Integer> findDisappearedNumbers3(int[] nums) {
        Set<Integer> set=new HashSet<>();
        List<Integer> list=new ArrayList<>();
        int len=nums.length;
        for(int n:nums){
            set.add(n);
        }
        for(int i=1;i<len+1;++i){
            if(!set.contains(i))
            list.add(i); 
        }
        return list;
    }
    //新数组做标记,3ms
    public List<Integer> findDisappearedNumbers2(int[] nums) {
        List<Integer> list=new ArrayList<>();
        int len=nums.length;
        boolean[] arr=new boolean[len];
        for(int n:nums){
            arr[n-1]=true;
        }
        for(int i=0;i<len;++i){
            if(!arr[i]) list.add(i+1);
        }
        return list;
    }
    //原数组做标记，还不会覆盖原来的数,空间优化，5ms
     public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> list=new ArrayList<>();
        int len=nums.length;
        int idx=0;
         for(int i=0;i<len;++i){
            idx=Math.abs(nums[i])-1;
            if(nums[idx]>0) nums[idx]=-nums[idx]; //大于0时才标记
        }
        for(int i=0;i<len;++i){
            if(nums[i]>0) list.add(i+1);
        }
        return list;
    }
```

#### 769 最多能完成排序的块

给定一个含有 0 到 *n* 整数的数组，每个整数只出现一次，求这个数组最多可以分割成多少个子数组，使得对每个子数组进行增序排序后，原数组也是增序的。

题解：从左往右遍历，同时记录当前的最大值，每当当前最大值等于数组位置时，可以多一次分割（块内连续，最大的大于后面最小的）

```java
public int maxChunksToSorted(int[] arr) {
        int max=0,len=arr.length,res=0;
        for(int i=0;i<len;++i){
            max=Math.max(max,arr[i]);
            if(i==max) res++; 
        }
        return res;
 }
```



#### 48 旋转图像

给定一个 *n* × *n* 的矩阵，求它顺时针旋转 90 度的结果，且必须在原矩阵上修改（in-place）。怎样能够尽量不创建额外储存空间呢

<img src="/image-20220307151335028.png" alt="image-20220307151335028" style="zoom:80%;" />

```java
//辅助数组，0ms
    public void rotate2(int[][] matrix) {
        int row=matrix.length;   //题目行列相同
        int col=matrix[0].length;
        int[][] res=new int[col][row];  //行列对换             
        for(int j=0,x=0;j<col;++j,++x){
            for(int i=row-1,y=0;i>=0;--i,++y){
                res[x][y]=matrix[i][j];
            }          
        }
        for(int i=0;i<row;++i){
            matrix[i]=res[i].clone();  //直接matrix=res;或 matrix=res.clone();是浅拷贝，提交不通过
        }  
    }
//翻转代替旋转
    public void rotate(int[][] matrix) {
        int row=matrix.length; //col和row必相等
        for(int i=0;i<row;++i){  //先沿斜对角线翻转
            for(int j=0;j<i;++j){  //不用等于，对角线不换
                int tem=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i]=tem;
            }
        }
        for(int i=0;i<row;++i){ //再沿垂直竖线翻转
            for(int j=0,k=row-1;j<k;k--,j++){
                int tem=matrix[i][k];
                matrix[i][k]=matrix[i][j];
                matrix[i][j]=tem;
            }
        }
    }
```

#### 54 螺旋矩阵**

给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素

<img src="/image-20220503151054239.png" alt="image-20220503151054239" style="zoom:33%;" />

```java
public List<Integer> spiralOrder(int[][] matrix) {
        int m=matrix.length,n=matrix[0].length,u=0,d=m-1,l=0,r=n-1;
        List<Integer> res=new ArrayList<>();
        while(true){  //有左右上下边界,不用visit数组了
            for(int j=l;j<=r;++j) res.add(matrix[u][j]);
            if(++u>d) break;
            for(int i=u;i<=d;++i) res.add(matrix[i][r]);
            if(--r<l) break;
            for(int j=r;j>=l;--j) res.add(matrix[d][j]);
            if(--d<u) break;
            for(int i=d;i>=u;--i) res.add(matrix[i][l]);
            if(++l>r) break;
        }
        return res;
    }
```

#### 240 搜索二维矩阵**

给定一个二维矩阵，已知每行和每列都是增序的，尝试设计一个快速搜索一个数字是否在矩阵中存在的算法。

题解：从右上角出发开始遍历，向左数字会变小，向下数字会变大，有点和二分查找树相似。若当前值大于待搜索值，我们向左移动一位；若当前值小于待搜索值，我们向下移动一位。若数组说逐行递增的也可以用。复杂度为O(m+n)

<img src="/image-20220307161029830.png" alt="image-20220307161029830" style="zoom:67%;" />

```java
//抽象 BST
public boolean searchMatrix(int[][] matrix, int target) {
    int row=matrix.length;
    int col=matrix[0].length;
    int i=0,j=col-1;
    while(i<row&&j>=0){
        if(target==matrix[i][j]) return true;
        else if(target<matrix[i][j]) j--;
        else  i++;
    }
    return false;
}
//二分法，一行一行的进行二分查找
```

#### 73 矩阵置零

给定一个 `m x n` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 原地 算法

```java
 //1ms
    public void setZeroes2(int[][] matrix) {
        int m=matrix.length,n=matrix[0].length;
        Set<Integer> row=new HashSet<>();
        Set<Integer> col=new HashSet<>();
        for(int i=0;i<m;i++){
            for(int j=0;j<n;++j){
                if(matrix[i][j]==0){
                    row.add(i);
                    col.add(j);
                } 
            }
        }
        for(Integer r:row){
            for(int j=0;j<n;++j){
                matrix[r][j]=0;
            }
        }
        for(Integer c:col){
            for(int i=0;i<m;++i){
                matrix[i][c]=0;
            }
        }
    }
    //0ms,空间复杂度O(1)
    public void setZeroes(int[][] matrix) {
        int m= matrix.length,n= matrix[0].length;
        boolean row0 = false,col0 = false;  // 第一行/列是否有零
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                row0 = true;
                break;
            }
        }
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                col0 = true;
                break;
            }
        }
        // 把第一行第一列作为标志位
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0)   matrix[i][0] = matrix[0][j] = 0;
            }
        }
        // 置0
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0)    matrix[i][j] = 0;
            }
        }
        if (row0) {
            for (int j = 0; j < n; j++)    matrix[0][j] = 0;
        }
        if (col0) {
            for (int i = 0; i < m; i++)    matrix[i][0] = 0;
        } 
    }
```

#### 621 任务调度器**

task数组每个字母表示一种不同种类的任务。任务可以任意顺序执行。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。但两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，计算完成所有任务所需要的 最短时间 。

题解：会有三种情况：

1、A-Z用一个int[26]保存任务种数，排序，先选数量最大的任务，最短时间： retCount =（count-1）* (n+1) + 1 => A->X->X->A->X->X->A(X为其他任务或者待命)

2、如果下一个任务B个数和最大任务数一致，则retCount++ ==> A->B->X->A->B->X->A->B

3、若都插满了还有，随便在这些间隔里面插入就可以，因为间隔长度肯定会大于n，这样最后取的是时间就是task的len

如：[A,A,A,B,B,B,C,C,C,D,D,D]  ==》 ABCDABCDABCD

```Java
public int leastInterval(char[] tasks, int n) {
        int len=tasks.length,maxCnt=0,res;
        int[] cnt=new int[26];
        for(char c:tasks){
            cnt[c-'A']++;
        }
        Arrays.sort(cnt);
        maxCnt=cnt[25];
        res=(maxCnt-1)*(n+1)+1;
        for(int i=24;i>=0;--i){
            if(cnt[i]==maxCnt){
                res++;
            }else break;
        }
        return res<len?len:res;   //res计算结果小于len就取len
    }
```

#### 晋级人数

计划晋级人数x人，则将所有人的分数从高到低排序（可能出现同分情况），所有分数大于等于第x个人的分数且得分不为0的人都可以晋级。  求实际晋级人数。

输入：第一行两个正整数n和x，表示参加人数和指定的x。第二行包含n个整数，每个整数表示一位选手的得分。

输出：一个整数，表示实际晋级人数，

题解：找到对应的分数，用二分法求对应值的位置，如34题

```java
 public static void main(String[] args){  //牛客网用Mian做类名
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int x=sc.nextInt();
        Integer[] arr=new Integer[n];  //用包装类后面才能从大到小排
        for(int i=0;i<n;++i){
            arr[i]=sc.nextInt();
        }
        Arrays.sort(arr,(a,b)-> b-a);  //或 Arrays.sort(arr, Collections.reverseOrder());
        int num=0,index=-1;
        for(int i=0;i<n;++i){
            if(arr[i].equals(0)&&i<=x-1){    //最好是用eqauls，==进行判断那么有效范围为-128-127 
                index=i;
                break;
            }
            if(arr[x-1].equals(arr[i])&&i>x-1)    num++;          
        }
        if(index!=-1)    System.out.println(index+1);
        else    System.out.println(x+num);
    }
```

#### 最小数字**

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出最小的一个，例如数组{3，32，321}，则最小数字为321323。

```java
//先将它们拼接起来，比较s1+s2,和s2+s1那个大，如果s1+s2大，那说明s2应该放前面，(先不管其他的，只两两比较，类似于选择排序)
public static String PrintMinNumber2(int [] num) {
		if(num.length==0||num==null) return "";   
		Integer[] arr=new Integer[num.length];  //变成Integer或者String才能用Array.sort
		for(int i=0;i<num.length;i++) {
			arr[i]=num[i];
		}		
		Arrays.sort(arr,(o1,o2)->(o1+""+o2).compareTo(o2+""+o1)); //不能用“-”,满足前小于后则返回-1，元素不交换.也可写两个for循环
		return Arrays.toString(arr);
	}
```



### 栈和队列

```java
用Deque<Integer> q = new LinkedList<>()；代替Stack<Integer> stack = new Stack<>()，方法一样但效率快
```

#### 71 简化路径**

一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称，最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。

题解：先以 / 为分割符分割成多个文件名，遍历文件名，如果是正常的文件名就直接入栈，如果是".."弹出栈顶元素，如果是'.'不用管他，到最后再遍历栈，将出栈的元素插入到返回字符串的头上同时加上'/'。

```java
public String simplifyPath(String path) {
        Stack<String> stack=new Stack<>();
        String[] str=path.split("/");
        for(String s:str){
            if("".equals(s)||".".equals(s)) continue;  //不能用==
            if("..".equals(s)){
                if(!stack.isEmpty()) stack.pop();
            } else stack.push(s);
        }
        StringBuilder sb=new StringBuilder();
        for(String s:stack){
            sb.append("/");
            sb.append(s);  // java的stack是个List，也可sb.insert(0,stack.pop());
        }
        if(stack.isEmpty()) return "/";
        return sb.toString();
    }
```

#### 232 用栈实现队列

尝试使用栈（stack）来实现队列（queue）

```java
 //栈容量o>p,则队列最大容量为2p+1
    Stack<Integer> s1;
    Stack<Integer> s2;
    public MyQueue() {
        s1=new Stack<>();
        s2=new Stack<>();
    }  
    public void push(int x) {
        // while(!s2.isEmpty()){
        //     s1.push(s2.pop());
        // }
        s1.push(x);
    }    
    public int pop() {
        if(s2.isEmpty()){
            while(!s1.isEmpty()){
                s2.push(s1.pop());
            }
        }      
        return s2.pop();
    }  
    public int peek() {
        if(s2.isEmpty()){
            while(!s1.isEmpty()){
                s2.push(s1.pop());
            }
        }      
        return s2.peek();
    }    
    public boolean empty() {
        return s1.isEmpty() && s2.isEmpty();
    }
```

#### 155 最小栈

设计一个最小栈，除了需要支持常规栈的操作外，还需要支持在 ***O*(1) 时间内**查询栈内最小值的功能。

题解：以额外建立一个新栈，栈顶表示原栈里所有值的最小值。在原栈里插入一个数字时，若该数字小于等于新栈栈顶，将其同时插入新栈内。每当从原栈里取出一个数字时，若该数字等于新栈栈顶，同时取出新栈栈顶的值。

```java
//clone方法循环遍历的时间复杂度太高，超时
	Stack<Integer> s;
    Stack<Integer> min;
    public MinStack() {
        s=new Stack<>();
        min=new Stack<>();        
    }   
    public void push(int val) {
        s.push(val);
        if(min.isEmpty()||min.peek()>=val) min.push(val);   //等于的也要放入
    }   
    public void pop() {
        int tem=s.pop();
        if(tem==min.peek())  min.pop();
    }    
    public int top() {
       return s.peek();
    }   
    public int getMin() {
        return min.peek();
    }
```

#### 20 有效括号**

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，求这个字符串是否合法。合法的定义是每一个类型的左括号都有一个右括号一一对应，且括号内的字符串也满足此要求。

题解：括号问题只是简单的判断或找长度，可以用栈试试，将左端的加入，右端的来判断。若要生成新的括号式的用回溯。

```java
 	//栈，1ms
    public boolean isValid2(String s) {
        Stack<Character> stack=new Stack<>();
        int len=s.length();
        for(int i=0;i<len;++i){
            char c=s.charAt(i);
            if(c=='{'||c=='['||c=='(') stack.push(c);
            else{
                if(stack.isEmpty()) return false;  //写上面，否则empty时下一句会报错
                char top=stack.peek();               
                if(top=='{'&&c=='}' || top=='['&&c==']' || top=='('&&c==')' ) stack.pop();  //&&优先级比||高
                else return false;
            }
        }
        return stack.isEmpty();
    }
    //字符串方法，55ms
    public boolean isValid(String s) {
        while(s.contains("{}")||s.contains("[]")||s.contains("()")){
			if(s.contains("[]")) {s=s.replace("[]", ""); }   //用replaceAll要用正则
			if(s.contains("{}")) {s=s.replace("{}", "");	}
			if(s.contains("()")) {s=s.replace("()", ""); }
		}
		return s.isEmpty();
    }
```

##### 32 最长有效括号**

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

题解：不加-1的话，0已经pop出去了，最长只有 5-2+1。故最左边要保留一个参照

<img src="/image-20220420104931014.png" alt="image-20220420104931014" style="zoom: 33%;" />

```java
	public int longestValidParentheses(String s) {
        int len=s.length(),res=0;
        Stack<Integer> stack=new Stack<>();
        stack.push(-1); //最左边要保留一个参照
        for(int i=0;i<len;++i){
            if(s.charAt(i)=='(') stack.push(i);
            else{
                stack.pop();  //pop后判断
                if(!stack.isEmpty()) {                
                   res=Math.max(res,i-stack.peek());
                }else stack.push(i);
            }
        }
        return res;
    }
```

#### 227 基本计算器***

给定一个包含加减乘除整数运算的字符串（可能有空格），求其运算结果（结果int范围），只保留整数。

题解：双栈法，遍历到的字符做分情况讨论：

​	空格 : 跳过
​	( : 加入 op 中
​	) : 计算直到遇到左边最近的（  为止
​	数字 : 将整一个连续数字整体取出，加入 num

​	运算符 : 放入 op 中。在放入之前先把栈内可以算的都算掉（只有「栈内运算符」比「当前运算符」优先级高/同	等，才进行运算），直到没有操作或者遇到左括号

细节：

​	第一个数可能是负数 或 存在（- 情况，可在 - 前添加一个 0
​	num 最好存放的是 long，因为可能存在 大数 + 大数  - 大数  中间结果溢出，最终答案不溢出的情况

![image-20220319151718434](/image-20220319151718434.png)

```java
    Deque<Integer> num=new LinkedList<>();
    Deque<Character> op=new LinkedList<>();
    Map<Character,Integer> map=new HashMap<>(); //运算符按优先级划分
    public int calculate(String s) {
        map.put('+',1);
        map.put('-',1);
        map.put('*',2);
        map.put('/',2);
        map.put('^',3);
        s=s.replaceAll("\\(-","(0-");   //(要转义,开头是负数的处理，replace不改变原字符串
        s=s.replaceAll(" ","");s="0"+s; 
        int len=s.length();
        for(int i=0;i<len;++i){
            char c=s.charAt(i);
            if(Character.isDigit(c)){
                int tem=i,x=0;
                while(tem<len&&Character.isDigit(s.charAt(tem))){
                    x=x*10+s.charAt(tem)-'0';
                    tem++;
                }
                i=tem-1;
                num.push(x);
            }else if(c=='('){
                op.push(c);
            }else if(c==')'){
                while(op.peek()!='('){
                    calculate();
                }
                op.pop();
            }else{
                while(!op.isEmpty()&&op.peek()!='('&&map.get(op.peek())>=map.get(c)){ //同级也要先算，1-1+1
                    calculate();
                }
                op.push(c);
            }
        }
        while(!op.isEmpty()){calculate();}
        return num.pop();
    }
    public void calculate(){
        int b=num.pop();   //b先出来
        int a=num.pop();
        char c=op.pop();
        int ans=0;
        if(c=='+') ans=a+b;
        else if(c=='-') ans=a-b;
        else if(c=='*') ans=a*b;
        else if(c=='/') ans=a/b;
        num.push(ans);
     }
```

逆波兰表达式：逆波兰表达式是一种后缀表达式，所谓后缀就是指运算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式优点：

去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

#### 394 字符串解码***

给定一个经过编码的字符串，返回它解码后的字符串。方括号内部的 string 正好重复 k 次

输入：s = "3[a2[c]]"
输出："accaccacc"

题解：本题难点在于括号内嵌套括号，需要**从内向外**生成与拼接字符串，这与栈的**先入后出**特性对应。

```java
public String decodeString(String s) {
        int len=s.length();
        Deque<Integer> numStack=new LinkedList<>();
        Deque<StringBuilder> strStack=new LinkedList<>(); 
        strStack.push(new StringBuilder());
        for(int i=0;i<len;++i){
            char c=s.charAt(i);
            if(Character.isDigit(c)){
                int t=i,x=0;
                while(t<len&&Character.isDigit(s.charAt(t))){
                    x=x*10+s.charAt(t)-'0';
                    t++;
                }
                i=t-1;
                numStack.push(x);
                strStack.push(new StringBuilder());  //后面一定会有字符串
            }else if(c>='a'&&c<='z'){
                strStack.peek().append(c);
            }else if(c==']'){
                int num=numStack.pop();
                String str=strStack.pop().toString();
                while(num>0){
                    strStack.peek().append(str);
                    num--;
                }
            }
        }
        return strStack.peek().toString();
    }
```

### 单调栈

单调栈通过维持栈内值的单调递增（递减）性，在整体 *O*(*n*) 的时间内处理需要大小比较的问题。

#### 84 柱状图中最大矩形**

数组为每个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

题解：遍历每根柱子，以当前柱子 i 的高度作为矩形的高，矩形的宽度边界即为向左向右找到第一个高度小于当前柱体 i 的柱体。对于每个柱子都计算一遍以当前柱子作为高的矩形面积，找出最大的矩形面积即可。

优化：用单调增栈以 O(1) 复杂度获取柱体 i 左边/右第一个比它小的柱体。遍历每个柱体，若当前的柱体高度大于等于栈顶柱体的高度，则入栈，小于就说明当前栈顶柱体找到了右边的第一个小于自身的柱体，而对于栈中的柱体来说，前一个元素就是左边第一个高度小于自身的柱体，这就可以计算以栈顶柱体为高的矩形的面积了

<img src="/image-20220523101648360.png" alt="image-20220523101648360" style="zoom:80%;" />

```java
//暴力法，超时
    public int largestRectangleArea2(int[] heights) {
        int len=heights.length,res=0,h,w,j;
        for(int i=0;i<len;++i){
            w=1;h=heights[i];j=i-1;
            while(j>=0&&heights[j]>=h){
                w++;
                j--;
            }
            j=i+1;
            while(j<len&&heights[j]>=h){
                w++;
                j++;
            }
            res=Math.max(res,h*w);
        }
        return res;
    }
    //单调栈
    public int largestRectangleArea(int[] heights) {
        int len=heights.length,res=0;
        int[] tem=new int[len+2]; //为了代码简便，在数组头尾加了两个高度为0的柱体，即哨兵
        System.arraycopy(heights,0,tem,1,len);
        Stack<Integer> stack=new Stack<>();  //加入的是索引
        for(int i=0;i<len+2;++i){
            while(!stack.isEmpty()&&tem[i]<tem[stack.peek()]){ //计算栈顶柱体为高的矩形
                int h=tem[stack.pop()];
                res=Math.max(res,(i-stack.peek()-1)*h); //h高度的提前出栈了
            }
            stack.push(i);
        }
        return res;
    }
```

##### 85 最大矩形***

给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积

题解：暴力法，遍历每个点，求以这个点为矩阵右下角的所有矩阵面积，高度逐渐增加找矩形。

优化：利用84题

<img src="/image-20220523164959306.png" alt="image-20220523164959306" style="zoom:67%;" />

```java
 public int maximalRectangle(char[][] matrix) {
        int row=matrix.length,col=matrix[0].length,res=0;
        int[] arr=new int[col];
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                if(matrix[i][j]=='1') arr[j]++;
                else arr[j]=0;
            }
            res=Math.max(res,largestRectangleArea(arr));
        }
        return res;
    }
     public int largestRectangleArea(int[] heights) {
        int len=heights.length,res=0;
        int[] tem=new int[len+2]; //为了代码简便，在数组头尾加了两个高度为0的柱体
        System.arraycopy(heights,0,tem,1,len);
        Deque<Integer> stack=new ArrayDeque<>(); //加入的是索引
        for(int i=0;i<len+2;++i){
            while(!stack.isEmpty()&&tem[i]<tem[stack.peek()]){ //计算栈顶柱体为高的矩形
                int h=tem[stack.pop()];
                res=Math.max(res,(i-stack.peek()-1)*h); //h高度的提前出栈了
            }
            stack.push(i);
        }
        return res;
    }
```

#### 739 每日温度**

给定每天的温度，求对于每一天需要等几天才可以等到更暖和的一天。如果该天之后不存在更暖和的天气，则记为 0。

题解：栈内是还没有得出结果的下标，可以维持一个单调递减的栈，为了方便计算天数差，存放下标位置而非温度本身

<img src="/image-20220308132025009.png" alt="image-20220308132025009" style="zoom:67%;" />

```java
   //双for,1200ms
    public int[] dailyTemperatures2(int[] temperatures) {
        int day=1,len=temperatures.length;
        int[] res=new int[len];
        for(int i=0;i<len;++i){
            day=1;
            for(int j=i+1;j<len;++j){
                if(temperatures[j]>temperatures[i]){
                    res[i]=day;
                    break;
                }
                day++;
            }
        }
        return res;
    }
    //栈，22ms
  public int[] dailyTemperatures(int[] temperatures) {
        int len=temperatures.length;
        Deque<Integer> s=new LinkedList<>();
        int[] res=new int[len];
        for(int i=0;i<len;++i){
            while(!s.isEmpty()&&temperatures[s.peek()]<temperatures[i]){ //等于不用
                int tem=s.pop();
                res[tem]=i-tem;
            }
            s.push(i);
        }
        return res;
    }
```

### 优先队列(堆)

优先队列（priority queue）可以在 *O*(1) 时间内获得最大值，并且可以在 *O*(log *n*) 时间内取出最大值或插入任意值。

优先队列常常用堆（heap）来实现。堆是一个完全二叉树，通常用一个数组而不是用node 指针建立一个树，位置 i 的节点的父节点位置一定为 i/2，而它的两个子节点的位置又一定分别为 2i 和 2i+1。堆的实现方法，其中最核心的两个操作是上浮和下沉（详见计算机基础-堆排序）。

#### 218 天际线问题

给定建筑物的起止位置和高度，返回建筑物轮廓（天际线）的拐点

<img src="/image-20220308172743806.png" alt="image-20220308172743806" style="zoom:67%;" />

```java

```

#### 数据流中的中位数*

 对于海量数据和流的数据，用最大堆和最小堆来管理
 Java的PriorityQueue 是从JDK1.5开始提供的新的数据结构接口，默认内部是自然排序，结果为小顶堆，也可以自定义排序器。

```java
//    为了保证插入新数据和取中位数的时间效率都高效，这里使用大顶堆+小顶堆的容器，并且满足：
//            1、两个堆中的数据数目差不能超过1，这样可以使中位数只会出现在两个堆的交接处；
//            2、大顶堆的所有数据都小于小顶堆，这样就满足了排序要求。
    //直接排序的时间复杂度，应该是n*nlogn,每次插入一个数字，都要进行排序，一共排了n次。而这排序的时间复杂度是nlogn，
    private PriorityQueue<Integer> min=new PriorityQueue<>();
    private PriorityQueue<Integer> max=new PriorityQueue<>((x,y)->y-x);
    private int count=0;
     public void Insert2(Integer num) {  //读取数据流
         if ((count&1)==0){     //当数据总数为偶数时，新加入的元素，应当进入小根堆
             max.offer(num);    // （注意不是直接进入小根堆，而是经大根堆筛选后取大根堆中最大元素进入小根堆）
             num=max.poll();
             min.add(num);
         }else{
             min.add(num);
             num=min.poll();
             max.add(num);
         }
         count++;
     }
   
    public Double GetMedian2() {    //获取当前读取数据的中位数，个数为偶数的话就是中间两个值的平均值.奇数的话就是中间值.
         if (count==0){throw new RuntimeException("no available number!");}
        if ((count&1)==0){
            return (max.peek()+min.peek())/2.0; //int除法会缺失精度，某个要先转double
        }else{
            return min.peek()/1.0;   //count从0开始的，第一个元素放入小堆中
        }
    }

```

#### 小美的仓库整理

每件货物的重量为w_i，小美会根据单据依次不放回的取出货物。每取出一件货物后会把剩余货物以取出的货物为界分成两堆，每次重量和最大的一堆货物重量是多少？

```java
public class Main {
 public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n], b = new int[n];
        for(int i = 0; i < n; i++){
            a[i] = sc.nextInt();
        }
        for(int i = 0; i < n; i++){
            b[i] = sc.nextInt() - 1;
        }
        TreeSet<Integer> set = new TreeSet<>();
        Collections.addAll(set, -1, n);  //-1和n加入set
        PriorityQueue<Integer> dui = new PriorityQueue<>((x,y)->y.compareTo(x));
        for (int i = 0; i <n; i++) {
            int start = set.floor(b[i]) + 1; 
            int end = set.ceiling(b[i]);//取TreeSet中大于等于b[i]的最小一个
            int leftT = 0, rightT = 0;
            for (int j = start; j < end; j++) {
                if (j < b[i]){
                    leftT += a[j];
                }else if(j > b[i]){
                    rightT += a[j];
                }
            }
            dui.remove(leftT + a[b[i]] + rightT); //不用poll方法
            Collections.addAll(dui, leftT, rightT);
            set.add(b[i]);
            System.out.println(dui.peek());
        }
    }
}
```



### 双端队列

单调队列在添加元素的时候靠删除元素保持队列的单调性；而优先级队列（二叉堆）相当于自动排序

#### 239 滑动窗口最大值***

给定一个整数数组和一个滑动窗口大小，求在这个窗口的滑动过程中，每个时刻其包含的最大值

题解：以利用双端队列进行操作：存的是下标，每当向右移动时，把窗口左端的值从队列剔除，把队列中小于窗口右端的值全部剔除。这样双端队列的最左端永远是当前窗口内的最大值。另外，这道题也是单调栈的一种延申：该双端队列利用从左到右递减来维持大小关系

```java
  //双个for，复杂度太高
  //单调队列
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> q=new LinkedList<>(); //放入的是下标，队列size可能小于窗口大小，用下标保证放入窗口大小的个数
        int len=nums.length;
        int[] res=new int[len-k+1];
        for(int i=0;i<len;++i){
            //加入队列前要左右要做的事
            if(!q.isEmpty()&&i-q.peek()==k)  q.poll(); //将左端剔除
            while(!q.isEmpty()&&nums[i]>nums[q.peekLast()]) { //剔除右端小于当前遍历,保证单调
                q.pollLast();
            }
            q.offer(i);
            if(i>=k-1) res[i-k+1]=nums[q.peek()];
        }
        return res;
    }
```

### 哈希表

哈希表，又称散列表，使用 *O*(*n*) 空间复杂度存储数据，通过哈希函数映射位置，从而实现近似 *O*(1) 时间复杂度的插入、查找、删除等操作。

**如果元素有穷，并且范围不大**，那可以用一个固定大小的数组来存储或统计元素。例如我们需要统计一个字符串中所有字母的出现次数，则可以用一个长度为 26 的数组来进行统计，这样空间复杂度就可以降低为常数。

用switch存键值会比map更快：但可读性不好

```java
switch(ch) {
            case 'I': return 1;
            case 'V': return 5;
            default: return 0;
}
```

#### 1 两数之和

给定一个整数数组，已知有且只有两个数的和等于给定值，求这两个数的位置。

题解：要是数组是有序的话可用 双指针

```java
	public int[] twoSum(int[] nums, int target) {  
        HashMap<Integer,Integer> map=new HashMap<>(16);  //先给map初始化一个值会快
        int len=nums.length;
        for(int i=0;i<len;++i){
            if(map.containsKey(target-nums[i])){
                return new int[]{map.get(target-nums[i]),i};
            }
            map.put(nums[i],i);  //有重复的也不怕，若kv反过来存，不好由v得k
        }
        return null;
    }
```

#### 1218 最长定差子序列

请找出并返回 `arr` 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 `difference`

```java
//用dp,连续递增序列会超时
//hash
public int longestSubsequence(int[] arr, int difference) {
        Map<Integer,Integer> map=new HashMap<>();
        int max=0;
        for(int i:arr){
            map.put(i,map.getOrDefault(i-difference,0)+1);
            max=Math.max(max,map.get(i));
        }
        return max;
}
```

#### 128 最长连续序列***

给定一个整数数组，求这个数组中的数字可以组成的最长连续序列有多长。要求时间复杂度为 `O(n)` 

题解：暴力法可以先sort再遍历连续的，但不符合时间复杂度

我们可以把所有数字放到一个哈希表，然后不断地从哈希表中任意取一个值，并删除掉其之前之后的所有连续数字，然后更新目前的最长连续序列长度。

若是求最长递增子序列则要用动态规划

```java
//用set,先排序后用一个while向后遍历26ms，直接两个while左右遍历14ms
   public int longestConsecutive(int[] nums) {
        Set<Integer> set=new HashSet<>();
        int max=0,r=0,l=0;
        for(int n:nums) {
            set.add(n);
        }
        //Arrays.sort(nums);
        for(int n:nums){
            if(set.contains(n)){
                r=n+1;
                l=n-1;
                while(set.contains(r)){
                    set.remove(r++);
                }
                while(set.contains(l)){
                    set.remove(l--);
                }
                max=Math.max(max,r-l-1);
            }
        }
        return max;
    }
```

#### 149 直线上最多的点数**

给你一个数组 `points` ，其中 `points[i] = [xi, yi]` 表示 **X-Y** 平面上的一个点。求最多有多少个点在同一条直线上。

题解：对于每个点，我们对其后面的点建立哈希表，统计同一斜率的点一共有多少个，key为斜率，value为数量。利用的原理是，一条线可以由一个点和斜率而唯一确定。另外也要考虑斜率不存在和重复坐标的情况。可以重复用一个map，每次清空map即可

```java
 public int maxPoints(int[][] points) {
        int len=points.length,same,sameX,max=0;
        if(len<=2) return len;
        double slope=0;
        Map<Double,Integer> map=new HashMap<>();
        for(int i=0;i<len;++i){
            same=0;sameX=0;
            for(int j=i+1;j<len;++j){
                if(points[i][0]==points[j][0]){
                    sameX++;
                    if(points[i][1]==points[j][1]) same++;
                }else{
                    slope=((double)points[i][1]-points[j][1])/(points[i][0]-points[j][0]);  //int除法会缺失精度，某个要先转double
                    if(slope==-0.0) slope=0.0;     // 斜率-0和0在map中算两个不同的数
                    map.put(slope,map.getOrDefault(slope,0)+1);
                    max=Math.max(max,map.get(slope)+same+1);
                }  
            }
            max=Math.max(max,sameX+1); //没有斜率的最大个数,sameX也包含了重复的点
            map.clear();
        }
        return max;
    }
```

#### 169 多数元素

给定一个大小为 `n` 的数组，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

题解：摩尔投票法：先假设第一个数过半数并设cnt=1；遍历后面的数如果相同则cnt+1，不同则减一，当cnt为0时则更换新的数字为候选数（成立前提：有出现次数大于n/2的数存在）。即每个“多数元素”和其他元素 **两两对拼抵消**，抵消到最后肯定还剩余**至少`1`个**“多数元素

```java
 	//基数排序后，找中间的数即为所求
    //hash表，18ms
    public int majorityElement2(int[] nums) {
        HashMap<Integer,Integer> map=new HashMap<>();
        int len=nums.length;
        for(int i=0;i<len;++i){           
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);  //先放入
            if(map.containsKey(nums[i])&&map.get(nums[i])>len/2) return nums[i];
        }
        return -1;
    }
    //摩尔投票法,1ms
    public int majorityElement(int[] nums) {
        int len=nums.length,cnt=0,res=0;
        for(int n:nums){
            if(cnt==0) res=n;
            cnt=res==n?++cnt:--cnt;  
        }
        return res;
    }
```

#### 第一个唯一字符

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符（区分大小写），并返回它的位置，如果没有则返回 -1

```java
public static int FirstNotRepeatingChar2(String str) {
		HashMap<Character,Integer> hm=new HashMap<Character, Integer>();
		char[] chs=str.toCharArray();
		for(int i=0;i<str.length();i++) {
		Integer value=hm.get(chs[i]);
		if(value==null) {
			hm.put(chs[i], 1);
		}else {
			hm.put(chs[i], ++value);
		 }
		}
		for(int i=0;i<str.length();i++) {
			if(hm.get(str.charAt(i))==1) {
				return i;
			}
		}
		return -1;
}	
	//方法2（用ASCII编码）65-90为A-Z，97-122为a-z；就定义一个长度为58的数组 (其实就是hash原理)    48-57为数字
	public static int FirstNotRepeatingChar3(String str) {
		int[] nums=new int[58];  //未初始化都为0；
		for(int i=0;i<str.length();i++) {
		nums[((int)str.charAt(i))-65]++;
	}
		for(int i=0;i<str.length();i++) {
			if(nums[(int)str.charAt(i)-65]==1) {
				return i;
			}
		}
		return -1;
	}
```

#### 简单错误记录***

输入：一行或多行字符串。格式：文件名称 行数， 如：E:\V1R2\product\fpgadrive.c 1325

输出：格式：文件名代码 行数 数目，一个空格隔开，如: fpgadrive.c 1325 1 
    结果根据数目从多到少排序，数目相同的情况下，按照输入第一次出现顺序排序。
    如果超过8条记录，则只输出前8条记录.
    如果文件名的长度超过16个字符，则只输出后16个字符

```Java
import java.util.*;
public class Main{
    public static void main(String[] args){
      Scanner sc=new Scanner(System.in);
       Map<String,Integer> map=new LinkedHashMap<>();  //数目相同的情况下，按照输入第一次出现顺序排序
      while(sc.hasNext()){
         String s = sc.nextLine();
         String s2=s.substring(s.lastIndexOf('\\') + 1);  //split(""),indexOf('').indexOf(“”)
          map.put(s2,map.getOrDefault(s2,0)+1); //map中有就返回对应value，否则返回0
      }
 List<Map.Entry<String,Integer>> list2=new ArrayList<>(map.entrySet());  //也可写map.values(),排序后找map.getVaule==list.get(1)
 Collections.sort(list2,(o1,o2)->o2.getValue().compareTo(o1.getValue())); //不可以直接排map。归并排序,此排序是稳定的。Arrays.sort()使用的是快排,是不稳定的.
       for(int i=0;i<8;++i){
          String key=list2.get(i).getKey();
           int index = key.indexOf(' ');
           if(index>16) key=key.substring(index-16);
           System.out.println(key+" "+list2.get(i).getValue());
       }
    }
}
（1）按输入顺序：用linkedHashMap
map按Key排序用TreeMap，key倒叙：Map<String, Integer> map = new TreeMap<>((s1, s2) -> s2.compareTo(s1));
（2）之后map按value排序：
 List<Map.Entry<String,Integer>> list2=new ArrayList<>(map.entrySet());
 Collections.sort(list2,(o1,o2)->o2.getValue().compareTo(o1.getValue())); //不可以直接排map

也可以用大根堆： PriorityQueue<Integer> max=new PriorityQueue<>((a,b)->b[0]-a[0]); //add/offer,remove/poll,   //不写默认小根堆
Queue 中 remove() 和 poll()
二维数组排序：Arrays.sort(arr,(a,b)->b[0]-a[0]);		//用减法可能会有溢出的情况，用 (a,b)-> a[0]<b[0] ? -1 : 1
 			Arrays.sort(envelopes,(o1,o2)-> {
                if (o1[0] != o2[0]) return o1[0] - o2[0];
                else   return o1[1] - o2[1];});

//value算个数，merge方法要快
for(int n:nums){
  map.merge(n, 1, Integer::sum);// map.put(n,map.getOrDefault(n,0)+1);
} 
```

### 多重集合和映射

#### 332 重新安排行程*

给定一个人坐过的一些飞机的起止机场，已知这个人从 JFK 起飞，那么这个人是按什么顺序飞的；如果存在多种可能性，返回字母序最小的那种。

题解：欧拉图就是从任意一个点开始都可以一笔画完整个图，半欧拉图必须从某个点开始才能一笔画完整个图。欧拉通路：通过图中所有边恰好一次且行遍所有顶点的通路.

先用哈希表记录起止机场，其中键是起始机场，值是一个多重集合，表示对应的终止机场。因为一个人可能坐过重复的线路，所以我们需要使用多重集合储存重复值。还要将结果逆序得到从起点到终点的顺序。

如果第一个访问的节点是 “孤岛节点”，他会出现在结果集的最后。当我们顺序读取结果集时，这种 “孤岛节点” 是最后遇到的，是图遍历的终点，这样就没有问题了

<img src="/image-20220315092029417.png" alt="image-20220315092029417" style="zoom:80%;" />

```java
 Map<String,PriorityQueue<String>> map=new HashMap<>();  //默认字典排序
    List<String> res=new ArrayList<>();
    public List<String> findItinerary(List<List<String>> tickets) {
        for(List<String> t:tickets){
            PriorityQueue<String> p=map.getOrDefault(t.get(0),new PriorityQueue<>());
            p.offer(t.get(1));
            map.put(t.get(0),p);
        }
        dfs("JFK");
        return res;
    }
    public void dfs(String start){
        PriorityQueue<String> strs=map.get(start);	//相邻的下个节点
        while(strs!=null&&!strs.isEmpty()){  //不用for,strs可能为null
             dfs(strs.poll());  //遍历过就移除，
        }
        res.add(0,start);
    }
```

### 前缀和积分和

一维的前缀和，二维的积分图，都是把每个位置之前的一维线段或二维矩形预先存储，方便加速计算。如果需要对前缀和或积分图的值做寻址，则要存在哈希表里；如果要对每个位置记录前缀和或积分图的值，则可以储存到一维或二维数组里，也常常伴随着动态规划

#### 304 二维区域和检索-矩阵不可变

设计一个数据结构，使得其能够快速查询给定矩阵中，任意两个位置包围的长方形中所有数字的和

![image-20220315103023931](/image-20220315103023931.png)

![image-20220315103049608](/image-20220315103049608.png)

```java
	int[][] sum;
    public NumMatrix(int[][] matrix) {
        int row=matrix.length,col=matrix[0].length;
        sum=new int[row+1][col+1];  //方便计算+1
        for(int i=1;i<=row;++i){
            for(int j=1;j<=col;++j){
                sum[i][j]=sum[i-1][j]+sum[i][j-1]+matrix[i-1][j-1]-sum[i-1][j-1];//dp方程，注意matrix下标-1
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return sum[row2+1][col2+1]-sum[row2+1][col1]-sum[row1][col2+1]+sum[row1][col1];
    }
```

#### 560 和为k的子数组***

给定一个数组，寻找和为 *k* 的连续子数组的个数。

题解：前缀和+hashmap

由于只关心次数，不关心具体的解，我们可以使用哈希表加速运算，其键是前缀和，而值是该前缀和出现的次数。在我们遍历到位置 i 时，假设当前的前缀和是 psum，那么 hashmap[psum-k] 即为以当前位置结尾、满足条件的区间个数

此题可以延伸到 树的路径和个数，也可用此方法，对比路径总和，这题也可用递归。若是求子数组最大和，则是用动态规划

```java
 //每次都求两个下标之间的和,超时
    public int subarraySum3(int[] nums, int k) {
        int len = nums.length,res=0,sum=0;
        for (int r= 0; r < len; r++) {
            for (int l = 0; l <= r; l++) {
                sum = 0;
                for (int i = l; i <= r; i++) {
                    sum += nums[i];
                }
                if (sum == k)  res++;
            }
        }
        return res;
    }
    //前缀和+hashmap，类似两数之和，这是两数之差，21ms
    public int subarraySum(int[] nums, int k) {
        int len=nums.length,sum=0,res=0;
        Map<Integer,Integer> map=new HashMap<>();
        map.put(0,1);  //重要，前缀和刚好等于k也要记录
        for(int n:nums){
            sum+=n;
            if(map.containsKey(sum-k)) res+=map.get(sum-k);
            map.put(sum,map.getOrDefault(sum,0)+1);
        }
        return res;
    }
```



## 字符串

#### 5 Z字形变换

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列存储。输出时需要从左往右逐行输出

<img src="/image-20220408124907961.png" alt="image-20220408124907961" style="zoom: 33%;" />

```java
public String convert(String s, int numRows) {
        if(numRows==1) return s;
        StringBuilder[] arr=new StringBuilder[numRows];
        for(int i=0;i<numRows;++i){
            arr[i]=new StringBuilder(); //初始化
        }
        int i=0,flag=-1;
        for(char c:s.toCharArray()){
            arr[i].append(c);
            if(i==0||i==numRows-1) flag=-flag;   //i++或i--由flag决定
            i=i+flag;
        }
        StringBuilder sb=new StringBuilder();
        for(StringBuilder a:arr){
            sb.append(a);
        }
        return sb.toString();
    }
```

#### 65 有效数字

**有效数字**可以分成两个部分：一个 **小数** 或者 **整数**；（可选）一个 `'e'` 或 `'E'` ，后面跟着一个 **整数**，示例：

1. true ：".1" "-.1" "1." " 005047e+6""46.e3" ".2e81"

2. false："." "+e" "+3. e04116"

   题解：判断好 点、+ -、e 三者的前后面必须有什么, 不能有什么

```java
public boolean isNumber(String s) {
        boolean digitFlag=false;  //是否是有效数字
        boolean dotFlag=false;   //是否有.
        boolean eFlag=false;
        for(int i=0;i<s.length();++i){
            char c=s.charAt(i);
            if(!isValid(c)) return false;
            if(isE(c)){          //是e,只能有一个e，e前后都要有数字
                if(eFlag||!digitFlag) return false;
                eFlag=true;
                digitFlag=false;  //后面要有数字
            }else if(isSymbol(c)){  //是+-,后面要有数字,不是第一个时前面要是e
                if(i>0&&!isE(s.charAt(i-1))) return false;
                digitFlag=false;
            }else if(isDot(c)){   //是.,只能一个.,前面不能有e,(左右至少一个数字，由是e或者是数字的时候保证了)
                if(dotFlag||eFlag) return false;
                dotFlag=true;
            }else{        
                digitFlag=true;
            }
        }
        return digitFlag;
    }
    public boolean isDigit(char c){return c>='0'&&c<='9';}
    public boolean isDot(char c){return c=='.';}
    public boolean isE(char c){return c=='e'||c=='E';}
    public boolean isSymbol(char c){return c=='+'||c=='-';}
    public boolean isValid(char c){return isDigit(c)||isDot(c)||isE(c)||isSymbol(c);}
```

#### 205 同构字符串

给定两个字符串 s 和 t ，判断它们是否是同构的。同构： s 中的字符可以按某种映射关系替换得到 t ，不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上。

题解：如果两个字符串中相同位置的字符与它们第一次出现的位置一样，那么这两个字符串同构。举例来说，对于“paper”和“title”，假设我们现在遍历到第三个符“p”和“t”，发现它们第一次出现的位置都在第一个字符，则说明目前位置满足同构

```java
//一个map一个判断则e->r,b->r不满足题意。一个map两个判断，则表示相互一一对应,即e->r,r->e。但题目可以e->r,l->e,34ms
    public boolean isIsomorphic2(String s, String t) {
        if(s.length()!=t.length()) return false;
        Map<Character,Character> map=new HashMap<>();
        Map<Character,Character> map2=new HashMap<>();
        for(int i=0;i<s.length();++i){
            if(map.containsKey(s.charAt(i))&&map.get(s.charAt(i))!=t.charAt(i)) return false;
            if(map2.containsKey(t.charAt(i))&&map2.get(t.charAt(i))!=s.charAt(i)) return false;
            map.put(s.charAt(i),t.charAt(i));
            map2.put(t.charAt(i),s.charAt(i));
        }
        return true;
    }
    //10ms
    public boolean isIsomorphic(String s, String t) {
        if(s.length()!=t.length()) return false;
        for(int i=0;i<s.length();++i){
        if(s.indexOf(s.charAt(i))!=t.indexOf(t.charAt(i))) return false;
        }        
        return true;
    }

```

#### 647 回文子串**

给定一个字符，求其有多少个回文子字符串。回文指正序和倒序读都是一样的，即左右对称

题解：解法同第5题最长回文串，可以用中心扩展法：从字符串的每个位置开始，向左向右延长，判断存在多少以当前位置为中轴的回文子字符串。

```java
 //中心扩展法,2ms
    int sum,len;
    public int countSubstrings2(String s) {
        len=s.length();
        for(int i=0;i<len;++i){
            sum+=extend(s,i,i); //奇数长度
            sum+=extend(s,i,i+1); //偶数长度
        }
        return sum;
    }
    public int extend(String s,int l,int r){
        int cnt=0;
        while(l>=0&&r<len&&s.charAt(l)==s.charAt(r)){
            l--;
            r++;
            cnt++;
        }
        return cnt;
    }
    //动态规划，长度为1是回文串，长度为2相等才是，长度大于2看dp[i+1][j-1]是才是，9ms
    public int countSubstrings(String s) {
        len=s.length();
        boolean[][] dp=new boolean[len][len];
        for(int j=0;j<len;++j){    //注意遍历顺序
            for(int i=0;i<=j;++i){  //等于！
                if(s.charAt(j)==s.charAt(i)&&(j-i<2||dp[i+1][j-1])){//后面两条件不能交换，会越界
                    dp[i][j]=true;
                    sum++;
                }
            }
        }
        return sum;
    }
```

##### 125 验证回文串

只考虑字母和数字字符，可以忽略字母的大小写。

输入: "A man, a plan, a canal: Panama"
输出: true  （"amanaplanacanalpanama" 是回文串）

题解：验证单个的话可以从两边开始向内扩展

```java
	int len;
    public boolean isPalindrome(String s) {
        s=s.toLowerCase();
        StringBuilder sb=new StringBuilder();
        for(char c:s.toCharArray()){
            if(c>='0'&&c<='9'||c>='a'&&c<='z') sb.append(c);
        }
        len=sb.length();
        return extend(sb,0,len-1); //>>和&运算级比+-低，要括号
    }
    public boolean extend(StringBuilder sb,int l,int r){
        while(r>=l&&sb.charAt(l)==sb.charAt(r)){
            l++;
            r--;
        }
        return l>=r;
    }
```

##### 131 分割回文串***

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。`1 <= s.length <= 16`

题解：`path` 的操作只在列表的末端，因此合适的数据结构是栈，Deque

```java
    int len;
    List<List<String>> res=new ArrayList<>();
    Deque<String> path=new ArrayDeque<>();
    public List<List<String>> partition2(String s) {
        len=s.length();
        dfs(s,0);
        return res;
    }
    public void dfs(String s,int begin){
        if(begin==len){ 
            res.add(new ArrayList<>(path));
        }
        for(int i=begin;i<len;++i){
            if(extend(s,begin,i)){
                path.addLast(s.substring(begin,i+1)); //path.push(s.substring(begin,i+1));
                dfs(s,i+1);
                path.removeLast(); //path.pop();
            }
        }
    }
    public boolean extend(String s,int l,int r){
        while(l<r&&s.charAt(l)==s.charAt(r)){
            l++;
            r--;
        }
        return l>=r;
    }
    //可以先采用动态规划预处理，把回文子串的结果记录在一个表格里
     public List<List<String>> partition(String s) {
         len=s.length();
         boolean[][] dp=new boolean[len][len];
         for(int j=0;j<len;++j){
             for(int i=0;i<=j;++i){
                 if(s.charAt(i)==s.charAt(j)&&(j-i<2||dp[i+1][j-1])) dp[i][j]=true;
             }
         }
        dfs(s,dp,0);
        return res;
     }
     public void dfs(String s,boolean[][] dp,int begin){
         if(begin==len) {
             res.add(new ArrayList<>(path));
         }
         for(int i=begin;i<len;++i){
             if(dp[begin][i]){
                 path.addLast(s.substring(begin,i+1));
                 dfs(s,dp,i+1);
                 path.removeLast();
             }
         }
     }
```

##### 132 分割回文串Ⅱ***

请你将 `s` 分割成一些子串，使每个子串都是回文。返回符合要求的 **最少分割次数** ,`1 <= s.length <= 2000`

题解：对于一个区间内的字符串来说，每一个位置都将是可能的分割点，可用暴力递归的时间复杂度太高，加上预处理回文数组能勉强通过。 换个角度想想，当切割次数最少使得切割后的所有字符串都是回文时，也正是这些回文子串最长的时候，那么如果说能找到以每个字符为中心的最长回文串，实际上就已经找到了答案

dp[j]=Math.min(dp[j]，dp[i-1]+1)，dp含义：到 j 位置最少分割次数。和最长递增序列题类似，不过那题是向 j 靠拢更新，这题是向外扩展更新

```java
 	int len;
    public int minCut(String s) {
        len=s.length();
        int[] dp=new int[len];
        Arrays.fill(dp,len-1);
        for(int i=0;i<len;++i){
            extend(s,dp,i,i);
            extend(s,dp,i,i+1);
        }
        return dp[len-1];
    }
    public void extend(String s,int[] dp,int l,int r){
        while(l>=0&&r<len&&s.charAt(l)==s.charAt(r)){
            dp[r]=Math.min(dp[r],l==0?0:dp[l-1]+1);
            l--;
            r++;
        }
    }
```

#### 696 计数二进制字串**

给定一个 0-1 字符串，求有多少非空子字符串的 0 和 1 数量相同

题解：从左往右遍历数组，记录和当前位置数字相同且连续的长度，以及其之前连续的不同数字的长度。若之前不同数字的连续长度大于等于当前数字的连续长度，则说明存在一个以当前数字结尾的满足条件的子字符串

<img src="/image-20220319123508793.png" alt="image-20220319123508793" style="zoom:50%;" />

```java
//中心扩展法，14ms
    int len=0,sum=0;
    public int countBinarySubstrings(String s) {   
        len=s.length();    
        if(len<2) return 0;
        for(int i=0;i<len;++i){
            sum+=extend(s,i,i+1);
        }
        return sum;
    }
    public int extend(String s,int l,int r){
        int cnt=0;
        if(r<len&&s.charAt(l)=='0'&&s.charAt(r)=='1'){
            while(l>=0&&r<len&&s.charAt(l)=='0'&&s.charAt(r)=='1'){
                l--;
                r++;
                cnt++;
            }
        }else if(r<len&&s.charAt(l)=='1'&&s.charAt(r)=='0'){
            while(l>=0&&r<len&&s.charAt(l)=='1'&&s.charAt(r)=='0'){
                l--;
                r++;
                cnt++;
             }
        } 
        return cnt;
    }
    //9ms
    public int countBinarySubstrings2(String s) {
        len=s.length();
        int pre=0,cur=1;
        for(int i=1;i<len;++i){
            if(s.charAt(i)==s.charAt(i-1))  cur++;
            else{
                pre=cur;
                cur=1;
            } 
            if(pre>=cur) sum++;   //等于
        }
        return sum;
    }
```

#### 30 串联所有单词的子串

```

```

#### 38 外观数列

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

1. 1

2. 11

3. 21

4. 1211

5. 111221           一 个 1 + 一 个 2 + 二 个 1 

   题解：将字符的统计数目再连接上对应的字符

```java
 public String countAndSay(int n) {
       if(n==1) return "1";
       String s="1";
       for(int i=2;i<=n;++i){
           StringBuilder sb=new StringBuilder();
           int len=s.length();          
           int l=0;
           int r=0;
            while(r<len){
                char c=s.charAt(l);
                while(r<len && c==s.charAt(r)){
                    r++;
                }
                sb.append(r-l).append(c);      
                l=r;
            }
            s=sb.toString();
       }
       return s;
    }
```

#### 58 最后一个单词长度

单词前后用一些空格字符隔开。返回字符串中 **最后一个** 单词的长度。**单词** 是指仅由字母组成、不包含任何空格字符的最大子字符串

```java
//也可以用s.split(" ")
    public int lengthOfLastWord(String s) {
        int len=s.length(),res=0;
        for(int i=len-1;i>=0;--i){
            if(s.charAt(i)==' '&&res==0) continue;
            if(s.charAt(i)==' '&&res!=0) return res;
            res++;  
        }
        return res;
    }
```

#### 76最小覆盖字串***

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"

题解：map+滑动窗口，一个哈希表表示 t 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 t 的哈希表中的所有字符，并且对应的个数都不小于 t 的哈希表中各个字符的个数，那么当前的窗口是「可行」的

滑动窗口：r 先走，在找最小/大的 l++

```java
 public String minWindow(String s, String t) {
        Map<Character,Integer> ms=new HashMap<>();
        Map<Character,Integer> mt=new HashMap<>();
        int lens=s.length(),lent=t.length();
        if(lens<lent) return "";
        for(int i=0;i<lent;++i){
            mt.put(t.charAt(i),mt.getOrDefault(t.charAt(i),0)+1);
        }
        int l=0,r=0,len=Integer.MAX_VALUE,idx=-1;
        while(r<lens){
            if(mt.containsKey(s.charAt(r))) ms.put(s.charAt(r),ms.getOrDefault(s.charAt(r),0)+1);
            while(l<=r&&check(ms,mt)){
                if(mt.containsKey(s.charAt(l))) ms.put(s.charAt(l),ms.get(s.charAt(l))-1);
                if(len>r-l+1){
                    len=r-l+1;
                    idx=l;
                }
                l++;
            }
            r++;
        }
        return idx==-1?"":s.substring(idx,idx+len);
    }
    public boolean check(Map<Character,Integer> ms,Map<Character,Integer> mt){
        for(Map.Entry<Character,Integer> e:mt.entrySet()){
            if(ms.getOrDefault(e.getKey(),0)<e.getValue()) return false;
        }
        return true;
    }
```

##### 242 有效字母异位词

判断两个字符串包含的字符是否完全相同

题解：只含小写字母，用26位数组表示字母频率

```java
//用36位数组代替hash表
public boolean isAnagram(String s, String t) {
        int[] arr=new int[26];
        if(s.length()!=t.length()) return false;
        for(int i=0;i<s.length();++i){
            arr[s.charAt(i)-'a']++;
            arr[t.charAt(i)-'a']--;
        }
        for(int i=0;i<26;++i){
            if(arr[i]!=0) return false;
        }
        return true;
    }
//方法二：用Arrays.sort(ch);排序每个字符串的字母，排好后用hashset判断是否相同
//若是判断s1中是否有个字串是s2的异位词，用两个hashmap分别装起来，遍历s2看s1中的对应字母是否大于等于s1的
```

##### 438 找到字符串中所有字母异位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引

题解：异位词长度相同，所以我们可以在字符串 s 中构造一个长度为与字符串 p 的长度相同的滑动窗口

```java
	List<Integer> res=new ArrayList<>();
    int[] arr;
    public List<Integer> findAnagrams(String s, String p) {
        int plen=p.length(),slen=s.length(),l=0,r=plen;
        if(plen>slen) return res;
        arr=new int[26];
        for(int i=0;i<plen;++i){
            arr[p.charAt(i)-'a']++;
        }
        while(r<slen+1){
            helper(s.substring(l,r),l);
            l++;r++;
        }
        return res;
    }
    public void helper(String s,int idx){
        int[] ans=Arrays.copyOfRange(arr,0,arr.length);
        boolean flag=false;
        for(int i=0;i<s.length();++i){
            ans[s.charAt(i)-'a']--;
        }
        for(int i:ans){
            if(i!=0) flag=true;
        }
        if(!flag) res.add(idx);
    }
```

##### 49 字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

```java
 public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map=new HashMap<>();
        for(String s:strs){
            char[] ch=s.toCharArray();
            Arrays.sort(ch);
            String key=String.valueOf(ch);
            if(!map.containsKey(key)) map.put(key,new ArrayList<>());
            map.get(key).add(s);
        }
        return new ArrayList<>(map.values());
    }
```



## 链表

是删除/添加 节点时，尽量处理当前节点的下一个节点而非当前节点本身，或建立一个虚拟节点 头节点，使其指向当前链表的头节点

#### 206 翻转链表

翻转一个链表

<img src="/image-20220321094417700.png" alt="image-20220321094417700" style="zoom:50%;" />

递归：

<img src="/image-20220321100915271.png" alt="image-20220321100915271" style="zoom:50%;" />

```java
//虚拟头节点法，三个节点
    public ListNode reverseList2(ListNode head) {
        ListNode h=new ListNode(-1),cur=head,tem;
        while(cur!=null){
            tem=cur.next;
            cur.next=h.next;
            h.next=cur;
            cur=tem;
        }
        return h.next;
    }
    //迭代法,三个节点
    public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode pre=null,cur=head,nex;
        while(cur!=null){
            nex=cur.next;  //下个节点写在前记录
            cur.next=pre;
            pre=cur;
            cur=nex;
        }
        return pre;
    }
    //递归
    public ListNode reverseList3(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode pre=reverseList(head.next);
        head.next.next=head;
        head.next=null;
        return pre;
    }
```

#### 92 翻转链表Ⅱ

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请反转从位置 left 到 right 的链表节点

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode h=new ListNode(-1);h.next=head;
        ListNode l=h,pre=null,cur,nex;
        int i=left;
        while(i>1){   //遍历到前一个节点并标记
            l=l.next;
            i--;
        }
        cur=l.next;
        while(right>=left){   //翻转
            nex=cur.next;
            cur.next=pre;
            pre=cur;
            cur=nex;
            right--;
        }
        l.next.next=cur;
        l.next=pre;
        return h.next;
    }
```

#### 24 两两交换链表中节点*

给定一个矩阵，交换每个相邻的一对节点。

<img src="/image-20220321113801871.png" alt="image-20220321113801871" style="zoom:67%;" />

```java
public ListNode swapPairs(ListNode head) {
        ListNode h=new ListNode(-1),tem=h,n1=null,n2=null;
        h.next=head;
        while(tem.next!=null&&tem.next.next!=null){
            n1=tem.next;
            n2=tem.next.next;
            tem.next=n2;
            n1.next=n2.next;   //在前
            n2.next=n1;
            tem=n1;  //不是n2,因为n1和n2交换了
        }   
        return h.next;
    }
```

#### 25 K个一组翻转链表

给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表

<img src="/image-20220418203424159.png" alt="image-20220418203424159" style="zoom:67%;" />

```java
 public ListNode reverseKGroup(ListNode head, int k) {
        if(k==1||head.next==null) return head;
        ListNode h=new ListNode(-1),cur=h,pre=h,tem,l;
        h.next=head;
        while(cur!=null){
            for(int i=0;i<k&&cur!=null;++i){
                cur=cur.next;
            }
            if(cur==null) break;
            l=pre.next;
            tem=cur.next;
            cur.next=null;
            pre.next=reverse(l);
            l.next=tem;
            cur=l;
            pre=l; 
        }
        return h.next;
    }
    public ListNode reverse(ListNode head){
       ListNode cur=head,pre=null,tem;
       while(cur!=null){
           tem=cur.next;
            cur.next=pre;     
            pre=cur;      
            cur=tem;   
       }
       return pre;
    }
```

#### 86 分割链表

给一个链表的头节点 head 和一个特定值 x ，请对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。保留 两个分区中每个节点的初始相对位置

<img src="/image-20220524093740441.png" alt="image-20220524093740441" style="zoom:50%;" />

```java
public ListNode partition(ListNode head, int x) {
        ListNode h1=new ListNode(-1),h2=new ListNode(-1),n1=h1,n2=h2;
        while(head!=null){
            if(head.val<x){
                n1.next=head;
                head=head.next;
                n1=n1.next;
                n1.next=null;   //h与h1的连接剪断
            }else {
                n2.next=head;
                head=head.next;
                n2=n2.next;
                n2.next=null;
            }
        }
        n1.next=h2.next;
        return h1.next;
    }
```

#### 61 旋转链表

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

题解：先遍历求得链表总长度count，同时将链表首尾相连；再找到原链表的倒数第k+1个节点，该节点的next就是新链表的头结点。

```java
public ListNode rotateRight(ListNode head, int k) {
        if(head==null||head.next==null||k==0) return head;
        ListNode tem=head,newH;
        int cnt=1;
        //计数并使tem到链表尾
        while(tem.next!=null){
            cnt++;
            tem=tem.next;
        }
        k%=cnt;
        if(k==0) return head; //不需要旋转
        //首尾相连
        tem.next=head;
        for(int i=0;i<cnt-k;++i){
            tem=tem.next;
        }
        newH=tem.next;
        tem.next=null;  //断首尾
        return newH;
    }
```

#### 83 删排序链表的重复元素

给定一个已排序的链表的头 `head` ， 删除原始链表中所有重复数字的节点。

题解：有序的重复的节点一点相邻

```java
public ListNode deleteDuplicates(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode cur=head;   //不能直接用head节点，head用来返回
        while(cur.next!=null){   //到最后一个元素不用操作
            if(cur.val==cur.next.val) cur.next=cur.next.next;  
            else cur=cur.next;     //要有else，删除后不能马上后移
        }
        return head;
    }
```

##### 82 删排序链表的重复元素Ⅱ*

不同的数字 。如：1->4->4->5 变成  1->5

```java
public ListNode deleteDuplicates(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode cur=head,h=new ListNode(-1),pre=h;//虚拟节点防止删除head节点情况
        pre.next=head;
        while(cur!=null&&cur.next!=null){  //[1,1]
            if(cur.val==cur.next.val){
                while(cur.next!=null&&cur.val==cur.next.val) cur.next=cur.next.next;
                pre.next=cur.next;
                cur=pre.next;
            }else{
                pre=cur;
                cur=cur.next;
            }
        }
        return h.next;
    }
```

#### 138 复制带随机指针的链表*

要求 深拷贝

![image-20220620110611371](/image-20220620110611371.png)

题解：使用hash存储原结点和克隆结点的映射关系，通过映射关系处理克隆结点的random指针

```java
 public Node copyRandomList(Node head) {
        Map<Node,Node> map=new HashMap<>(); // 使用hash表存储旧结点和新结点的映射
        Node cur=head;
        while(cur!=null){
            map.put(cur,new Node(cur.val,null,null));
            cur=cur.next;
        }
        cur=head;
        while(cur!=null){
            map.get(cur).next=map.get(cur.next);
            map.get(cur).random=map.get(cur.random);
            cur=cur.next;
        }
        return map.get(head);
    }
```

#### 146 LRU算法**

设计一个固定大小的，最近最少使用缓存：将信息插入缓存或查找一个缓存内存在的信息的时候，将该信息标为最近使用。在缓存满的情况下还需要移除最旧的信息。

题解：哈希表查找快（O(1)） ，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 `LinkedHashMap`

<img src="/image-20220330143922499.png" alt="image-20220330143922499" style="zoom:50%;" />

为什么用双向链表？操作某个节点时（删除移到头），map 以O(1)要找到那个节点，此时还要找到前一个节点才能删除，单向链表要遍历一次找到，而双向链表不用，因为每个节点会记录之前的节点。

双向链表的节点为什么要存一组key-value，只存value不行？map 满了时删除最后一个节点，map里key-value 还要通过最后一个Node里的key来删除，hashmap无法通过value来remove。先删map中的再删链表

<img src="/image-20211001182951392-1648621170877.png" alt="image-20211001182951392" style="zoom: 50%;" />

```java
class LRUCache {
    int size;
    Map<Integer,Node<Integer,Integer>> map;
    Node tail,head;    //加上头尾节点
    public LRUCache(int capacity) {
        size=capacity;
        map=new HashMap<>();
        head=new Node();   //注意要初始化
        tail=new Node();
        head.next=tail;
        tail.pre=head;
    }
    public int get(int key) {
        Node n=map.get(key);
        if(n==null) return -1;
        remove(n);
        addToHead(n);
        return (int)n.val;
    }
    public void put(int key, int value) {
        Node n=map.get(key);
        if(n!=null){
            n.val=value;  //值更新
            remove(n);
            addToHead(n);
        }else{
            Node tem=new Node(key,value);
            addToHead(tem);
            map.put(key,tem);
            if(map.size()>size){  //先添加后删除否则会空指针，若容量为零情况              
                map.remove(tail.pre.key);  //记得还要移除map中的
                remove(tail.pre);       //注意，这行写在下面，要不然tail.pre变了
            }          
        }
    }
    public void addToHead(Node node){   //采用头插法，添加到头节点
        head.next.pre=node;
        node.next=head.next;
        head.next=node;   //写在上面两句后
        node.pre=head;
    }
    public void remove(Node node){ //两个顺序可换
        node.pre.next=node.next;  //等号前面的表示箭头指向，后面的表示节点，node.next还没变
        node.next.pre=node.pre;   
    }
    class Node<K,V>{   //支持泛型，此题也可不写，明确是int
        K key;
        V val;
        Node pre;
        Node next;
        public Node(){}
        public Node(K key,V val){
            this.key=key;   //注意，局部和全局相同时要用this区别
            this.val=val;
        }
    }
}
//java的API，LinkedHashMap
public class Solution {
    public int[] LRU (int[][] operators, int k) {  //传入操作链表的二维数组
        ArrayList<Integer> list=new ArrayList<>();  
        A a=new A(k);
        for(int i=0;i<operators.length;++i){
            if(operators[i][0]==1){
                 a.set(operators[i][1],operators[i][2]); 
            } else{
                list.add(a.get(operators[i][1]));
            }                          
        }
       Integer[] aa= list.toArray(new Integer[list.size()]); //不能直接转为int数组
        int[] arr=Arrays.stream(aa).mapToInt(Integer::valueOf).toArray(); //将包装类数组转化为原生数组
        return arr;
    }   
  class A extends LinkedHashMap<Integer,Integer>{
    private int capacity;
    public A(int capacity){
        super(capacity,0.75F,true);  //容量，负载因子，true 访问顺序/false 插入顺序
        this.capacity=capacity;
    }     
    @Override
   protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return super.size() > capacity;
    } 
      public int get(int key){return super.getOrDefault(key,-1);}
      public void set(int key,int value){ super.put(key,value);}
   }  
}
```

#### 小美的代金券*

系统把代金券打乱顺序排成一排，如果存在相邻的两个代金券金额相等，设其面额为x，则将这两张代金券兑换一张为x+1的代金券并放在原来两张券的位置上

输入：第一行一个正整数n，表代金券数量。(1<=n<=500)。第二行n个正整数，每个整数x表示一张代金券的面额，同时也是系统排出的代金券顺序(1<=x<=100)

输出：输出仅包含一个整数，表示最多可以兑换

```java
public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        Node head=new Node(-1);
        Node tem=head;  //临时，不用head直接
        while(sc.hasNext()){
            tem.next=new Node(sc.nextInt());
            tem=tem.next;
        }
        Node cur=null;
        int res=0;
        boolean flag=true;
        while(true){   //多次遍历，有可能前一位的和当前的相等了
            cur=head.next;  //重置
            flag=true;
            while(cur.next!=null){  //一次遍历
                if(cur.value==cur.next.value){
                    cur.value++;
                    cur.next=cur.next.next;
                    res++;
                    flag=false;
                }else{
                 cur=cur.next;   
                }            
            }
            if(flag==true) break;  //没有兑换的一趟可退出了
        }
        System.out.println(res);
}
```

#### 不给表头情况下删除指定节点

若是双链表，有pre节点，可以找到前个节点，直接删

若是单向链表，删除的是尾节点，则不能删除。若删除的是其他节点：

```java
public void deleteNode(Node node){
    if(node==null||node.next==null) return;
    node.val=node.next.val;
    node.next=node.next.next;
}
```



### 双指针

#### 160 相交链表**

给定两个链表，判断它们是否相交于一点，并求这个相交节点

题解：走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路

<img src="/image-20220321154037804.png" alt="image-20220321154037804" style="zoom:50%;" />

两个指针并以相同的速度前进，若到达链表结尾，则移动到另一条链表的头节点继续前进。最终两个指针会在 a+ b+ c 路程相交于交点

```java
//暴力，双层循环，700ms
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode n1=headA,n2=headB;
        while(n1!=null){
            n2=headB;
            while(n2!=null&&n1!=n2){
                n2=n2.next;
            }
            if(n1==n2) break;
            n1=n1.next;
        }        
        if(n1==null||n2==null) return null;
        return n1;
    }
    //1ms
    public ListNode getIntersectionNode2(ListNode headA, ListNode headB) {
        ListNode n1=headA,n2=headB;
        while(n1!=n2){          //地址相等
            n1=n1!=null?n1.next:headB;   //不是n2.next
            n2=n2!=null?n2.next:headA;
        }        
        return n1;
    }
```

### 快慢指针

#### 19 删除链表倒数第n个节点

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode newHead=new ListNode(-1);  //解决删除头节点的情况
        newHead.next=head;
        ListNode slow=newHead,fast=newHead;      
        for(int i=0;i<n;++i){
            fast=fast.next;
           // if(fast==null) return head;  //题目要求了n<=sz
        }
        while(fast.next!=null){
            fast=fast.next;
            slow=slow.next;    
        }
        slow.next=slow.next.next;
        return newHead.next;
    }
```

#### 234 回文链表**

以 *O*(1) 的空间复杂度，判断链表是否回文

题解：使用快慢指针找到链表中点，可在快慢指针过程中就翻转前半段，最后比较两半是否相等。

```java
public boolean isPalindrome(ListNode head) {
		if(head==null||head.next==null) return true;
        ListNode slow=head,fast=head,pre=null,nex;
        while(fast!=null&&fast.next!=null){   //奇数slow在中间，偶数slow在中右
            fast=fast.next.next;
            nex=slow.next;   //以下四句翻转链表,且slow=slow.next
            slow.next=pre;
            pre=slow;
            slow=nex;
        }
        if(fast!=null) slow=slow.next;   //奇数个时，不用fast.next==null,会空指针
        while(pre!=null){
            if(pre.val!=slow.val) return false;
            pre=pre.next;
            slow=slow.next;
        }
        return true;
    }
```

#### 141 环形链表

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

题解：fast走的路程是slow的两倍。

<img src="/image-20211013140805837.png" alt="image-20211013140805837" style="zoom:67%;" />

```java
public ListNode detectCycle(ListNode head) {
    ListNode slow=head,fast=head;
    while(fast!=null&&fast.next!=null){  //&&fast!=low 条件不加在这
        fast=fast.next.next;
        slow=slow.next;
        if(slow==fast) break;
    }
    if(fast==null||fast.next==null) return null;  //无环
    slow=head;
    while(fast!=slow){
        fast=fast.next;
        slow=slow.next;
    }
    return slow;
}
//可以用HashSet做，看看节点是不是同一个
```

#### 143 重排链表**

L0 → L1 → … → Ln - 1 → Ln  变为 L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …

题解：1、快慢指针找到中间节点	2、反转后半段链表	3、合并前半段链表和后半段链表

```java
 public void reorderList(ListNode head) {
        ListNode fast=head,slow=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        ListNode reverseHead=reverse(slow.next); //翻转后半段链表
    	slow.next=null;  //断开
       //间隙插入
        ListNode cur=head,curNex,reverseHeadNex;
        while(cur!=null&&reverseHead!=null){
            reverseHeadNex=reverseHead.next;
            curNex=cur.next;
            cur.next=reverseHead;
            reverseHead.next=curNex;
            cur=curNex;
            reverseHead=reverseHeadNex;
        }
    }
    public ListNode reverse(ListNode reverseHead){
        ListNode pre=null,nex;
        while(reverseHead!=null){
            nex=reverseHead.next;
            reverseHead.next=pre;
            pre=reverseHead;
            reverseHead=nex;
        }
        return pre;
    }
```

#### 287 寻找重复数

数组中的数字都是在 1 到 n 之间的，假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

题解：可以使用数组配合下标，抽象成链表问题，并使用快慢指针。

[1,3,4,2,2] ，数组下标 `n` 和数 `nums[n]` 建立一个映射关系：

0->1
1->3
2->4
3->2
4->2

按 i=nums[i] 方式去遍历，0->1->3->2->4->2->4->2->…… 有重复数字的出现, 所以这个游走必然是成环的

```java
public int findDuplicate(int[] nums) {
        int slow=0,fast=0;
        while(true){
            slow=nums[slow];
            fast=nums[nums[fast]];
            if(slow==fast) break;
        }
        slow=0;
        while(slow!=fast){
            slow=nums[slow];
            fast=nums[fast];
        }
        return slow;
    }
```

##### 565 嵌套数组**

数组 A 包含`0`到`N - 1`的所有整数。找到最长的集合`S`并返回其大小，其中 `S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }`

题解：至少存在一个环，而问题本质是求所有环的最大长度。

<img src="/image-20220728154552534.png" alt="image-20220728154552534" style="zoom:80%;" />

```java
public int arrayNesting(int[] nums) {
        int len = nums.length, ans = 0;
        boolean[] v=new boolean[len];
        for (int i = 0; i < len; i++) {
            int cur = i, cnt = 0;
            while (!v[cur]) {    //没访问过
                cnt++;
                v[cur]=true;
                cur = nums[cur];
            }
            ans = Math.max(ans, cnt);
        }
        return ans;
    }
```

### 分治法

#### 23 合并 k 个升序链表**

给定 *k* 个增序的链表，试将它们合并成一条增序链表

题解：前提是每个链表都已排序好可直接用归并

```java
 //分治/归并排序,1ms
    public ListNode mergeKLists2(ListNode[] lists) {
        int len=lists.length;
        if(len==0) return null;
        // ListNode res = lists[0];
		// for(int i=1;i<lists.length;i++) {
		// 	res = merge(res,lists[i]);
		// }
        return recursion(lists,0,len-1);
    }
    public ListNode recursion(ListNode[] lists,int l,int r){  //加个二分会快一点
        if(l==r) return lists[l];
        int mid=(l+r)>>1;
        ListNode n1=recursion(lists,l,mid);
        ListNode n2=recursion(lists,mid+1,r);
        return merge(n1,n2);
    }
    public ListNode merge(ListNode n1,ListNode n2){
        ListNode h=new ListNode(-1),tem=h;	//重要
        while(n1!=null&&n2!=null){
            if(n1.val<=n2.val){
                tem.next=n1;
                n1=n1.next;
            }else{
                tem.next=n2;
                n2=n2.next;
            }
            tem=tem.next;
        }
        tem.next=n1!=null?n1:n2;
        return h.next;
    }
    //最小堆,4ms
    public ListNode mergeKLists(ListNode[] lists) {
        int len=lists.length;
        if(len==0) return null;
        Queue<ListNode> q=new PriorityQueue<>((n1,n2)->n1.val-n2.val);
        for(ListNode n:lists){
            if(n!=null) q.offer(n);  //非空判断
        }
        ListNode h=new ListNode(-1),tem=h;
        while(!q.isEmpty()){
            ListNode min=q.poll();
            tem.next=min;
            tem=tem.next;
            if(min.next!=null) q.offer(min.next);
        }
        return h.next;
    }
```

####   148 排序链表***

给你链表的头结点 `head` ，请将其按 升序 排列并返回 排序后的链表 。

分治法，归并排序：由快慢指针找到中间节点

```java
public ListNode sortList(ListNode head) {
        return head==null?null:dfs(head);
    }
    public ListNode dfs(ListNode head){
        if(head.next==null) return head;   //不是null
        ListNode fast=head,slow=head,pre=null;
        while(fast!=null&&fast.next!=null){
            pre=slow;
            fast=fast.next.next;
            slow=slow.next;
        }
        pre.next=null; //pre记录的是slow的前一个节点，中间节点之后的断开
        ListNode l=dfs(head);
        ListNode r=dfs(slow);
        return merge(l,r);  //链表只能合并完小的返回继续合并,数组可用临时数组装不返回
    }
    public ListNode merge(ListNode l,ListNode r){ //不用临时链表参数
        ListNode dum=new ListNode(-1),tem=dum;
        while(l!=null&&r!=null){
            if(l.val<=r.val){
                tem.next=l;
                l=l.next;
            }else{
                tem.next=r;
                r=r.next;
            }
            tem=tem.next;
        }
        tem.next=l==null?r:l;
        return dum.next;
    }
```

插入排序：

```java
public ListNode insertionSortList(ListNode head) {
        ListNode dum=new ListNode(-1),pre;
        dum.next=head;
        while(head!=null&&head.next!=null){
            if(head.next.val<head.val){
                pre=dum;
                while(pre.next.val<head.next.val) pre=pre.next;
                ListNode tem=head.next;
                head.next=head.next.next;
                tem.next=pre.next;
                pre.next=tem;
            }else{
                head=head.next;
            }
        }
        return dum.next;
    }
```



## 二叉树

leetcode二叉树的输入都是层序的

### 二叉树求值

#### 104 二叉树的最大深度

```java
public int maxDepth(TreeNode root) {
   return root==null?0:Math.max(maxDepth(root.left),maxDepth(root.right))+1;
}
```

##### 111 二叉树的最小深度

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。**说明：**叶子节点是指没有子节点的节点。

题解：求最小深度时将Math.max换成Math.min即可，但要注意如果当前节点的左或右子树其中一个为空的话不属于叶子节点，不能参与比较。下面的二叉树最小深度是3而不是1。

<img src="/image-20220604152333364.png" alt="image-20220604152333364" style="zoom: 33%;" />

```java
 public int minDepth(TreeNode root) {
        if(root==null) return 0;
        if(root.left==null&&root.right!=null) return minDepth(root.right)+1;  // null节点不参与比较
        if(root.right==null&&root.left!=null) return minDepth(root.left)+1;
        return Math.min(minDepth(root.left),minDepth(root.right))+1;
    }
```

#### 110 平衡二叉树**

判断是否平衡二叉树，二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 

题解：类似于求树的最大深度，可以在处理子树的深度就进行比较，且处理子树时发现其已经不平衡了（-1），则可以返回一个-1，避免多余的计算了

```java
	//1ms,两次递归
    public boolean isBalanced2(TreeNode root) {
        if(root==null) return true;
        if(Math.abs(maxDept(root.left)-maxDept(root.right))<2) return isBalanced(root.left)&&isBalanced(root.right);//当前满足的情况下，向下有个false就返回false。还可定义个flag或者这行false下行true的方法
        return false;
    }
    public int maxDept(TreeNode root){
        return root==null?0:Math.max(maxDept(root.left),maxDept(root.right))+1;
    }
    //0ms，处理子树的深度就进行比较
    public boolean isBalanced(TreeNode root) {
        return dfs(root)!=-1;
    }
    public int dfs(TreeNode root){  //是平衡的就返回真实高度，不是返回-1
        if(root==null) return 0;
        int l=dfs(root.left),r=dfs(root.right);
        if(l!=-1&&r!=-1&&Math.abs(l-r)<2) return Math.max(l,r)+1;
        return -1;
    }
```

#### 543 二叉树的直径

求一个二叉树的最长直径。直径的定义是**二叉树上任意两节点之间的无向距离**。

这条路径可能不穿过根结点：

<img src="/image-20220324111323522.png" alt="image-20220324111323522" style="zoom:67%;" />

```java
	int res=0;
    public int diameterOfBinaryTree(TreeNode root) {
        maxDept(root);   
        return res;		//两侧长度
    }
    public int maxDept(TreeNode root){  //递归返回一侧最大长度，当前root也包含
        if(root==null) return 0;
        int l=maxDept(root.left),r=maxDept(root.right);  //求子树的最大长度
        res=Math.max(r+l,res);  //不用-2，下面才+1，这里是下一层的深度
        return Math.max(r,l)+1;
    }
```

##### 124 二叉树最大路径和**

这里路径的定义是：任意两点间的路径和。

题解：不是父到子向下路径，不能用下面437题的双重递归，那个求一侧，这个求两侧

```java
int res=Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return res;
    }
    public int dfs(TreeNode root){  //递归求一侧最大长度，包含自身
        if(root==null) return 0;
        int l=Math.max(0,dfs(root.left)),r=Math.max(0,dfs(root.right));// 子树路径和为负则置0，表示不包含子树
        res=Math.max(res,root.val+l+r);
        return Math.max(l,r)+root.val;
    }
```

#### 112 路径总和***

判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。

题解：方法2的递归模板只适用于父节点到子节点的向下路径

```java
    //回溯法
    public boolean hasPathSum3(TreeNode root, int targetSum) {
        if(root==null) return false;
        return dfs(root,targetSum-root.val); 
    }
    public boolean dfs(TreeNode root,int targetSum){  //当前root.val已减
        if(root.left==null&&root.right==null&&targetSum==0) return true; //并且要是叶子节点
        if(root.left!=null){
            targetSum-=root.left.val;
            if(dfs(root.left,targetSum)) return true;
            targetSum+=root.left.val;
        }
        if(root.right!=null){
            targetSum-=root.right.val;
            if(dfs(root.right,targetSum)) return true;
            targetSum+=root.right.val;
        }
        return false;
    }
    //简化，不用回溯，在递归方法中减，返回后还是原来的targetSum,记住这个模板**
    public boolean hasPathSum2(TreeNode root, int targetSum) {
        if(root==null) return false;
        return dfs2(root,targetSum); 
    }
    public boolean dfs2(TreeNode root,int targetSum){  //当前root.val未减
        if(root==null) return false;
        if(root.left==null&&root.right==null&&targetSum==root.val) return true; //并且要是叶子节点
        if(dfs2(root.left,targetSum-root.val)) return true;
        if(dfs2(root.right,targetSum-root.val)) return true;
        return false;
    }
    //再简化
    public boolean hasPathSum(TreeNode root, int targetSum) {  //当前root.val未减
        if(root==null) return false;
        if(root.left==null&&root.right==null&&targetSum==root.val) return true;
        return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);
    }
```

##### 113 路径总和Ⅱ

找出所有 **根节点到叶子节点** 的路径和等于target

```java
	List<List<Integer>> res=new ArrayList<>();
    List<Integer> path=new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if(root==null) return res;
        dfs(root,targetSum);
        return res;
    }
    public void dfs(TreeNode root,int sum){  //当前root还没减
        if(root==null) return;
        if(root.left==null&&root.right==null&&sum==root.val){
            path.add(root.val); //还要将叶子节点加入
            res.add(new ArrayList<>(path));
            path.remove(path.size()-1);
            return ;
        }
        path.add(root.val);
        dfs(root.left,sum-root.val);
        dfs(root.right,sum-root.val);
        path.remove(path.size()-1);
    }
```

##### 437 路径总和Ⅲ*

有多少条路径节点值的和等于给定值。**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）

题解：不是任意两节点的路径，如图红色不是

![image-20220611124537405](/image-20220611124537405.png)

```java
    //双重递归，29ms
    int res=0;
    public int pathSum2(TreeNode root, int targetSum) {  //每个节点为起点都向下递归一次
        if(root==null) return 0;
        dfs(root,targetSum);
        pathSum(root.left,targetSum);
        pathSum(root.right,targetSum);
        return res;
    }
    public void dfs(TreeNode root,int targetSum){
        if(root==null) return;
        if(targetSum==root.val) res++; //不return，有可能有向下遍历还有能满足的情况，如图绿色
        dfs(root.left,targetSum-root.val);
        dfs(root.right,targetSum-root.val);
    }
    //前缀和+hashMap+回溯,类似两数之和用map存前面的值，2ms
     Map<Integer,Integer> map=new HashMap<>();  //key为前缀和，value为前缀和个数
     public int pathSum(TreeNode root, int targetSum) {
         map.put(0,1); //前缀和等于targetSum时也算
         dfs(root,targetSum,0);
         return res;
     }
     public void dfs(TreeNode root,int targetSum,int sum){ //前缀和未记录root.val
         if(root==null) return;
         sum+=root.val;
         if(map.containsKey(sum-targetSum)) res+=map.get(sum-targetSum);
         map.put(sum,map.getOrDefault(sum,0)+1);
         dfs(root.left,targetSum,sum);
         dfs(root.right,targetSum,sum);
         map.put(sum,map.getOrDefault(sum,0)-1); //回溯，每次向下递归完的数据清空，只记录父节点数据，即一条路径不能分叉
     }
```

#### 129 根到叶子节点数字和

每个节点都存放有一个 0 到 9 之间的数字。从根节点到叶节点的路径 如：1 -> 2 -> 3 表示数字 123 。生成的 所有数字之和 。

```java
 int sum=0,tem=0;
    StringBuilder sb=new StringBuilder();
    public int sumNumbers(TreeNode root) {
        dfs(root);
        return sum;
    }
    public void dfs(TreeNode root){
        if(root==null) return ;
        if(root.left==null&&root.right==null){  
            sb.append(root.val);         
            tem=Integer.parseInt(sb.toString());
            sum+=tem;
            sb.deleteCharAt(sb.length()-1);
            return ;
        }
        sb.append(root.val);
        dfs(root.left);
        dfs(root.right);
        sb.deleteCharAt(sb.length()-1);
    }
```

#### 236 二叉树的最近公共祖先**

设 root 为节点 p,q 的公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则 root是 “最近的公共祖先” 

题解：LCA 问题：root是 p，q 的公共祖先情况：p=root 或者 q=root 或者 p 和 q 在 root 的子树中，且分列 root 的 异侧。

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null||root==q||root==p) return root;
        // 如果p,q在左子树，则在左子树查找公共祖先
        if(isChildren(root.left,p)&&isChildren(root.left,q))  return lowestCommonAncestor(root.left,p,q);
        if(isChildren(root.right,p)&&isChildren(root.right,q)) return lowestCommonAncestor(root.right,p,q);
        // 如果p,q 在root两侧，则root为公共祖先
        return root;
    }
    public boolean isChildren(TreeNode root,TreeNode cur){
        if(root==null) return false;
        if(root.val==cur.val) return true;
        return isChildren(root.left,cur)||isChildren(root.right,cur); //有个true就返回true
    }
```

##### 1257 最小公共区域

 `regions` ，每个列表的第一个区域都包含这个列表内所有其他区域，给定两个区域 `region1` 和 `region2` ，找到同时包含这两个区域的 **最小** 区域。r1` 包含 `r2 和 `r3 ，那么数据保证 r2` 不会包含 r3

输入：
regions = [["Earth","North America","South America"],
["North America","United States","Canada"],
["United States","New York","Boston"],
["Canada","Ontario","Quebec"],
["South America","Brazil"]],
region1 = "Quebec",
region2 = "New York"
输出："North America" 

```java
 public String findSmallestRegion(List<List<String>> regions, String region1, String region2) {
        Map<String,String> map = new HashMap<>();
        for(List<String> list : regions){
            String ParentRegion = list.get(0);
            for(int i = 1;i < list.size();i++){
                map.put(list.get(i),ParentRegion); //key是当前区域，value是最小父区域
            }
        }
        List<String> res1 = find(region1,map);
        List<String> res2 = find(region2,map);
        for(String s : res1){
            if(res2.contains(s)){   //因为父节点队列是有序的，排在前面的是最小的父节点
                return s;
            }
        }
        return "";
    }
    public List<String> find(String region,Map<String,String> map){
        List<String> res = new ArrayList<>();
        String parent = region;      //本身也要放入
        while(map.get(parent)!=null){
            res.add(parent);
            parent = map.get(parent);  //将父区域从小到大放入list
        }
        res.add(parent);
        return res;
    }
```

### 镜像/相同二叉树*

#### 100  相同的树

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同

```java
public boolean isSameTree2(TreeNode p, TreeNode q) {
        if(p==null&&q==null) return true;
        if(p!=null&&q!=null&&p.val==q.val) return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right); //true还要往下看，有个false就返回
        else return false;       
    }
```

#### 101 对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称（只是根据root对称，不是根据每个子节点）

题解：如果两个子树都为空指针，它是对称的。若左右节点相等，则向下递归：比较 `left` 的左节点和 `right` 的右节点，再比较 `left` 的右节点和 `right` 的左节点。不是 **dfs(l.left,l.right)&&dfs(r.left,r.right);**

```java
public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        return dfs(root.left,root.right);
    }
    public boolean dfs(TreeNode l,TreeNode r){
        if(l==null&&r==null) return true;
        if(l!=null&&r!=null&&r.val==l.val) return dfs(l.left,r.right)&&dfs(l.right,r.left);
        return false;
    }
```

#### 226 翻转二叉树**

操作给定的二叉树，将其变换为源二叉树的镜像（根结点相同并且每个树的左子树和另一个树的右子树对称则称为镜像二叉树）

```Java
   //也可以新复制一棵树
    public TreeNode mirrorTree(TreeNode root) {
        if(root==null) return null;
        TreeNode e=new TreeNode(root.val);
        e.left=mirrorTree(root.right);
        e.right=mirrorTree(root.left);
        return e;
    }
```

#### 1110 删点成林

给定一个整数二叉树和一些整数，求删掉这些整数对应的节点后，剩余的子树

题解：建树改造树都要root.left指向。将待删除节点存入hashSet 可以快速检索

```java
	List<TreeNode> list;
    Set<Integer> set;
    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {
        list=new ArrayList<>();
        set=new HashSet<>();
        for(int i:to_delete){
            set.add(i);
        }
        root=dfs(root);
        if(root!=null) list.add(root);
        return list;
    }
    public TreeNode dfs(TreeNode root){
        if(root==null) return null;
        //先递归，后序遍历删除，自底向上删除，保证入list的树没有要删除的元素
        root.left=dfs(root.left);   //递归的时候还要指针指向，才算是真正删除
        root.right=dfs(root.right);
        if(set.contains(root.val)){
            if(root.left!=null) list.add(root.left);
            if(root.right!=null) list.add(root.right);
            root=null;  //置为空，或直接 return null
        }
        return root;
    }
```

### 广度优先/层次遍历

层序模板：

```java
public void levels(TreeNode root) {
       Queue<TreeNode> q=new LinkedList<>();
       if(root!=null) q.add(root);
       while(!q.isEmpty()){
           root=q.poll();
           System.out.print(root.val + "->");
           if(root.left!=null) q.offer(root.left);
           if(root.right!=null) q.offer(root.right); 
       } 
    }
```

#### 102 二叉树的层序遍历

要求返回结果这样：[[3],[9,20],[15,7]]

```java
 public List<List<Integer>> levelOrder(TreeNode root) {       
        List<List<Integer>> res=new ArrayList<>();
        Queue<TreeNode> queue=new LinkedList<>();
        if(root!=null) queue.add(root); //非空判断
        while(!queue.isEmpty()){
            int len=queue.size();
            List<Integer> path=new ArrayList<>();
            for(int i=0;i<len;++i){
                TreeNode tem=queue.poll();
                path.add(tem.val);
                if(tem.left!=null) queue.add(tem.left);  //非空判断
                if(tem.right!=null) queue.add(tem.right);
            }
            res.add(path); //若题目要求层序是从下往上的，则可定义LinkedList,addFirst()
        }
        return res;
    }
```

#### 103 二叉树锯齿形层序遍历

先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res=new ArrayList<>();
        Queue<TreeNode> q=new LinkedList<>();
        boolean flag=false;
        if(root!=null) q.add(root);
        while(!q.isEmpty()){
            int len=q.size();
            Integer[] path=new Integer[len];  
            for(int i=0;i<len;++i){
                TreeNode tem=q.poll();
                path[flag?len-i-1:i]=tem.val;
                if(tem.left!=null) q.add(tem.left);
                if(tem.right!=null) q.add(tem.right);
            }
            flag=!flag;
            res.add(Arrays.asList(path));  //path要为包装类型
        }
        return res;
    }
```

#### 637 二叉树的层平均值

给定一个二叉树，求每一层的节点值的平均数

```java
public List<Double> averageOfLevels(TreeNode root) {
       Queue<TreeNode> q=new LinkedList<>();
       List<Double> list=new ArrayList<>();
       if(root!=null) q.add(root);
       while(!q.isEmpty()){
           int len=q.size();
           long sum=0;      //防止溢出
           for(int i=0;i<len;++i){
               root=q.poll();
               sum+=root.val;
               if(root.left!=null) q.offer(root.left);
               if(root.right!=null) q.offer(root.right);
           }
           list.add((double)sum/len); 
       } 
       return list;
    }
```

### 前中后序遍历

```java
//递归
 public void preOrder(TreeNode root) {
        if (root == null) return;
            System.out.print(root.val + "->");    //前
            preOrder(root.left);			//写在下行中序
            preOrder(root.right);
    }
//非递归，用栈实现
 public void preOrder(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        while (root != null || !stack.empty()) {   //存入不为空 或 取出不为空
            if (root != null) {
                System.out.print(root.val + "->");  //前
                stack.push(root);
                root = root.left;
            } else {
                root= stack.pop().right;	//写在下行中序
            }
        }
    }
```

#### 105 前序和中序遍历构造树*

给定一个二叉树的前序遍历和中序遍历结果，尝试复原这个树。已知树里不存在重复值的节点

题解：递归法，由前序遍历确定根节点并在中序遍历中定位到根节点，就可知道左子树和右子树中的节点数目，这样就知道了左子树和右子树的前序遍历和中序遍历结果，就可以递归地对构造出左子树和右子树。`preorder` 和 `inorder` 均 **无重复** 元素，可以用hash表加速定位中序遍历的根节点

前序：[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]
中序：[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]

<img src="/image-20220327172549090.png" alt="image-20220327172549090" style="zoom:50%;" />

```java
	Map<Integer,Integer> map=new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int plen=preorder.length,ilen=inorder.length;  
        for(int i=0;i<ilen;++i){
            map.put(inorder[i],i);
        }
        return dfs(preorder,inorder,0,plen,0,ilen); //包前不包后
    }
    public TreeNode dfs(int[] preorder,int[] inorder,int pbegin,int pend,int ibegin,int iend){
        if(pbegin==pend) return null;    //前序/中序是空的即构造完
        int rootVal=preorder[pbegin];
        int iidx=map.get(rootVal);
        int leftNum=iidx-ibegin;
        TreeNode root=new TreeNode(rootVal);
        root.left=dfs(preorder,inorder,pbegin+1,pbegin+1+leftNum,ibegin,iidx);
        root.right=dfs(preorder,inorder,pbegin+1+leftNum,pend,iidx+1,iend);
        return root;
    }
```

#### 114 二叉树展开为链表

展开后的单链表应该与二叉树 先序顺序相同。要求在原二叉树上操作

<img src="/flaten.jpg" alt="img" style="zoom: 50%;" />

题解： 在还没操作节点右子树前，不能破坏该节点的右子树指向。所以采用后序遍历。将原来的左子树放在右子树位置，将原来的右子树挂载到新的右子树之后

```java
public void flatten(TreeNode root) {
        if(root == null) return;
        flatten(root.left);
        flatten(root.right);
        TreeNode tmp = root.right;
        root.right = root.left;
        root.left = null;
        while(root.right != null) root = root.right;
        root.right = tmp;
}
```

### 改造二叉树

#### 116 填充右侧节点指针

给定一个 完美二叉树，填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到则设置为 `NULL`。要求使用常数空间，递归程序占用的栈空间不算做额外的空间复杂度

<img src="/116_sample.png" alt="img" style="zoom:50%;" />

题解：可用BFS+queue:  if (i < size - 1) tem.next = q.peek()， 但空间复杂度太高。到了下一层，由于上一层的next已经连好，所以可以root.right.next = root.next.left。

```java
public Node connect(Node root) {
      if(root==null)  return null;
      if(root.left!=null){ //完全树，有左必有右
        root.left.next=root.right;  //左
        if(root.next!=null) root.right.next=root.next.left; //右
      }
      connect(root.left);
      connect(root.right);
      return root;
}
```

##### 117 填充右侧节点指针Ⅱ

给定的树不是完美树

```java
 /* 先对 root.right递归，从右到左连接，如图，若先对 root.left 递归，底层最左边节点无法获得next节点
                          o root
                         / \
                  left  o —— o  right
                       /    / \
                      o —— o   o
                     /        / \
                    o        o   o
    */
    public Node connect(Node root) {
        if(root==null) return null;
        if(root.left!=null){  //左
            if(root.right!=null) root.left.next=root.right;
            else root.left.next=getNext(root.next);
        }
        if(root.right!=null) root.right.next=getNext(root.next); //右
        connect(root.right);
        connect(root.left);
        return root;
    }
    public Node getNext(Node root){
        if(root==null) return null;
        if(root.left!=null) return root.left;
        if(root.right!=null) return root.right;
        else return getNext(root.next);
    }
```

#### 297 二叉树的序列化和反序列化

不限定序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

```java
 // Encodes a tree to a single string.
     public String serialize(TreeNode root) {
        StringBuilder sb=new StringBuilder();
        sDfs(root,sb);
        return sb.toString();
    }
    public void sDfs(TreeNode root,StringBuilder sb){
        if(root==null){
            sb.append("null,");
            return ;
        }
        sb.append(root.val+",");
        sDfs(root.left,sb);
        sDfs(root.right,sb);
    }
 // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] str=data.split(",");
        List<String> list=new LinkedList<>(Arrays.asList(str));
        return dDfs(list);
    }
    public TreeNode dDfs(List<String> list){
        if(list.get(0).equals("null")){   //String用equals
            list.remove(0);
            return null;
        }
        TreeNode root=new TreeNode(Integer.parseInt(list.get(0)));
        list.remove(0);            //
        root.left=dDfs(list);
        root.right=dDfs(list);
        return root;
    }
```



### 二叉查找/搜索树

二叉查找树（Binary Search Tree, BST）：左子树上所有结点的值均小于它根结点的值；右子树上所有结点的值均大于它根结点的值

二叉查找树可以在 *O*(*n* log *n*) 的时间内查找一个值是否存在：若当前节点的值大于查找值则向左下走，小于查找值则向右下走

**对二叉查找树的中序遍历的结果即为排好序的数组。**

#### 108 有序数组转化为二叉搜索树

给一个数组，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树(BST,左右两个子树的高度差不超过 1)。

题解： 可选择从start到end的任何一个值做为根结点构建二叉搜索树， 这里**选择它们的中点，这样构建出来的是一颗平衡二叉搜索树**

```java
 public TreeNode sortedArrayToBST(int[] nums) {
        return dfs(nums,0,nums.length-1);
    }
    public TreeNode dfs(int[] nums,int begin,int end){
        if(begin>end) return null;
        int mid=(begin+end)>>1;
        TreeNode root=new TreeNode(nums[mid]);
        root.left=dfs(nums,begin,mid-1);
        root.right=dfs(nums,mid+1,end);
        return root;
    }
```

##### 109 有序链表转化为二叉搜索树

```java
public TreeNode sortedListToBST(ListNode head) {
        if(head==null) return null;
        if(head.next==null) return new TreeNode(head.val); //必要
        ListNode pre=null,low=head,fast=head;  // low是中点，pre是low的前一个结点，用于断开需要置空
        while(fast!=null&&fast.next!=null){
            pre=low;
            low=low.next;
            fast=fast.next.next;
        }
        pre.next=null;
        return new TreeNode(low.val,sortedListToBST(head),sortedListToBST(low.next));
    }
```

#### 95 不同的二叉搜索树Ⅱ**

给一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** 。可以按 **任意顺序** 返回答案

题解： 1...n 的所有可能：

把 1 作为根节点，[ ] 空作为左子树，[ 2 ... n ] 的所有可能作为右子树。

2 作为根节点，[ 1 ] 作为左子树，[ 3...n ] 的所有可能作为右子树。。。

以 i 为根节点的二叉搜索树递归找到左子树的结合和右子树的集合，然后两个结合笛卡尔积就得到以 i 为根节点的树的集合

```java
    public List<TreeNode> generateTrees(int n) {
        return dfs(1,n);
    }
    public List<TreeNode> dfs(int begin,int end){
        List<TreeNode>  path=new ArrayList<>();  //不定义全局变量，左右种类都需要集合存，并返回出去求笛卡尔积
        if(begin>end){  
            path.add(null);  // 如果当前子树为空，加入null，不加的话，其中一个列表空下面的双重循环都不会走
            return path;
        }
        for(int i=begin;i<=end;++i){
            // TreeNode root = new TreeNode(i);  //不能在这，否则都是同个对象，最终生成的都是一个
            List<TreeNode> left=dfs(begin,i-1);
            List<TreeNode> right=dfs(i+1,end);
            for(TreeNode l:left){
                for(TreeNode r:right){
                    TreeNode root=new TreeNode(i);
                    root.left=l;
                    root.right=r;
                    path.add(root);
                }
            }
        }
        return path;
    }
```

##### 96 不同的二叉搜索树

给一个整数 `n` ，请你返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树 **的个数

题解：动态规划，假设 n 个节点存在二叉排序树的个数是 G (n)，令 f(i) 为以 i 为根的二叉搜索树的个数，则

G*(*n)=f(1)+f(2)+f(3)+f(4)+...+f(n)，*f*(*i*)=*G*(*i*−1)∗*G*(*n*−*i*)，推出 卡特兰公式：*G*(*n*)=*G*(0)∗*G*(*n*−1)+*G*(1)∗G(*n*−2)+...+*G*(*n*−1)∗G(0)

<img src="/image-20220531170107717.png" alt="image-20220531170107717" style="zoom: 50%;" />



```java
 	public int numTrees(int n) {
        int[] dp=new int[n+1];
        dp[0]=1;dp[1]=1;
        for(int i=2;i<n+1;++i){
            for(int j=1;j<i+1;++j){
                dp[i]+=dp[j-1]*dp[i-j];   //i即公式中的n，j即i
            }
        }
        return dp[n];
    }
```

#### 98 验证二叉搜索树**

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

```java
 //递归，0ms
    public boolean isValidBST(TreeNode root) {
       return dfs(root,Long.MIN_VALUE,Long.MAX_VALUE);
    }
    public boolean dfs(TreeNode root, long min, long max){
        if(root==null) return true;
        if(root.val>=max||root.val<=min) return false;   //子树的节点的值都要在 (min,max)的范围内，开区间
        return dfs(root.left,min,root.val)&&dfs(root.right,root.val,max);  //有false就返回false
    }
    //中序遍历+集合,2ms
    public boolean isValidBST2(TreeNode root) {
        List<Integer> res=new ArrayList<>();
        dfs(root,res);
        for(int i=1;i<res.size();++i){
            if(res.get(i)<=res.get(i-1)) return false;
        }
        return true;
    }
    public void dfs(TreeNode root,List<Integer> res){
        if(root==null) return ;
        dfs(root.left,res);
        res.add(root.val);
        dfs(root.right,res);
    }
```

#### 99 恢复二叉搜索树

给定一个二叉查找树，已知有两个节点被不小心交换了，试复原此树

题解：**中序遍历**，结果中如果只有一个降序对，说明该两个node需交换；若有两个降序对，说明第一对的前一个node和第二对的后一个node需要交换。可以增加辅助的`pre`指针，记录 **上一个** 节点的值，就不用额外数组了

<img src="/image-20220328103514252.png" alt="image-20220328103514252" style="zoom:67%;" />

```java
	TreeNode x,y,pre;
    public void recoverTree(TreeNode root) {
        dfs(root);
        if(x!=null){  //有错误节点就交换，直接交换节点不行，因为指针指向没有改变 ，直接交换节点值就行 
            int tem=x.val;
            x.val=y.val;
            y.val=tem;
        }
    }
    public void dfs(TreeNode root){
        if(root==null) return ;
        dfs(root.left);
        if(pre!=null&&pre.val>=root.val){  
            if(x==null) x=pre;
            y=root;
        }
        pre=root;
        dfs(root.right);
    }
```

#### 538 将二叉搜索树转化为累加树

将每个节点的值修改为原来的节点值加上所有大于它的节点值之和

题解：BST的中序遍历就是从小到大，那么反过来就是从大到小，接下来累加就行

```java
	int sum=0;
    public TreeNode convertBST(TreeNode root) {
        if(root==null) return null;
        convertBST(root.right);
        sum+=root.val;
        root.val=sum;
        convertBST(root.left);
        return root;
    }
```

#### 669 修剪二叉搜索树

给定一个二叉查找树和两个整数 *L* 和 *R*，且 *L* < *R*，试修剪此二叉查找树，使得修剪后所有节点的值都在 [*L*, *R*] 的范围内

<img src="/image-20220328113941357.png" alt="image-20220328113941357" style="zoom:50%;" />

```java
  //前中后序都可以
	public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root==null) return null;
        root.left=trimBST(root.left,low,high);
        root.right=trimBST(root.right,low,high);
    	if(root.val<low) return trimBST(root.right,low,high);
        if(root.val>high) return trimBST(root.left,low,high);
        return root;
    }
```

#### 二叉树叶子节点

士兵们沿着一条道路行进，遇到三岔路口时， 部队若可以分为两个部分且两个部分的人数差恰好为k，则完成部队划分沿着两条路走下去，否则不走。

输入：两个整数n,k(1 <= n <= 10^9, 1 <= k <= 1000)n,k(1<=n<=109,1<=k<=1000), 即部队中士兵的总人数和划分部队的参数
输出：最终叶子节点个数

```java
public class Main{
    private static  int res=0;
    public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int k=sc.nextInt();
        solution(n,k);
        System.out.println(res);
    }
    public static void solution(int n,int k){
        if(n<2+k||(n-k)%2!=0){  res++;return;}
        solution((n+k)/2,k);  //还要保证可以整除
        solution((n-k)/2,k);
    }    
}
```

## 字典树

字典树（Trie）用于判断字符串是否存在或者是否具有某种字符串前缀

![image-20220328115522599](/image-20220328115522599.png)

为什么需要用字典树？假如有一个储存了近万个单词的字典，即使我们使用哈希，在其中搜索一个单词的实际开销也是非常大的，且无法轻易支持搜索单词前缀。然而由于一个英文单词的长度 *n* 通常在 10 以内，如果我们使用字典树，则可以在 *O*(*n*)—近似 *O*(1)的时间内完成搜索，且额外开销非常小

#### 208 实现Trie

尝试建立一个字典树，支持快速插入单词、查找单词、查找单词前缀的功能

题解：Trie 是一颗非典型的多叉树模型。**一次建树，多次查询**

<img src="/image-20220328152902412.png" alt="image-20220328152902412" style="zoom: 67%;" />

```java
class Trie {
    TrieNode root;  //虚拟头
    public Trie() {
        root=new TrieNode();
    }
    public void insert(String word) {
        TrieNode tem=root;
        for(char w:word.toCharArray()){
            if(tem.next[w-'a']==null){
                tem.next[w-'a']=new TrieNode();
            }
            tem=tem.next[w-'a'];
        }
        tem.isEnd=true;
    }   
    public boolean search(String word) {
        TrieNode tem=root;
        for(char w:word.toCharArray()){
            if(tem.next[w-'a']==null) return false;
            tem=tem.next[w-'a'];
        }
        return tem.isEnd;
    }  
    public boolean startsWith(String prefix) {
        TrieNode tem=root;
        for(char w:prefix.toCharArray()){
            if(tem.next[w-'a']==null) return false;
            tem=tem.next[w-'a'];
        }
        return true;
    }
    class TrieNode{
        TrieNode[] next;    //子节点
        boolean isEnd;  //是否叶子节点
        public TrieNode(){
            next=new TrieNode[26];
            isEnd=false;
        }
    }
}
```

#### 异或

给定整数m以及n各数字A1,A2,..An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果，请求出这些结果中大于m的有多少个。

```java
//暴力破解肯定超时，两个数从高位到地位依次运算，如果两个数异或结果在某高位为1，而m 对应位为0，则这两位异或结果肯定比m大。
//从高位到低位建立字典树，使用每个元素依次去字典中查对应高位异或为1 而m为0的数的个数，相加再除以2既是最终的结果
public class Main { 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int m = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
            }   
            System.out.println(solve(a, m));
    }
    private static long solve(int[] a, int m) { 
        TrieTree trieTree = build(a);  //建树
        long result = 0;   //个数可能会超过int
        for (int num:a) {
        result += query(trieTree, num, m, 31); //每个数和字典树异或相当于和其他数异或了
        }
        return result / 2;
    }
     private static TrieTree build(int[] a) {
        TrieTree trieTree = new TrieTree();
        for (int i = 0; i < a.length; i++) {
            TrieTree current = trieTree;
            for (int j = 31; j >= 0; j--) { //31到0是整数能表示的范围
                int dig = (a[i] >> j) & 1;  //从高到低取每一位
                if(current.next[dig] == null) {  //不存在就建
                    current.next[dig] = new TrieTree();
                } else {  //存在就共享
                    current.next[dig].count ++;
                }
                current = current.next[dig];
            }
        }
        return trieTree;
    }
    private static long query(TrieTree trieTree, int a, int m, int index) {   
        if(trieTree == null) return 0;
        TrieTree current = trieTree;
        for (int i = index; i >= 0; i--) {
            int aDigit = (a >> i) & 1;
            int mDigit = (m >> i) & 1;
/*四种情况：
1. aDigit=1， mDigit=1时，字典中第k位为0，异或结果为1，需要继续搜索更低位，第k位为1，异或结果为0，小于mDigit，不用理会；
2. aDigit=0， mDigit=1时，字典中第k位为1，异或结果为1，需要继续搜索更低位，第k位为0，异或结果为0，小于mDigit，不用理会；
3. aDigit=1， mDigit=0时，字典中第k位为0，异或结果为1，结果会大于m，第k位为1，异或结果为0，递归获得结果；
4. aDigit=0， mDigit=0时，字典中第k位为1，异或结果为1，结果会大于m，第k位为0，异或结果为0，递归获得结果；
*/
            if(aDigit == 1 && mDigit == 1) {
                if(current.next[0] == null)  return 0; 
                current = current.next[0];   //相等往下走
            } else if (aDigit == 0 && mDigit == 1) {
                if(current.next[1] == null)  return 0;
                current = current.next[1];
            } else if (aDigit == 1 && mDigit == 0) {
                long p = query(current.next[1], a, m, i - 1);  //相等递归
                long q = current.next[0] == null ? 0 : current.next[0].count;
                return p + q;
            } else if (aDigit == 0 && mDigit == 0) {
                long p = query(current.next[0], a, m, i - 1);
                long q = current.next[1] == null ? 0 : current.next[1].count;
                return p + q;
            }
        }
        return 0;
    }
     private static class TrieTree {   //静态内部类
        TrieTree[] next = new TrieTree[2];  //0或1的孩子节点
        int count = 1;  //共享当前节点的数的个数，默认为1
    }
}
```



## 图

图通常分为有向（directed）或无向（undirected），有循环（cyclic）或无循环（acyclic）。树即是一个相连的无向无环图。

图通常有两种表示方法。第一种表示方法是邻接矩阵 ：如果第 i 个节点连向第 j 个节点，则 `G[i][j]= 1`，反之为 0；如果图是无向的，则这个矩阵一定是对称矩阵，即 `G[i][j] = G[j][i]`。第二种表示方法是邻接链表：建立一个大小为 *n* 的数组，每个位置 i 储存一个数组或者链表或者集合，表示第 i 个节点连向的其它节点。邻接矩阵空间开销比邻接链表大，但是邻接链表不支持快速查找 i 和 j 是否相连，因此两种表示方法可以根据题目需要适当选择。

对于无向图，遍历的次数 =  该图的连通分量数

对于有向图，遍历的次数 = 强连通分量的个数

#### 133 克隆图

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）

题解：遍历节点过程中，在Map里没有出现过的就创建一个新的并与旧的对应。然后在遍历的同时对照着Map把原来建的节点的邻接点连接到现在的新节点。map相当于复制链表时的pre节点，只不过图要记录全部的pre

```java
	//bfs
    public Node cloneGraph(Node node) {
        if(null==node) return null;
        Deque<Node> q=new ArrayDeque<>();
        Map<Node,Node> map=new HashMap<>();
        Node clone=new Node(node.val,new ArrayList<>());
        map.put(node,clone);
        q.offer(node);
        while(!q.isEmpty()){
            Node tem=q.poll();
            for(Node n:tem.neighbors){
                if(!map.containsKey(n)){
                    map.put(n,new Node(n.val,new ArrayList<>()));
                    q.offer(n);
                }
                map.get(tem).neighbors.add(map.get(n));
            }
        }
        return clone;
    }
```

#### 582 杀死进程**

给 n 个进程，每个进程都有一个独一无二的 PID （进程编号）和它的 PPID （父进程编号）,只有一个进程的 PPID 是 0 ，意味着这个进程没有父进程。当一个进程被杀掉的时候，它所有的孩子进程和后代进程都要被杀掉。

题解：进程id 不是从 1~n，不能直接用 List<>[] 数组 结构

<img src="/image-20220725152245762.png" alt="image-20220725152245762" style="zoom:80%;" />

```java
public List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) {       
        Map<Integer, List<Integer>> map = new HashMap<>();  // key 为父进程编号，value 为该进程的子进程编号集合
        for (int i = 0; i < ppid.size(); i++) {
            if (ppid.get(i) > 0) {
                List<Integer> l = map.getOrDefault(ppid.get(i), new ArrayList<Integer>()); // 取出子进程集合
                l.add(pid.get(i)); 
                map.put(ppid.get(i), l); // 把子进程集合放回去
            }
        }
        List<Integer> l = new ArrayList<>();
        l.add(kill);
        getAllChildren(map, l, kill);
        return l;
    }
    public void getAllChildren(HashMap<Integer, List<Integer>> map, List<Integer> l, int kill) {
        if (map.containsKey(kill)) { // 如果存在被杀死的进程
            for (Integer id : map.get(kill)) {
                l.add(id); // 自己也要被杀死
                getAllChildren(map, l, id);
            }
        }
    }

```

### 二分图

二分图算法也称为染色法，是一种广度优先搜索。如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么图为二分

#### 785 判断二分图

给定一个图，判断其是否可以二分。

题解：用 0 表示未检查的节点，用 1 和 2 表示两种不同的颜色。 因为图中可能含有多个连通域，所以都要遍历一遍判断是否存在顶点未被访问

```java
//bfs，推荐,1ms
    public boolean isBipartite2(int[][] graph) {
        int len=graph.length;
        int[] visit=new int[len];
        Queue<Integer> q=new LinkedList<>();
        for(int i=0;i<len;++i){ 	 //有多个连通图情况
            if(visit[i]!=0) continue;
            q.offer(i);
            visit[i]=1;
            while(!q.isEmpty()){
                int tem=q.poll();
                for(int j:graph[tem]){
                    if(visit[j]==0){
                        q.offer(j);
                        visit[j]=visit[tem]==1?2:1;
                    }else if(visit[j]==visit[tem]){
                        return false;
                    }
                }
            }  
        }
        return true;
    }
    //dfs,0ms
    public boolean isBipartite3(int[][] graph) {
        int len=graph.length;
        int[] visit=new int[len];
        for(int i=0;i<len;++i){
            if(visit[i]!=0) continue;
            visit[i]=1;
            if(!dfs(graph,visit,i)) return false;
        }
        return true;
    }
    public boolean dfs(int[][] graph,int[] visit,int i){
        for(int j:graph[i]){
            if(visit[j]==0) {
                visit[j]=visit[i]==1?2:1;
               // boolean flag=dfs(graph,visit,j); if(!flag) return false; 
                if(!dfs(graph,visit,j)) return false;         //dfs有一个false就返回false
            }else if(visit[i]==visit[j]){
                return false;
            }
        }
        return true;
    }
    //并查集,2ms
    public boolean isBipartite(int[][] graph) {
        int len=graph.length;
        UnionFind uf=new UnionFind(len);
        for(int i=0;i<len;++i){
            int[] tem=graph[i];
            for(int t:tem){
                if(uf.isConnect(i,t)) return false;
                uf.union(tem[0],t);
            }
        }
        return true;
    }
    class UnionFind{
        int[] roots;
        public UnionFind(int n){
            roots=new int[n];
            for(int i=0;i<n;++i){
                roots[i]=i;
            }
        }
        public int find(int x){
            if(roots[x]!=x) roots[x]=find(roots[x]); 
            return roots[x];
        }
        public void union(int p,int q){
            roots[find(p)]=find(q);
        }
        public boolean isConnect(int p,int q){
            return find(p)==find(q);
        }
    }
```

### 拓扑排序

拓扑排序（topological sort）是对**有向无环图排序的算法**。给定有向无环图中的*N* 个节点，我们把它们排序成一个线性序列；若原图中节点 i 指向节点 j，则排序结果中 i 一定在 j 之前。

拓扑排序的**结果不是唯一的。能够顺带检测有向图中是否存在环**

拓扑排序 = BFS +贪心算法（让入度为 0 的结点入队）：

每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，可以设置一个入度数组，每一轮都输出入度为 0 的结点，并移除它、修改它指向的结点的入度（−1即可），依次得到的结点序列就是拓扑排序的结点序列

#### 210 课程表Ⅱ***

给定 N 个课程（记为 `0` 到 `numCourses - 1`）和这些课程的前置必修课（二维矩阵，[1,0] 表示上课程 1 之前必须先上课程 0），求可以一次性上完所有课的顺序

题解：采用邻接表，不能得到入度值为 0 的节点，说明存在环，不存在满足条件的顺序

若题目要看能不能，就看 idx等不等于numcourses

<img src="/image-20220630153100850.png" alt="image-20220630153100850" style="zoom:50%;" />

```java
public int[] findOrder(int numCourses, int[][] prerequisites) {
        if(numCourses<1) return new int[0];
        int len=prerequisites.length;
        Node[] arr=new Node[numCourses];  //从0开始的，不用+1
        for(int i=0;i<numCourses;++i){     //初始化节点
            arr[i]=new Node();
        }
        for(int[] p:prerequisites){     //构造邻接表，[1,0],0->1
            arr[p[1]].list.add(p[0]);
            arr[p[0]].inde++;
        }
        int[] res=new int[numCourses];  //删除一个加入一个
        int idx=0;
        Queue<Integer> q=new LinkedList<>();  //不放node，放下标
        for(int i=0;i<numCourses;++i){
            if(arr[i].inde==0) q.offer(i);
        }
        while(!q.isEmpty()){
            int tem=q.poll();
            res[idx++]=tem;
            for(Integer i:arr[tem].list){   //更新节点入度
                arr[i].inde--;
                if(arr[i].inde==0) q.offer(i);
            }
        }
        if(idx==numCourses) return res;  //结果集中的数量等于结点的数量，能完成课程任务
        return new int[0];
    }
    static class Node{  //一般用构造初始化，这里为了简便
        List<Integer> list=new ArrayList<>();
        int inde=0;  //入度,入度=0的删除。若是删除无向图叶子节点，可以用度，度<=1的删除，另外无向图要个属性flag标记是否已删除
    }
```

#### 小美的送花线路*

 设花店始终位于1号位置，客户共有n-1个，其编号为2~n，这n个位置构成的是一棵树。令dis(i,j)表示i号位置到j号位置的距离，即分别计算![img](/equation), 和骑手实际所走的最短路程。

输入：第一行一个正整数n，表节点总数。(1<=n<=30000)接下来有n-1行，每行有三个整数u,v,w，表示在u和v之间存在一条距离为w的道路。(1<=w<=1000)

输出：输出包含两个整数，中间用空格隔开，分别表示花店到所有客户地址的距离之和和骑手实际走的路程。

```java
/*已经是树了，不用生成树的算法了。DFS找到根节点到各个节点的距离，骑手的路径就是边的总和的两倍减去最后一次
路径（最后不返回，即根节点到最远的节点距离）*/
public class Main {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        Node[] a=new Node[n+1];
        for(int i = 0; i < n+1; ++i){   //Node[]初始化必要
            a[i] =new Node();
        }
        int sum=0;
        for(int i=0;i<n-1;i++){
            int u=sc.nextInt();
            int v=sc.nextInt();
            int w=sc.nextInt();
            a[u].map.put(a[v],w);
            a[v].map.put(a[u],w);
            sum+=2*w;
        }
        a[1].visit=true;
        DFS(a[1],0);  //深度遍历将距离求出
        int res1=0;
        int res2=0;
        for(int i=1;i<=n;i++){
            res1+=a[i].dis;
            res2=Math.max(res2,a[i].dis); //找到距离根节点到最远的节点距离
        }
        res2=sum-res2;
        System.out.println(res1+" "+res2);
    }
    public static void DFS(Node cur,int dis){  //图的话外面还要层循环，树不用
        for(Node n:cur.map.keySet()){
            if(n.visit)continue;//访问过就结束本次循环，进入下一次。可以将树变成有向树就不用visit了
            n.visit=true;
            n.dis=dis+cur.map.get(n);
            DFS(n,n.dis);
        }
    }
    public static class Node{  //可以构造new，也可直接new赋值
        int dis=0;     //当前节点与花店距离
        boolean visit=false;  //不赋值也成
        Map<Node,Integer> map=new HashMap<>(); //相通的邻节点和边，用map。输入不分前后节点，最好不用父子节点
    }
}
```

#### 神秘的苹果树**

输入：第一行一个正整数n表节点个数。接下来n-1行，每行两个正整数x­­i,yi,表示树上第i条边连接的两个节点。接下来一行n个正整数c­i，表示从1~n号节点上的苹果的颜色。接下来一行一个正整数q，表示接下来有q次独立的询问。接下来q行，每行一个正整数t表示询问：如果小团只能从节点t的子树中选取某一种颜色的苹果，选取什么颜色能拿到最多的苹果？如果有多种颜色都可以拿同样多的苹果，输出颜色编号最小的那个对应的编号。n≤5000, 1≤xi,yi,t≤n, ci≤10^9,q≤1000

输出：q行，每行一个整数表示答案。

```java
/*
题目只知道1为根节点，输入边时不知道哪个是父节点，需要先构建无向树。然后
从根节点1开始向下递归删除子节点指向父节点，改为有向树
*/ 
import java.util.*;
public class Main {
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        Node[] arr=new Node[n+1];
        for(int i=0;i<n+1;++i){  //初始化
            arr[i]=new Node();
        }
        for(int i=0;i<n-1;i++){
            int a= scanner.nextInt(); 
            int b= scanner.nextInt();
            arr[a].sonList.add(arr[b]);
            arr[b].sonList.add(arr[a]);
        }
        adjust(arr[1]);
        for(int i=1;i<n+1;++i){
            int c = scanner.nextInt();
            arr[i].c=c;
        }
        Map<Integer,Integer> cnt = new TreeMap<>();//每个颜色对应的个数,用Treemap排序后面找最小的
        int time = scanner.nextInt();
        for(int i=0;i<time;i++){
            int root = scanner.nextInt();
            Dfs(arr[root],cnt);  //深度遍历得出颜色个数
            List<Integer> list =new ArrayList<>(cnt.values()); //map的value转为list
            Collections.sort(list);
            for(Map.Entry entry: cnt.entrySet()){
                if(entry.getValue() == list.get(list.size()-1)){
                    System.out.println(entry.getKey());
                    break;
                }
            }
            cnt.clear();  //清空map
        }
    }
    public static void Dfs(Node node,Map<Integer,Integer> cnt){   //调整为有向树就不用visit变量了
        int c = node.c;
        cnt.put(c,cnt.getOrDefault(c,0)+1); //map中有c就返回对应value，否则返回0
       // if(node.sonList.size()==0)return;  //不用出口也行，不用回溯
        for(Node n:node.sonList){
            Dfs(n,cnt);
        }
    }
    public static void  adjust(Node node){  //无向图变有向图
            //if(sonList.size()==0) return;
            for(Node n:node.sonList){
                List<Node> ssonList = n.sonList;
                ssonList.remove(node);
                n.sonList=ssonList;
                adjust(n);
            }
    }
    static class Node{
        int c;  //颜色
        List<Node> sonList=new ArrayList<>();  //子节点
     }
}
```

#### 树上上升序列

给定一棵树，树上的第u个节点有点权au。请你找出一条最长的路径，使得从u沿着唯一路径走到v的途中，点权不断严格递增。

输入：第一行树的节点个数n , 接下来一行n个数字，表示每个点的点权。接下来n−1行表树上两点u，v的一条边(2≤n≤10^5，1≤ai≤n)

输出：最长的路径长度（设每条边长为1）

```java
    static int max=0;
    public static void main(String[] args) {
        Scanner s=new Scanner(System.in);
        int N=s.nextInt();
        int[] nums=new int[N+1];
        for (int i = 1; i < N+1; i++) {
            nums[i]=s.nextInt();
        }
        List<Integer>[] graph=new ArrayList[N+1];
        for(int i=0;i<graph.length;i++){
            graph[i]=new ArrayList<>();
        }
        for (int i = 0; i <N-1 ; i++) {
            int l=s.nextInt();
            int r=s.nextInt();
            graph[l].add(r);
            graph[r].add(l);
        }
        for (int i = 1; i <N ; i++) {
            dfs(graph,nums,i,0);
        }
        System.out.println(max);
    }
    public static void dfs(List<Integer>[] graph,int[] nums,int now,int len){
        len+=1;
        max=Math.max(max,len);   //每次for循环中找最长的
        List<Integer> nexts=graph[now];
        for (int next:nexts ) {
            if(nums[next]>nums[now]){   //不用设置visit数组，每次找比上次大的
                dfs(graph,nums,next,len);
            }
        }
    }
}
```



## 并查集

并查集可以动态地连通两个点（两点合并到一个集合），并且可快速地判断两个点是否属于一个连通分量/成环（在一个集合），还可以确定连通分量的个数。

并查集是一种数据结构
并（Union），代表合并，给定两个目标值，把两个目标合并到一个集合中（parent[目标值] = 根）
查（Find），代表查找，给定一个目标值，找到这个目标值的根（find(目标值) = 根），根的值在parent数组中。
集（Set），代表这是一个以字典为基础的数据结构，它的基本功能是合并集合中的元素，查找集合中的元素

并查集跟树有些类似，只不过在树里面每个节点会记录它的子节点。在并查集里每个节点会记录它的父节点。

并查集并不是一个二叉树，而是一个多叉树，所以并查集的查询和合并时间复杂度并不是O(log n)

模板（带权值的）:

```java
public class UnionFind {
    private int[] roots;
    private int count; //集合个数,知道个数或不用求个数不写
    private int[] sz;	//不带权值或者不用按秩合并的可不写
    public UnionFind(int N) {
        roots = new int[N];
        count = N;
        sz = new int[N];
        for(int i = 0; i < N; i++) {
            roots[i] = i;   //一开始roots[i]存的是自己点
            sz[i] = 1;
        }
    }
    public int find(int p) {  //查询
        if(roots[p] != p) roots[p] = find(roots[p]); //路径压缩，1->2->3->4->5，若查找5的根结点，则可以在查找的过程中把2,3,4的parent全部指向1
        return roots[p];
    }
    public void union(int p, int q){   //合并。优化，按秩合并：深度小的集合合并在大的集合下
        // roots[find(p)] = find(q)
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == qRoot) return;
        if(sz[pRoot] < sz[qRoot]) { roots[pRoot] = qRoot; sz[qRoot] += sz[pRoot]; }
        else                      { roots[qRoot] = pRoot; sz[pRoot] += sz[qRoot]; }
        count--;
    }
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}
```

#### 684 冗余连接

有n个节点的无向图(节点值 `1～n`)，在无向图找出一条边，移除它之后该图能够成为一棵树（即无向无环图）。如果有多个解，返回在原数组中位置最靠后的那条边

题解：一棵树中，边的数量比节点的数量少 1。此题的边数量和节点数量相同

遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。若不同的连通分量，合并这两个顶点。若相同的连通分量，则说明有环出现，将当前的边作为答案返回

```java
public int[] findRedundantConnection(int[][] edges) {
        int[] res=new int[2];
        int n=edges.length;
        UnionFind uf=new UnionFind(n+1);
        for(int[] e:edges){
            if(uf.isConnect(e[0],e[1])){res[0]=e[0];res[1]=e[1];}
            else uf.union(e[0],e[1]);
        }
        return res;
    }

    static class UnionFind{
        int[] roots;
        public UnionFind(int n){
            roots=new int[n];
            for(int i=0;i<n;++i){
                roots[i]=i;
            }
        }
        public int find(int x){
            if(roots[x]!=x) return roots[x]=find(roots[x]);
            return roots[x];
        }
        public void union(int p,int q){
            roots[find(p)]=find(q);
        }
        public boolean isConnect(int p,int q){
            return find(p)==find(q);
        }
    }
```

####  小团的配送团队

输入第一行是两个正整数n，m，表示接受的订单数量和已知的关系数量。(1<=n，m<=10000)接下来有m行，每行两个正整数a和b，表示a号订单和b号订单属于同一个小区(1<=a,b<=n);

输出第一行包含一个整数x，表示这些订单共来自x个不同的小区。接下来的输出包含x行，每行表示输出订单属于同一个小区，按照订单编号升序输出。优先输出最小的订单编号较小的小区。

```java
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        UnionFind uf = new UnionFind(n);
        for(int i = 0; i < m; i++) {
            uf.union(sc.nextInt(), sc.nextInt());
        }
        // 先输出小区数
        System.out.println(uf.count);
        // 再输出每个小区的订单号
        TreeMap<Integer, ArrayList<Integer>> region = new TreeMap<>();
        ArrayList<Integer> temp;
        for(int i = 1; i <= n; i++){
            if(region.containsKey(uf.parent[i]))
                temp = region.get(uf.parent[i]);
            else
                temp = new ArrayList<>();
            temp.add(i);
            region.put(uf.parent[i], temp);
        }
        for(int id: region.keySet()){
            temp = region.get(id);
            for(int i = 0; i < temp.size(); i++)
                System.out.print(temp.get(i) + " ");
            System.out.println();
        }
    }
}
class UnionFind {
    public int[] parent;
    public int count;  //集合个数
    public UnionFind(int n) {
        count = n;
        parent = new int[n + 1];
        for(int i = 1; i <= n; i++){
            parent[i] = i;     //一开始parent[x]存的是自己点
        }
    }    
    public int find(int x) {//查询，union方法使parent[x]存的是父节点，find方法使parent[x]存根节点
        if(parent[x] != x){
            parent[x] = find(parent[x]);// 路径压缩，1->2->3->4->5，若查找5的根结点，则可以在查找的过程中把2,3,4的parent全部指向1
        }
         return parent[x];
    }   
    public void union(int x, int y) { //合并
        if(x == y) return;
        int rootX = find(x);
        int rootY = find(y);
        if(rootX == rootY) return;
        // 将节点编号大的合并到节点编号小的节点下面
        if(rootX < rootY){
            for(int i = 0; i < parent.length; ++i){
                if(parent[i] == rootY)
                    parent[i] = rootX;
            }
        }else{
            for(int i = 0; i < parent.length; ++i) {
                if(parent[i] == rootX)
                    parent[i] = rootY;
            }
        }
        count --;
    }
}
```

逆序插入+查并集的区间合并















