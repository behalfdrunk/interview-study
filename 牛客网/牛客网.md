---
typora-root-url: images
typora-copy-images-to: images
---



## 选择题

#### 1、时间/空间复杂度

时间复杂度是**基本操作的执行次数，n是目标值的界限 。**

O(1)<对数(logn)<线性O(n)<线性对数O(nlogn)<平方O(n²)<立方O(n³)<k次方O(n的k次方)<指数O(2的n次方)

下面代码的时间复杂度：O(n^1/2)    (加是开根号，乘是取对数)

```java
i = k = 0;
while( k < n ){
i ++ ;
k += i ;
}
```

1  次 							   2        							3  		....... 			 q次

k=0+1						k=0+1+2					  k=0+1+2+3	 ... 		  k=1+2+3+...+q=n 	===>	q(1+q)/2=n	===>	q^2+q=2n

q^2+q+1/4=2n+1/4	===> 	(q+1/2)=(2n+1/4)^1/2	===>	q=(2n+1/4)^1/2-1/2	===>	T(n)=O(n^1/2)



递归的时间复杂度就是 **递归次数*每次递归复杂度 或 计算递归树的节点。**

下面代码时间复杂度是O(n)。若是两个分叉则是2^n（二叉树是2^n，不是n^2）

```java
 intfact(int n) {
       if (n <= 1) return 1; 
       return n * fact(n-1);
 }
```

二分查找的递归实现中，递归深度是 log n ，每次递归里面的复杂度是 O(1) ，所以二分查找的递归实现的时间复杂度为 O(log n) 



第一个时间复杂度：

外层循环是O(logN)，第二个for，i和次数n是挂钩的，这时候通常的方法就不起作用了。先写一下`sum++`操作的运行次数：

1 2 4 … N，等比为2，次数n为：![image-20210913151130175](/image-20210913151130175.png)，等比数列的和是：2^n-1=2N-1，其实是O(N)级别的算法。
第二个时间复杂度：

外层循环是O(logN)，内层是：N，复杂度是：O(NlogN)

第三个：次数：1+2+……+N=N(1+N)/2，就是O(n^2)，是简单选择排序

```java
 int sum = 0;
//一：
        for (int i = 1; i < N; i *= 2) {
            for (int j = 0; j < i; j++) {
                sum++;
            }
        }
//二：
        for (int i = 1; i < N; i *= 2) {
            for (int j = 0; j < N; j++) {
                sum++;
            }
//三：
        for (int i = N - 1; i > 1; i--){
   			 for (int j = 1; j < i; j++){
        		if (a[j] > a[j + 1]){
           			 ，，，，，
       		 	}
```



有一个字符串数组，最长的字符串长度为 s，数组中有 n 个字符串，将数组中的每一个字符串按照字母序排序，之后再将整个字符串数组按照字典序排序。两步操作的整体时间复杂度：每个字符串都按照字母序排序 O(n * slog s)，数组按照字典序排序O(s * nlog n)，故总的：O(n*s*(log s + log n))



空间复杂度：

只需要额外的几个变量就可以实现相关的操作的时候额外空间复杂度就是O(1).
需要额外的开辟一个与原数组同等规模的数组的话，这个时候的空间复杂度就是O(N)
一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息



#### 2、try/finally

1、 ﬁnally 代码会复制了 3 份，分别放入 try ，catch 以及 catch 中有异常的流程，故不管有无异常，finally块中代码一般都会执行 （只执行一次）；在try语句块或catch语句块中有System.exit(0)直接退出程序，故finally不一定会执行

2、finally 语句在 try/catch的 return **执行完成之前执行**：try/catch 中 return 中的操作执行完，先不返回，将结果（包括return中的运算结果）保存到**临时的局部变量 i‘** 中（finally**改不了try的retrun值，但变量若是引用/静态类型则可以改 (堆中)，finally是以try中的结果执行的**）。当try、catch、finally语句里均有return时程序会提前退出，**只用finally的return 的值**。 但ﬁnally 最好不要有 return，会吞掉异常，finally中发生异常，也会吞掉 try/catch 中的异常。

3、try...catch可以没有catch块（运行时异常），但当没用catch块的时候必须得有finally块

**有抛出或异常进入catch（异常后的代码不执行），没有catch则先finally后throw，throw/return 之后方法结束，不会再执行try/finally{}括号外的代码**



输出结果：ACBD

```java
   public static void main(String[] args) {
        System.out.print(fun1());
    }
    public static String fun1() {
        try {
            System.out.print("A");
            return fun2();
        } finally {
            System.out.print("B");
        }
    }
    public static String fun2() {
        System.out.print("C");
        return "D";
    }
```



运行流程：**finally语句先于 return 和 throw语句的结果执行**。最终结果为"eE"	

```java
public class Test {
    private static void test(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            try {
                if (arr[i] % 2 == 0) {
                    throw new NullPointerException();
                }
            } finally {
                System.out.print("e");
            }
        }
    }
    public static void main(String[]args) {
        try {
            test(new int[] {0, 1, 2, 3, 4, 5});
        } catch (Exception e) {
            System.out.print("E");
        }
    }
```



下面程序的输出:3423

```java
    public static String output = ””;
    public static void foo(inti){
        try{
            if (i == 1){
                throw new Exception();  		//进入catch
            }
        } catch (Exception e){
            output += “2”;
            return ;
        } finally{
            output += “3”;
        }
        output += “4”;
    }
    public static void main(String[] args){
        foo(0);	//34
        foo(1);		//try代码块抛出异常，进入catch代码块，return后就结束方法
        System.out.println(output); 	//3423
    }
```



输出：10 	9	return的值： 8

```java
int i=10;
try{
i = i/0;  		//进入catch
return --i;		//不执行
}catch(Exception e){	
System.out.println(i);
return --i;
}finally{
System.out.println(i);
return --i;
}
```



输出：20   45

```java
public static void main(String[] args) {
    System.out.print(test1());
}
public static int test1() {
    int a = 20;
    try {
        return a + 25;  //a还是20啊
    } catch (Exception e) {
        System.out.println("test catch exception");
    } finally {
        System.out.print(a + " "); //输出20
        a = a + 10;  
     }
     return a;   //不执行
 }
```



#### 3、设计模式

​	结构型模式中最体现扩展性的模式是**装饰模式**：动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活**，可以说装饰模式是继承关系的一种替代方案**

​	适配器模式是将一个类的接口转换成客户希望的另外一个接口，兼容接口不同的类在一起工作。

<img src="/20181026153243388.PNG" alt="img" style="zoom: 67%;" />

​	桥接模式将抽象部分与它的实现部分分离开来，使他们都可以独立变化。

​	 组合模式将对象组合成树形结构以表示部分-整体的层次结构

​	在委托事件模型中，源生成事件并把它发送给一个或多个监听器，每个**监听器必须向事件源注册**

​	Struts框架基于MVC模式，由3类组件构成：控制器组件、模型组件、视图组件

​	备忘录模式(Memento Pattern)，在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便在适当的时候恢复对象

<img src="/image-20210928200616352.png" alt="image-20210928200616352" style="zoom: 67%;" />

责任链模式里，很多对象由每一个对象对其下家的引用(next)而连接起来形成一条链

<img src="/image-20210928200714928.png" alt="image-20210928200714928" style="zoom:80%;" />

生成器模式又叫建造者模式，功能是使用简单的对象一步步构造成复杂对象

![img](/310461_1557413711330_4A47A0DB6E60853DEDFCFDF08A5CA249)

观察者模式：当一个对象被修改时，则会自动通知它的依赖对象

领域驱动设计：



**设计模式的六大原则：**

（1）开闭原则 (Open Close Principle) ：
    **指的是对扩展开放，对修改关闭**。不能去修改原有的代码，就需要使**用接口或者抽象类。**
（2）依赖倒转原则 (Dependence Inversion Principle)：
    是开闭原则的基础，指的是**针对接口编程，依赖于抽象而不依赖于具体**
（3）里氏替换原则 (Liskov Substitution Principle) ：
     **指的是任何基类可以出现的地方，子类一定可以出现替换。** 是对 “开闭原则” 的补充，是对实现抽象化的具体步骤的规范。
（4）接口隔离原则 (Interface Segregation Principle)：
     **使用多个隔离的接口，比使用单个接口要好，降低接口之间的耦合度与依赖，**方便升级和维护方便
（5）迪米特原则 (Demeter Principle)：
	**也叫最少知道原则，指一个类应当尽量减少与其他实体进行相互作用，降低耦合关系。**过分的使用会产生大量的中介和传递类
（6）合成复用原则 (Composite Reuse Principle)：
   **尽量使用组合/聚合的方式，而不是使用继承。**



#### 4、Thread线程方法

​	**run()方法执行线程**；run()方法只是一个普通方法，没有实现多线程，直接调用Run方法会执行run方法，程序中依然只有主线程，还是按代码顺序执行

​	**start()方法启动线程，使其进入就绪状态**；用 start方法来启动线程，是真正实现了多线程，此时无需等待run()方法执行完毕，即可继续执行下面的代码

​	sleep()方法使线程进入睡眠状态

​	suspend()方法使线程挂起，要通过resume()方法使其重新启动

​	A.join()；线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。

​	A.yield(); A让其他线程先执行

wait/notify/notifyAll 是object的方法，释放锁，都为final方法，无法被重写；sleep是Thread的静态方法，不释放锁，必须捕获异常。

wait和notify，await()/signal() 规定要在同步块（synchronized（同一把锁））中使用，否则会抛出 llegalMonitorStateException ；原因是方法是线程之间的通信，避免 wait 和 notify之间产生竞态条件：消费者线程count=0没来得及调用wait，之间可能会被生产者线程改了count值并notify了，这样就一直wait了。

Condition.await/signal/signalAll **更加安全和高效**，在 lock.lock()和lock.unlock之间才可使用，也是同步块。



三个线程T1，T2，T3顺序执行：

① T3先执行，在T3的run中，调用t2.join，让t2执行完成后再执行t3，在T2的run中，调用t1.join，让t1执行完成后再让T2执行

② 使用condition的await和signal方法，T1的的lock和unlock之间c1.await，c2.signal；T2用c2.await，c3.signal；T3用c3.await，c1.signal



Thread的中断机制(interrupt)：

Thread.join/sleep，object.wait，CyclicBarrier.await ，condition.await，IO等线程阻塞状态时，若被打断（中断标志为true）则抛出异常 InterruptedException且立即将线程的中断标标志置为false，是编译时异常（checked exception），要本函数必须处理的（runtime exception不必须），用try和catch或throws抛出。

线程中断或停止：InterruptedException异常被捕获或调用了wait等方法（当前线程创建了一个新的线程不会使线程中断）。stop()线程会立即终止，可能会引起数据不一致的问题(stop()方法已经被废弃不推荐使用)

**synchronized 产生了死锁也不可能被中断，reentrantLock.tryLock(long timeout, TimeUnit unit)可中断，允许程序打破死锁**

输出：interrupt	InterruptedException        不输出final和exit，中断标志为false一直循环

```java
public class Test implements Runnable {
    @Override
    public void run() {
    //判断中断标志是否为true，不更改中断标志。不要使用thread.interrupted()，判断后会将中断标志设置为false    
        while (!Thread.currentThread().isInterrupted()) {  
            synchronized (this) {
            try {
                wait();
            } catch (InterruptedException e) {	//捕捉到InterruptedException异常的时就将中断标志置为false，想要还是ture就在下一行加一个hread.currentThread().interrupt()重新置为true 或者直接自己定义一个标志判断 或者继续上抛
                System.out.println("InterruptedException");
            }
        }
    }
    System.out.println("Final");
}
public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(new Test());
    thread.start();
    new Thread(() -> {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
        }
        thread.interrupt(); //并不能立即中断线程，设置该线程中断标志为true，进入异常，至于是否中断还取决于线程自己。catch中的内容比main线程晚执行
        System.out.println("interrupt");
    }).start();
    thread.join();
    System.out.println("exit");
    }
}
```



```java
public class Main{
    public static List<String> list = new ArrayList<>();
    public static void main(String[] args) throws Exception{
        Thread t1 = new Main().new MyThread();
        Thread E10:E64t2 = new Thread(new Main().new MyRunnable());
        t1.setPriority(3);
        t2.setPriority(8);   //优先级高的先执行，默认的优先级是5.
        t1.start();
        t2.start();
        t2.join();
        for (int i = 0; i < 100000; i++) { i++;}
        list.add("main");        
        t1.join();
        for (String s : list) {
            System.out.println(s);  //输出：Thread 1   Thread 2   main
        }
    }
    class MyThread extends Thread{
        @Override
        public void run(){
            for (int i = 0; i < 100000; i++) {     i++;  }
            list.add("Thread 1");
        }
    }
    class MyRunnable implements Runnable{
        @Override
        public void run(){
            for (int i = 0; i < 100000; i++) {
                Thread.yield();
                i++;
            }
            list.add("Thread 2");
        }
    }
}
```



#### 5、URL

URL u =new URL("http://www.123.com");。如果www.123.com不存在，则返回 www.123.com

new URL 确实要抛异常，但是这个异常属于IOException（字符串格式和URL不符导致）



#### 6、Servlet

servlet：是一套技术标准，service方法在servlet生命周期的服务期，默认在javax.servlet.http.**HttpServlet 类中实现**，根据HTTP协议的请求方法（GET/POST等），将请求分发到doGet、doPost等方法实现，产生动态http响应。**servlet在多线程下其本身并不是线程安全的**，

servlet处于服务器进程中，它通过**多线程方式运行其service方法**，一个实例可以服务于多个请求，且其实例一般不会销毁，而CGI(Common Gateway Interface通用网关接口) 对**每个请求都产生新的进程**，服务完成后就销毁，所以效率上低于servlet。

为了能够输出HTML格式内容，需要编写大量重复代码。为了解决这个问题，基于Servlet技术产生了JSP（JavaServet Pages）技术。Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。 

Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。

(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet

(2)创建：通过调用**servlet构造函**数创建一个servlet对象（实例），**创建Servlet实例是在初始化方法init()之前**

(3)初始化：调用init方法初始化

(4)处理客户请求：每当有一个客户请求，容器**会创建一个线程**来处理客户请求，执行service()方法，执行相应的doGet()/doPost()

(5)卸载：调用destroy()方法让servlet自己释放其占用的资源，方法仅执行一次，即在**服务器停止且卸载Servlet时执行该方法**



Applet 类是所有 JAVA 小应用程序的基本类， Applet 的生命周期涉及 init() 、 start() 、 stop() 和 destroy() 四种方法

ServletConfig接口默认是GenericServlet实现

<img src="/image-20210828151012620.png" alt="image-20210828151012620" style="zoom:80%;" />



web容器：例如tomcat，用于接受、响应客户端的请求，负责将HTTP请求转换为HttpServletRequest对象，也就是创建servlet实例对象 

jsp网页：java的服务器页面，其本质也是一个servlet，由html网页代码、Java代码、jsp标签组成，当servlet处理完数据后会转发给jsp，jsp负责显示数据



#### 7、Spring

Spring：对象是皇上，IOC容器是太监，当皇上挑选妃子时不用管，只要到容器即可，太监则根据皇上喜好找到对应依赖或其他对象。

​	Spring本身并不直接管理事务，而是提供了事务管理器接口，Spring提供了对**编程式事务**和**声明式事务**的支持，编程式事务是嵌在业务代码中的，而声明式事务	是基于xml文件配置。

```
int propagationBehavior;  /*事务的传播行为*/
int isolationLevel;        /*事务隔离级别*/
int timeout;              /*事务完成的最短时间*/
boolean readOnly;        /*是否只读*/
```



#### 8、多线程

下面代码可能运行结果：A B C  A B C A B C ，A B C A  A B C A B C，AABBCCAABBCC

```java
public class NameList{
    private List names = new ArrayList();
    public synchronized void add(String name){    //同步方法只代表本次调用方法不会被其他线程干扰，
        names.add(name);
    }
    public synchronized void printAll() {
        for (int i = 0; i < names.size(); i++){
            System.out.print(names.get(i) + ””);
        }
    }
    public static void main(String[]args) {
        final NameList sl = new NameList();
        for (int i = 0; i < 2; i++){
            new Thread(){
                public void run(){
                    sl.add(“A”);
                    sl.add(“B”);
                    sl.add(“C”);
                    sl.printAll();
                }
            } .start();
        }}}
```

线程内顺序执行，线程间交叉执行。第一次打印的长度在3~6之间；第二次打印集合长度是6



a 是一个由线程 1 和线程 2 共享的初始值为 0 的全局变量，最终 a 可能是：-1、0、-2

```java
boolean isOdd = false;
for(int i=1;i<=2;++i){
if（i%2==1）isOdd = true；
else isOdd = false；
a+=i*(isOdd?1:-1)；   //不加上a，第一次1，第二次-2
}
```

![image-20210901145218803](/image-20210901145218803.png)



#### 9、ThreadLocal**

对于**多线程资源共享的问题**，同步机制采用了“以时间换空间”（提供一份变量，让不同的线程排队访问），而ThreadLocal采用了“以空间换时间”

**为每一个线程维护了一个变量副本，各个线程可以独立更改自己的变量副本，避免多线程同时访问资源影响**

​	**每一个线程都有个用ThreadLocalMap存的变量，key就是ThreadLocal（弱引用，直接回收），值为就是变量的副本**

​	ThreadLocal的**set()/get()方法**，先获取当前线程对象和ThreadLocalMap对象，再存/取该线程变量的本地副本

​	ThreadLocal 线程私有互斥的，存放的值(局部变量)是线程封闭，保证各个线程间数据安全；在本线程内随时随地可取，避免通过参数来传递

​	ThreadLocal并没有继承自Thread，也没有实现Runnable接口。 

​	**threadlocalmap使用开放地址法**（**线性探测法**，发现已被占用则寻找下个新的；元素都放在数组中）解决hash冲突，因为经常需要清除无用的对象，使用纯数组更加方便；hashmap使用链地址法（都放在链表中）

使用：**数据库事务操作，spring的事务管理器使用ThreadLocal为不同的线程维护一套独立的connection 副本，保证线程之间不会互相影响**

<img src="/image-20210828155839002.png" alt="image-20210828155839002" style="zoom:67%;" />

ThreadLocal 内存泄漏：

key使用弱引用原因：ThreadLocalMp中的每一个Entry的key都是指向了一个threadlocal，若是这个key是一个强引用，当外界对指向threadlocal的强引用回收之后，就说明这个threadlocal就没用了，但是此时还有map中的key也是强引用，就无法对threadlocal进行回收，就可能内存泄漏。所以使用了弱引用，只有弱引用指向的对象，在下次垃圾回收时就会被回收。

虽然 ThreadLocalMap 的 key 是弱引用，但 value 是强引用 ，**只要用户线程还存活（使用线程池一直存活）就会保留 value 不会回收**，但是key为null导致value不能被访问到，这样就存在了内存泄漏。所以ThreadLocalMap没有显式地删除时，就会一直在内存中。

解决办法：每次使用完ThreadLocal都调用它的**remove()方法**清除value数据（key （ThreadLocal）是弱引用不用手动删除，不要使用ThreadLocal.set(null)，并没有清除这个键值对）；

将map的key：ThreadLocal 变量定义为private static，这样key就存在一个强引用，保证任何时候都可通过key访问的value的值进而清除掉。

如：private static ThreadLocal<SimpleDateFormat> local = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy:MM:ddHHmm"));SimpleDateFormat是线程不安全的，在多线程可以借助ThreadLcoal来保证一个安全问题



#### 10、Socket

客户端通过new Socket()方法创建通信的Socket对象，服务器端通过new ServerSocket()创建TCP连接对象 ，accept接纳客户端请求

​	**ServerSocket** (int port)：创建一个serversocket 绑定在特定的端口

​	**Socket**(InetAddress address, int port)：创建一个socket流，连接到特定的端口和ip地址

![img](/4552908_1476667093647_1915F9C678C8EA2DBDCFB50383935889)

![img](/8955099_1521189690989_0BB28C2A1ECCC47EC020E89E8A554BBC)

accept 发生在三次握手之后，三次握手完成后，客户端和服务器就建立了tcp连接并可以进行数据交互了。accept阻塞直到由客户端连接。



#### 11、Sql语句

每个省份中名称以'州'为结尾的城市数量降序排序，包含相同数量的省份以省份名称降序排序，最终输出第二多以及第三多的省份以及数量：

select province, count(*) c from test where city like '%州' group by province order by c desc, province desc limit 1,2；（limit（初始，量）从0下标开始 ，limit(量)一个参数是从0开始选几个）



每位学生的期末考试成绩以及补考成绩都录入到course表，学号为20190001的同学查询自己未通过的课程的课程编号与课程名称

select distinct cid,cname from course where cid not in (select cid from course where score > 60) and sid=20190001；**（补考大于60 也算通过，条件not>60）**



表account记录着今年的每一笔开支，想查看一下3月和7月这两个月份哪个月份的消费总额最高：

select month,sum(pay) s from account where month in (3,7) group by month order by s desc limit 1; （不用 m = 3 and m= 7 后一个条件将前一个条件覆盖掉，in相当于m = 3 or m= 7或m between 3 and 7）



从table表得到每门课都大于80分的学生姓名：select name,sum(case when fenshu<=80 then 1 else 0 end) scr from table group by name having scr=0;

或select distinct a.name from table a left join (select distinct name from table where fenshu <= 80) b on a.name=b.name where b.name is null;



给一个stu表含有stu_id name major score四个个字段（每个学生上多门课），求总分最多的那个人信息

```
SELECT stu.stu_id, stu.name, sumScore from stu 
inner join (SELECT stu_id, SUM(score) sumScore FROM stu GROUP BY stu_id) temp
on stu.stu_id = temp.stu_id ORDER BY sumScore DESC LIMIT 1;

只找id：SELECT stu_id, SUM(score) sumScore FROM stu GROUP BY stu_id ORDER BY sumScore DESC LIMIT 1
```



group by：

多个字段进行分组时，需要将name和grade看成一个整体，只要是name和grade相同的可以分成一组

select 查询字段要与group by中的字段相同或为聚合函数



求和用累加sum()，求行（行row，列col）的个数用累计count()。

select count(*) 会扫描所有列，只要某一行有一个字段有值就累计此行。count ( xx字段 ) 会将xx字段值不为null 的行累加1，为null的不计入

select count(1) 不会扫描所有列，返回结果和count(*)一样。



ORDER BY子句后未指定ASC或DESC，默认使用ASC。



show index from tableA  查看表tableA的索引（没有s）



#### 12、final

能不能被一个包访问是和访问控制符有关系，和final无关

​	final 变量不允许再次赋值：基本数据类型不能改变；引用类型**不能改变引用**，但里面的**值是可以改变**的 ；**final 变量必须初始化赋值或者在构造函数中赋值。**

​	final 类不能被继承，final 方法可以被子类继承，**但是不能被重写（覆盖）。**

​	被fianl修饰的变量不会自动改变类型；**final 和 volatile/abstract 不一起用**

final声明的方法是不能被覆盖的，但是这里并不错误，因为父类方法是private的，也就是**子类没有继承父类的run方法**，并不是覆盖（重写）。调用子类的

```java
class Car extends Vehicle{
    public static void main (String[] args){
        new  Car(). run();
    }
    private final void run(){
        System. out. println ("Car");
    }
}
class Vehicle{
    private final void run(){
        System. out. println("Vehicle");
    }
}
//输出：car
```



为什么局部内部类和匿名内部类只能访问局部final变量：类编译后会**生成两个class文件**，内部类和外部类是同一级别的，内部类不会随着外部类方法的的执行完就销毁，故方法的局部变量要**复制一份到内部类中**，又必须要保证复制的变量不会变，故最终将局部变量设置为final。

```java
public void outPrint(final int x) {
		class InClass {
			public void InPrint() {
				System.out.println(x);
				System.out.println(age);
			}
		}
		new InClass().InPrint();
	}
```



#### 13、HttpSession

**HttpSessionAttributeListener**：获取web应用程序中**会话属性列表更改（绑定/删除属性）**的通知

​		HttpSessionBindingListener：会话中**绑定或者解绑一个对象**时通知该对象

​		HttpSessionListener：当web应用程序中的活动**会话列表发生更改时**通知该接口的实现类

getParameter()是获取POST/GET传递的**参数值**；getInitParameter获取Tomcat的server.xml中设置Context的初始化参数

getAttribute()是获取对象容器中的数据值（**属性值**）；
getRequestDispatcher是请求转发。



#### 14、会话跟踪

会话跟踪使Web上的状态编程变为可能，有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。
		1）.隐藏表单域：<input type="hidden">，适合大量数据存储的会话应用。隐藏域在页面中对于用户是不可见的。
		2）.URL 重写：URL 可以在后面附加参数，这些参数为名字/值对。可以将jsessionId存放在cookie中，也可以通过重写url将jsessionId拼接在url。因此可以查看浏览器cookie或地址栏url看到 jsessionId；
		3）.Cookie：服务器使用 SET-Cookie 将它作为 HTTP响应的一部分传送到客户端，cookie存放在客户端，可以分为内存cookie和磁盘cookie。内存cookie在浏览器关闭后消失，磁盘cookie超时后才消失。当浏览器发送请求时，将自动携带对应cookie信息，前提是请求url满足cookie路径； 
		4）.Session：session对象在服务端维护，一般tomcat设定session生命周期为30分钟，超时将失效，也可以主动设置无效；使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话，请求到服务端时，将根据请求中的jsessionId查找session，如果可以获取到则返回，否则返回null或者返回新构建的session，老的session依旧存在。



#### 15、字节流和字符流

输入输出相对于内存而言，可分字节流和字符流，out/inputStream是字节流输出/入流，Writer/Reader字符流输出/入流；另一种分：节点流和处理流，

InputStreamReader只是 byte->char的 桥梁，OutputStreamWriter 将字符流转换为字节流，**只用于转换，不能用于字符的输出！**

字符流=字节流+编码集，故和**字符流有关的类都拥有操作编码集(unicode)的能力。**

​	**JAVA常用的节点流：**可以从/向一个特定的地方（节点）读写数据。

- 文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。
- 字符串 StringReader StringWriter 对字符串进行处理的节点流。
- 数 组 ByteArrayInputStream...  CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。
- 管 道 PipedInputStream ... PipedWriter对管道进行处理的节点流。

**常用处理流（关闭处理流使用关闭里面的节点流）:**是对一个已存在的流的连接和封装。一个流对象经过其他流的多次包装，称为流的链接。

- 缓冲流：BufferedInputStream...  BufferedWriter 增加缓冲功能，避免频繁读写硬盘。

- 转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。
- 数据流 DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来.

**流的关闭顺序:**

1. 一般情况下是：先打开的后关闭，后打开的先关闭

2. 另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。

3. 可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。

   

#### 16、字面量

下面的代码：**编译错误**。++() 括号里面必须是一个变量，而 i ++ 是一个字面量。（给基本类型/String 赋的值即字面量，int i = 1整数1就是Java字面量）

```java
int i = -5;
i = ++(i++);
```



#### 17、编解码

编码格式由浏览器决定，浏览器根据html中指定的编码格式进行编码；Web 容器诸如 Tomcat 默认解码是ISO-8859-1，可以显示指定解码格式通过调用 request.setCharacterEncoding("UTF-8")，或者修改tomcat的配置文件server.xml中的编码，添加uriEncoding属性。另外get请求和post请求对编码格式的处理也是不同的

Java一律采用Unicode编码方式，不论什么语言一个字符都占用2个字节

不同的编码之间是可以转换的，若数据库是GBK编码，那显示的网页不一定是GBK编码

UTF（Unicode Transformation Formats），有UTF-8/UTF-16/UTF-32，Java的class文件编码为UTF-8，而Java虚拟机中通常使用UTF-16的方式保存一个字符，UTF-8编码一个中文占3个字节，一个英文占1个字节（8位）

ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的



GBK编码字节流到UTF-8编码字节流的转换：dst=new String(src，"GBK").getBytes("UTF-8")；//先通过GBK编码还原字符串，String没有decode和encode方法



#### 18、并发和并行/同步异步

并行（异步）：同一时刻互不干扰执行；	并发：同一时间间隔交替执行；	串行：一个一个执行，前面执行完才可以执行后面

同步：顺序执行。

异步：不要等待这一事件完成后再工作，让调用方法的主线程不需要同步等待另一个线程的完成，从而让主线程干其他事情。



#### 19、序列化

对象序列化，将对象以二进制的形式保存在硬盘上。反序列化，将二进制的文件转化为对象读取

Serializable是一个空接口，起标记作用，具体的序列化由ObjectOutputStream和ObjectInputStream完成。序列化的是对象，类变量不会被序列化。static 或transient 修饰的变量不参与序列化（不保存在磁盘中）

string实现了Serializable接口，所以能被序列化和反序列化

```java
public class DataObject implements Serializable{
    private static int i=0;
    private String word=" ";
    public void setWord(String word){
        this.word=word;    //this表示全局的变量，不是复制的，所以会改变word
    }
    public void setI(int i){
        Data0bject. i=I;
     }
}
//执行如下操作，并将此对象序列化为文件，并在另外一个JVM中反序列化读取文件，则此时读出的word和i的值分别为："123", 0
DataObject object=new Data0bject ( );
object. setWord("123");
object. setI(2);
```



#### 20、Object类

Object是所有类的父类，任何类都默认继承Object。Object类实现的方法：

1．clone方法

保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。

2．getClass方法

final方法，获得运行时类型。

3．toString方法

该方法用得比较多，一般子类都有覆盖。

4．finalize方法

该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。

5．equals方法

6．hashCode方法

该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。

7．wait方法

wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。

调用该方法后当前线程进入睡眠状态，直到以下事件发生。

（1）其他线程调用了该对象的notify方法。

（2）其他线程调用了该对象的notifyAll方法。

（3）其他线程调用了interrupt中断该线程。

（4）时间间隔到了。

此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。

8．notify方法

9．notifyAll方法



#### 21、java关键字

​	1）48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。

​	2）**2个保留字（现在没用以后可能用到作为关键字）**：goto、const。

​	3）**3个特殊直接量：true、false、null。** 



#### 22、java变量**

Java中变量有两种类型：①原始类型（基本类型）：六种数字类型，一种字符类型，一种布尔型。② 引用类型。③ java5新增了**枚举（enum）类型**

![img](/9190126_1475723846442_DBF69CBC1D813F96C161209A36A3B5D8)

```java
byte b1=1,b2=2;
final byte b3=3,b4=4,b5;
b2=(b1+b2);            //编译错误，结果自动转为int，可以为b2=(byte)(b1+b2)或者将b2定义为int；两个short相加也一样是int
b2+=b1;					//正确，相当于b2=(b2)(b2+b1)，+= 会自动强制转型为左边的类型，适用于包装类型
b5=b3+b4;   			//正确，不会自动提升，和的类型视左边变量类型而定，即b5可以是任意数值类型；
b4=b3+b4; 				//编译错误，final不能改显示赋的值
b2=(b1+b3);  			//编译错误，虽然b3不会自动提升，但b1仍会自动提升，结果自动转为int
b1 = (char) 1 + (short) 1 + (int) 1; // 正确，常量任君搞
i = (long) 1 // 错误
```

Java**自动转型**规则**由低到高转换**（向上转型）：**强制转型**用于向下转型

1、所有的byte,short,char型的值将被提升为int型；如果有一个操作数是long型/float型/double型，计算结果是long型/float型/double型；**boolean类型不能和任何类型进行转换，会报出类型转换异常错误。**

2、**被fianl修饰的变量不会自动改变类型**且只可赋值一次，当2个final修饰相操作时，结果会根据左边变量的类型而转化。

3、基本类型之间的**比较（==，>，<），会将低精度类型自动转为高精度类型再比较。**int/integer和Integer用<比，Integer会拆箱。String和String可以用 > 比较内容，包装类型不可以，可以把包装类型Integer.parseInt转为基本类型/equals 比较；String/包装类型之间的比较也可用： s1.compareTo(s2)前面的小返回-1。

<img src="/image-20210816112338211.png" alt="image-20210816112338211" style="zoom:80%;" />

精度丢失发生在**向下转型**，但int类型的数没有超出（byte，short，char）的表述范围（127），可以直接byte a=23。超出报错



**int和long类型的除法都会有精度缺失问题**

Integer.parseInt();转化成的是int类型，不是Integer，同理Double.pareseDouble()

Integer.parseInt("");转换为**int基础数据类型**，Integer.valueOf("") 转换为Integer对象，Integer.intValue(); 返回基础数据类型int

Integer.MAX_VALUE,得到最大值



注意：int整数相乘溢出，得到的是负数

计算一天微秒：long m= 24 * 60 * 60 * 1000 * 1000;  运算完成之后，已经是负数了才被升为long。可以 long m= 24L * 60 * 60 * 1000 * 1000;



对于像金额这一类数值类别，推荐使用 **java.math.BigDecimal** 类，数值作为 **字符串** 传递给构造函数，不然仍会发生精度丢失问题

 BigDecimal b1 = new BigDecimal(Double.toString(2.0));	b1.add/subtract/multiply/div(b2).doubleValue()



使用BIGDECIMAL使long类型太大自动转化为科学计数法：

```
BigDecimal.valueOf(byte2Mb(1400993242333333333L)).toString()
```



Java采用unicode来表示字符，java中的一个char是2个字节，一个中文或英文字符的unicode编码都占2个字节。在GBK 编码中，一个英文字母字符1个字节，一个汉子字符2个字节。在UTF-8编码中，一个英文字母字符1个字节，一个汉字字符3到4个字节。



自动装箱，**只能装对应的数据类型**；**装箱是Integer.valueOf方法实现的，拆箱是 i.intValue 方法**

```java
Double d=100; //报红杠，100默认是int
double d=100;//没有问题，100是int类型，自动转换为double
Double d=100.0;//没有问题，自动装箱
Double d=100.0f;//报红杠
float f = 45.0; //错误，不加f 默认是double类型，不能自动强制向下转型
Integer i3=(byte)100;//报红杠

Short s = (byte) 100;//没有问题，是不是很神奇？说明上面的规律对Short不适用

Double d=Double.valueOf("100"); //正确
Double d=Double.valueOf(100);//正确
Double d=new Double(100);//正确

Object o = ‘f’; //正确
char s = ‘\u0639’;	//正确 \U十六进制的Unicode
double d = 0x12345678;   //正确 ，十六进制整数，没超范围，自动转为双精度浮点数
boolean b=3>5  //正确
c=a---b   //等价与：c=(a--)-b 
```

二进制： Binary，八 ：octal，十：decimal，十六 ：hexadecimal



```java
public static void main(String[] args) {
Object o1 = true ? new Integer(1) : new Double(2.0);
Object o2;
if (true) {
 	o2 = new Integer(1);
} else {
	o2 = new Double(2.0);
}
System.out.print(o1);   //不输出int       
System.out.print(o2);
}
```

运行结果:1.0 	1

三元运算符会对两个操作数进行自动的类型提升。

**总结：**

三目，一边为byte另一边为char，结果为int；其它情况结果范围大的(适用包装类型)		byte:short===>short。**byte:char==>int**。byte:byte==>byte
表达式，两边为byte,short,char，结果为int型；其它情况结果为范围大的（适用包装类型）    byte+short=int



x=x+1,x+=1及x++的效率哪个最高？为什么？ 
x=x+1最低，因为它的执行如下。 
（1）读取右x的地址； 
（2）x+1； 
（3）读取左x的地址； 
（4）将右值传给左边的x（编译器并不认为左右x的地址相同）。 
x+=1其次，它的执行如下。 
（1）读取x的地址； 
（2）x+1； 
（3）将得到的值传给x（因为x的地址已经读出）。 
x++最高，它的执行如下。 
（1）读取右x的地址； 
（2）x自增1.

x=x+1,和 x+=1; 在什么情况下不成立 而且 x=x+1 是错误的; （类型隐式转换）如： short x=1; 结果会会自动转变成int 



#### 23、成员/局部/static静态

成员变量有默认初始值，可不用赋值，boolean的默认值为false， 局部变量（定义方法中）必须显示赋值（用之前赋值就行），无初始值就使用**编译出错**。

若s在方法外，静态方法直接引用非静态变量/非静态方法（实例方法）会编译出错。静态方法要想调用类中的非静态变量，**可在静态方法中创建类的对象调用**。

```Java
public static void main(String[] args){
    String s;
    System.out.println("s="+s);   //用对象.变量调用，局部变量调用前要赋值
}
```

**外部类、局部变量（属于方法，而static属于类）不能用 static修饰。**下面代码编译报错

```Java
public class Test{
    static int a = 1;
    static int b = 2;
    public static void main(String[] args) {
        static String c = "3";
        System.out.println(a+b+c);
    }
}
```



下面代码编译错误，static方法不能访问非静态变量 a 的，需要将 a 声明为static，答案才会是 0 

```java
int a[] = new int[6];
public static void main ( String arg[] ) {
System.out.println ( a[0] );
}
```



#### 24、半双工通信方式

使用消息队列主要是为了通过异步处理提高系统性能和流量削峰、降低系统耦合性。

**管道( pipe )：**管道是一种半双工的通信方式，数据只能单向流动，**而且只能在具有亲缘关系的进程间使用**（父子进程关系）。

**不同的服务器之间的通信，是要求全双工形式的，而管道只能是半双工，虽然可以双向，但是同一时间只能有一个方向传输**

<img src="/m.wendangwang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img" style="zoom:50%;" />



#### 25、构造方法

构造方法的用于完成对象的初始化（属性初始化），只有与类名相同的方法可以叫构造函数（内部类的构造方法名与内部类名相同）。

构造方法没有返回类型，也不能定义为void。

构造方法可以重载。若类没有构造方法，JVM生成一个默认无参构造方法（第一行是super()），若定义了构造方法，编译器都不会自动生成构造方法



1、子类构造器（无参/有参）**第一行默认都是super()，默认调用直接父类的无参构造**，一旦直接父类构造器中没有无参的，那么必须显式调用父类或者自己的某个构造。**super()或this()都只能位于构造器的第一行**，否则编译不通过(不写默认加上super())，super()可以换成this()（子类有显示调用就调用子类显示声明的），但是this()和super()只能出现一个。

3、super，this关键字与super()，this()不是一回事，前者表示当前调用者的父类与其本身，后者是为了**构造器相互调用**。

4、**this()和super()都指的是对象**，**均不可以在static环境中使用**。包括：static变量，static方法，static语句块(里面不能使用非static类型的)。

```java
class Person {
	String name = "No name";
	public Person(String nm) {
		name = nm;
	}
}
class Employee extends Person {
	String empID = "0000";
	public Employee(String id) {		//编译报错
		empID = id;
	}
}
```



```java
public class Base{
int w, x, y ;
public Base(int a,int b){
x=a; y=b;
}
public Base(int a, int b, int c){	//构造方法的重载
	x=a; y=b;	//不能直接Base(a,b);调用构造方法要new Base(a,b);或者this(a,b);，
	w=c;
}}
```



#### 26、if-else if选择

```java
int age = 11;
int a = 0;
if(age < 10){    //执行
    a += 1;		//不执行
}else if(age < 15){		//10<age<15，执行
    a += 2;             //执行
}else if(age < 25){		//15<age<25，不执行
    a += 3;				//不执行
}		
//上面代码，两个else if如果互换位置，编译可以通过，改变之后对程序的执行结果有影响
```



#### 27、类之间常见关系

类：use-a 是依赖关系（ a类引用了b类，就可以说a类依赖b类）		has-a  一般是组合关系		is-a  一般是继承关系 （小米手机是一个手机） 

接口：like-a（飞行器像鸟一样飞行）



#### 28、JDBC

加载驱动方法：

1.**Class.forName**("com.microsoft.sqlserver.jdbc.SQLServerDriver");

2.DriverManager.**registerDriver**(new com.mysql.jdbc.Driver());

3.System.setProperty("**jdbc.drivers**", "com.mysql.jdbc.Driver");

```
JDBC步骤：
Class.forName("com.mysql.jdbc.Driver");  //加载jdbc驱动
con=DriverManager.getConnection(url,user,password); //建立连接
stmt=con.createStatement(); //创建语句执行者（statement用于执行不带参数的简单sql语句，PreparedStatement带参数的预编译sql语句，能够预防sql注入，CallableStatement对象用于执行对存储过程的调用）  
stmt.execute(“sql语句”); 
rs=stmt.executeQuery("sql查询语句"); //结果集
stmt.close;  //关闭JDBC对象    
```



JDBC用到 桥接模式 ：将抽象与实现分离，使它们都可以独立地变化。JDBC提供了统一接口，可以根据需求能够动态切换不同的数据源，无需动太多的代码



#### 29、继承/实现

父类方法有throws Exception，子类重写可不抛出






#### 30、循环和()判断

for循环的执行顺序：ABDCBDCB

```java
static boolean foo(char c)
 {
 System.out.print(c);
 return true;
 }
 public static void main(String[] args) {
 int i =0;
 for(foo('A');foo('B')&&(i<2);foo('C'))
 {
 i++;
 foo('D');
 }
 }
```

for/while循环执行顺序：

<img src="/image-20210826153640794.png" alt="image-20210826153640794" style="zoom: 67%;" />



while（）中表达式在C语言中大于0的int值为true，而 java 中不能，必须是boolean类型的

```java
Boolean flag = false;
if (flag = true){}   //可以这么写，if肯定会走
```



死循环”的两种写法，for (；；) 底层完 指令少，不占用**寄存器**，而且没有判断跳转，比while (true) 好





#### 31、synchronized锁

类锁和对象锁互不干扰，是两个对象

```java
public class Test {
    private synchronized void a() {}		//同步方法使用的锁是固有对象this，实例对象,方法a和方法b锁住的是同一个对象
    private void b() {
        synchronized (this) {}				//同步块使用的锁可以是任意对象，方法b里锁也是对象this
    }
    private synchronized static void c() {		//为静态同步方法，使用的锁是该类的字节码文件Test.class，类对象
    }
    private void d() {
        synchronized (Test.class) {}		//锁的是类对象，方法c和方法d锁住的是同一个对象
    }
}
```

 用synchronized修饰所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，只能分配给一个线程，因此叫做互斥锁，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。



#### 32、SPI

spi 机制 是Java内置的一种寻找服务实现的机制，通过定义一个接口去外部寻找接口的具体实现。通过ServiceLoader类 解析classPath或jar包中 MATA-INFO/service 目录下以接口全限定类名命名的文件，并加载该文件中指定的实现类。为框架的动态扩展提供了很好的支持。场景：jdbc可拔插实现。



#### 33、switch

（）中只能支持：jdk1.7之前：byte、short、char、int或者其对应的封装类以及Enum类型。jdk1.7 加入了String 。**实际只支持 int 类型**，byte char short 自动向上转型；包装类自动拆箱机制；String实际比较string.hashCode，再用一个switch的int匹配；enum实际比较的是的 ordinal 值（表示枚举值的顺序）



没有break，发生case穿透现象，程序会继续向下执行，直到结束switch语句为止。下面代码 输入为2时返回值是10（1不执行。default表其他）

```java
public static int getValue(int i) {
int result = 0;
switch (i) {
case 1   
result = result + i;
case 2:
result = result + i * 2;
case 3:
result = result + i * 3;
}
return result;
}
```



#### 34、进程和线程

jvm中没有进程的概念 ，但是jvm中的线程映射为操作系统中的进程，对应关系为1:1。  jvm中使用监视器锁(synchronized )来实现不同线程的异步执行



后台线程也称为**守护线程**，为**所有非守护线程**提供服务，主要用与内存分配等方面，如：JVM的垃圾回收线程。托管线程池的线程都是后台线程

前台线程就是**用户线程**，应用程序的**主线程及new Thread**的线程都默认为前台线程 ；**jre 判断程序是否执行结束**的标准是：所有的前台线程执行完毕

1、某个进程的所有前台线程都终止后，该进程就会被终止。
2、可以将前台线程修改为后台线程（正在运行的不行）：设置Thread.IsBackground 属性。可通过isDaemon()/setDaemon()方法来判断/设置后台线程
3、不管是前台线程还是后台线程，如果线程内出现了异常，都会导致进程的终止。



#### 35、转发和重定向

forward是转发（内部重定向）一个请求；redirect是外部重定向，两个请求。

forward 转发页面和转发到的页面**可以共享request里面的数据**；redirect 不能共享数据。

forward 浏览器不知服务器发送的内容是从何处来，浏览器**地址栏中还是原来的地址**；redirect 服务器端告诉浏览器重新去请求新的URL地址，**地址栏变了**

**redirect默认将产生301** Permanently moved的HTTP响应

forward效率高，redirect效率低。



#### 36、==和equals

== 是运算符，在基本类型中比较的是值是否相同，在引用类型中（类/接口类型、数组类型）**比较地址**；

equals() 是一个方法，对比**引用类型（String），比较 内存地址、地址相同再比较值**，对象重写equals了才有可能比较相等，equals()没有重写的话默认调用"=="（return this==object），和 == 的作用相同。（注意：不是equal方法）



==和equals不能比较两边类型不一样的，如：cha[] 和 String

**int和Integer比较，Integer会自动拆箱，== 和 equals都为true**

**StringBuffer没有重写equals方法，比较用：sb1.toString().equals(sb2.toString())；char用==比较**

Byte、Short、Integer、Long 直接赋值，若在[-128,127]区间内会到缓存池中（new在堆中，不同对象），==比较的时总为true（指向同一对象），在这个区间外会new是不等的。而Float和Double则不相等， Boolean的值总是相等的



hashCode、equals、toString()方法不重写默认调用Object类中的，即使一个类不重写，其对象也能使用

equals 方法重写时 hashcode 也要重写：两对象值一样，则hashcode相同；但hashcode相同，值不一定一样，可以提升效率，equals 是防止有 hashCode 冲突。在向 Hashmap 中添加对象时，会先计算对象的 HashCode 值来确定对象的存储位置，再用equals 方法判断两个对象是否相同。



可以用 list.contains() ,代替某个比较很多其他 equals() 的方法



#### 37、Java基础名词

Java坐标：Java 的屏幕坐标是以像素为单位，容器的**左上角**被确定为坐标的起点。



import：import java.util.* ; 能访问java/util目录下所有类，不能访问java/util子目录下所有类。因为其根目录和子目录下可能有同名类，若都能读取，则会混淆。

import语句并没有将java源文件拷贝到此处仅仅是引入，告诉编译器有使用时候去读取这个外部文件。



Java包：Java包机制是为了更好地组织类，分隔类名空间，与操作系统和IDE工具无关。

外部类不能用private修饰，故定义在同一个包（package）内的类可以不经过import而直接相互使用



冯诺依曼结构的计算机硬件逻辑组成：五个部件：输入设备 输出设备 存储器 控制器 运算器。没有编译器



开源软件可以自己研究学习，不可以商业用途，会侵权



字节码：程序源代码编译成JVM可以理解的代码指令（即.class文件）。

好处：将整个执行过程分为了编译、解释和运行，通过JVM实现了一次编译处处运行的跨平台性



#### 38、jsp

EL 全名为Expression Language，就是为了替代<%= %>脚本表达式。JSP 表达式的写法：

```
(1)<%...%>：可以插入一些语句。
(2)<%! ...  %>：只能放置全局变量、全局常量、类、函数。
(3)<%= ... %>：只能放置一个变量、常量。
```



myjsp.jsp

```jsp
<%@ page language="java" import="java.util.*" errorPage="error.jsp" isErrorPage="false" %>
```

exception是 JSP 九大内置对象之一，只有当页面是错误处理页面时，即isErroePage为 true时该对象才可以使用。

errorPage 是设置当前页面要**引入错误的页面**。**isErrorPage默认值为false**，若要当前页面为错误页面就设置isErrorPage=true。



动态包含：jsp动作实现<jsp:include page="included.jsp" flush="true" /> ，在页面被请求的时候引入一个文件，直到输出时才合并 。不共享request请求域，先编译再包含，是要检查包含页面的变化的。

静态包含：伪码实现 <%@ include file="included.htm" %> ，先包含再编译，不检查包含页面的变化。将其他静态文本（html/jsp) 引入当前jsp。**不允许变量同名**



**Servlet与JSP九大内置对象的关系**，JSP对象 怎样获得

> out->response.getWriter
>
> request ->Service方法中的req参数
>
> response ->Service方法中的resp参数
>
> session ->request.getSession
>
> application ->getServletContext
>
> exception ->Throwable
>
> page  ->this
>
> pageContext  ->PageContext，转发重定向时pageContent内的属性值不能被传递
>
> Config ->getServletConfig



#### 39、正则表达式

大写表示“非”。d表示数字，非数字就是\D； w表示word，非单词就是\W

| ^     | 匹配输入字符串的开始位置。                                   |
| ----- | ------------------------------------------------------------ |
| $     | 匹配输入字符串的结束位置。                                   |
| [a-z] | 匹配指定范围内的任意字符。[ ] 里面是不重复的，如：   ://不能为[://]，应为[:/] |
| {n,m} | 最少匹配n次且最多匹配m次。                                   |
| *     | 匹配前面的子表达式任意次。例如，zo能匹配“z”，也能匹配“zo”以及“zoo”。等价于o{0,} |
| +     | 匹配前面的子表达式一次或多次(大于等于1次）                   |
| ?     | 匹配前面的元素0次或1次                                       |
| \w    | 匹配字母数字或下划线                                         |
| .     | 匹配除了换行符\n \r外的任何字符                              |

​	 http://www.bilibili.com/video/av21061574	===>	/^(http:\/\/)?(\w+)\.bilibili\.com\/?video\/av(\d{1,8})\/?$/



#### 40、GUI

Swing 是在AWT基础上构建的一套新的图形界面系统。**AWT 是基于本地方法的C/C++程序，运行速度较快；Swing是基于AWT 的Java程序，可移植，运行速度较慢。** 图形界面至少要有一个顶级Swing容器： JFrame（框架）：表示主程序窗口； JDialog（对话框）：对话框属于二级窗口； JApplet（小程序）；



#### 41、String、数组、集合方法***

##### String

String 类型的源码1.9前是 final 修饰的 char []数组，结尾不用\0。1.9后用的是byte类型的数组。

不可变性：所指向的内存空间（串池）的内容是不可变），变了产生新对象；但 String 的引用是可变的。

String获取长度用的是length（）方法，而数组类型我们直接用属性length获取长度，所以String[]数组类型我们应该用length获取长度；

 

如果"xyz"没有被创建过，String s =new String(“xyz”);;创建了几个string object？2个。第一个在堆中，第二个在字符串常量池中！如果在Java字符串常量池中已经存在，就只会创建一个。将常量池中的对象**复制一份**放到 heap ，并且把 heap 中的这个对象的引用交给 s1 持有



性能：StringBuilder>StringBuffer>String ，优先使用StringBuilder（不会每次都去申请内存，而是一下子就申请一大块内存），多线程使用共享变量时使用StringBuffer



字符串”ABCD”和字符串”DCBA”进行比较，后面的大（<）。比的是ASCII码，从第一位开始比，若相等则比较下一个字符。==比较的是地址。**全相等则比较长的大**

char可以==，可以'a'<'b'



String S=”UP！UP！JD”，则其子串的数目：37。字符串有8个字符（不加空格），那么非空子串数为8+7+...+2+1=8*9/2=36，加上一个空串。公式n(n+1)/2 + 1，不排除重复的，子串只能由相邻的字符组成，不能调换次序，和集合概念不同。

**s="" (不是null，null是空间都没开辟，用length会报错 ) 时，length为0，s=" "时，length为1。**



```java
//split返回一个数组
String[] arr = str.split(",")
//如果没有找到分隔符，会把整个字符串当成一个长度为1的字符串数组返回（空元素也是1）,若是split(",",2);则数组的长度限制为2
//str = ""        arr长度为1
//str = ",bb,";   arr=[,bb]
//str=","         arr=[],长度为0
str.split("[\\,\\;\\ \\|]");  //逗号，空格，分号， ｜ ，都有可能做分割符，空格也可\\s
String str="han.bb   test@love";
String[] a=str.split("\\s+|\\!|@");  //以 多个空格、！、@(不用转义) 为分割符


//replaceAll，split先默认正则，遇到 “\”，"."，“|”，“*”，"()"都要转义，加上`"\\"或"//"`
//默认匹配正则，"."在正则表达式中表示任何字符。结果为：/////// 。如果想替换的只是"."，可写成"\\."
String c= "com.jd.". replaceAll(".", "/");
s.replace(s.charAt(i),'o');    //字符串某个位置替换

//
s.contains("d")
s.charAt(i)

str=s.replace("()","");  //不改变原字符串s，返回新串
str=s.replaceAll("\\(\\)","");  //要用正则，  
s.substring(int begin)	//s要小写,不改变原字符串

//
s.indexOf('c');
s.indexOf("zzd");  //K，找出 s2 字符串出现的第一个位置，s中没有这样的字符串则返回-1，s2为空字符串时返回0
s.lastIndexOf('o')  //索引位置  ,"o"也行

s.equalsIgnoreCase(“A”) //忽略大小写
s.toLowerCase(); 		//转为小写

String.format(“%04d”, 99);	==> 0099
String.format("name=%s, age=%d", "huhx", 25);  // name=huhx, age=25
 MessageFormat.format("name={1}, age={0}, {1}", 25, "huhx");  // name=huhx, age=25, huhx

StringUtils.leftPad("abc", 10, "*");   //返回结果：`*******abc`

s.trim()      //去掉字符串两端的空格
    
String.jion(",",list);   //在list的每个元素后加",",返回一个字符串
```



##### StringBuilder

Stringbuilder要比较：if("".equals(stringbuilder.toString()))。StringBuilder没有重写equals方法

```java
sb.length();

sb.insert(0,"（");  //在位置零处插入

sb.append("z");  //可以是boolean,char,int,double,,,
sb.append(sb2);  //可以是arr,sb,obj,,,
sb.append(sb2,3,4);//将sb2中索引3开始位置后四个字符追加到sb后

sb.reverse();  //反向

sb.deleteCharAt(sb.length() - 1);
```



##### 数组

数组长度是不可以动态调整；

 java可以有n维数组。注意数组下标有越界异常

数组a.equals(数组b)：调用Object的equals方法，比较的是地址，相当于==，Arrays.equals(数组a,数组b)：对基本数据类型逐个比较，其余类型需要重写

数组元素下标总是从0开始，下标可以是**整数或整型表达式**（ a[i+1]=a[i]）。ResultSet结果集跟普通的数组不同，索引从1开始而不是从0开始

 Arrays.sort()，默认从小到大排，也可对指定的下标排序。	 Arrays.sort(arr2,(a,b)->b-a);要将int数组转为包装类型才行（新建循环），aslist方法也一样		 Arrays.sort(arr,(a,b)->b[0]-a[0]);  按二维数组每行第一个元素对二维数组排序。

```java
arr.toString   //不能打印

Arrays.toString(arr) 	//快速打印一维数组的数据元素列表

Arrays.deepToString(arr)	//快速打印一个二维数组的数据元素列表

//数组初始化：
   // 静态初始化：创建 + 赋值
int[] num={1,2,3}; 
int num[]={1,2,3};
int[] num=new int[]{1,2,3};
int[] num[]={{},{}};      int[][] num={{},{}};  int num[][]={{},{}};
	//动态初始化： 包含默认初始化
int[] num = new int[2]; num[0]=1;num[2]=2
int[][] num=new int[][];

//sort改变原数组
Arrays.sort(arr,2,4);  //只排下标位置，包前不包后 

Arrays.copyOfRange(nums,0,nums.length-1);  //返回nums下标0到len-2元素组成的新数组,包前不包后
```



##### list

如果一个list初始化为{5，3，1}，执行以下代码后，其结果为：[4, 3, 1, 6]

```java
//初始化
List<String> list = new ArrayList<>(set);
List<String> list = new ArrayList<>(map.values());  //将map的valule作为元素加入list
List<String> list = new ArrayList<>(16);  //初始容量 

nums.add(6);
nums.add(0,4);	//在list的第0个位置添加4，list变为｛4,5,3,1,6｝;不是替换
nums.add(list2); //list2作为nums的一个元素
nums.addAll(list2);//list2的元素全加入nums中
nums.remove(1);	//1是int类型，移除list的指定下标元素，list变为｛4,3,1,6｝
nums.remove(1);	//1是Integer类型，移除list中第一个匹配的指定值，之后的每一个元素都会向前移动一个下标，所以在循环中不能使用list.remove方法
nums.set(1,"5");  //将下标1位置的元素更改为“5”


//简单数据,求全，交，差，结果都放入了list2中
//全集
list2.addAll(list1)
//交集
list2.retainAll(list1); 
//差集
list2.removeAll(list1);

list.size() //是元素个数，而不是开辟空间大小

list2=list1;  //不算是拷贝，不管是改基本类型还是引用都会改变原来的
//浅拷贝，拷贝引用地址，还是原内存空间，改引用会改变原来的
循环遍历
List<Person> destList = new ArrayList<Person>(srcList);
List<Person> destList = new ArrayList<Person>();  destList.addAll(srcList); 
List<Person> destList = srcList.stream().collect(Collectors.toList());
//深拷贝，
序列化、反序列化

//遍历
for，增强for，迭代器，stream流
Iterator<String> it = list.iterator();while(it.hasNext()){sout(it.next());}
list.forEach(str-> System.out.println(str));
//排序
Collections.sort(list,(o1,o2)->o1.compareTo(o2));
//反转集合
Collections.reverse(list);
```



当用 Iterator 迭代集合时又对集合删除（list.remove()）或添加元素，会发生ConcurrentModifiedException。但调用  Iterator的 remove()  是个安全的做法。

```java
//报错
for (String i:lists) {
    if ("a".equals(i)){
        lists.remove(i);
    }
}
//正确
Iterator<String> it = lists.iterator();
        while(it.hasNext()){
            String ele = it.next();
            if ("a".equals(ele)){
                it.remove();
            }
        }
//正确
for (int i = 0; i < lists.size(); i++) {
    String ele =  lists.get(i);
    if ("a".equals(ele)){
        lists.remove(ele);
        i--;// 删除后倒退一位
    }
}
```

ArrayList 继承了 AbstractList， AbstractList 中有个**modCount** 代表了集合修改的次数，在 iterator 方法中会判断 期望修改次数 与 修改次数 是否相等，相等继续执行，不相等报错。不同于 list.remove() 只改动修改次数，Itr.remove()执行后会让 期望修改次数 与 修改次数 相等

也可使用倒序删除，for(int i=list.size()-1;i>=0;i--){  list.remove(i); }



##### set

```java
list/set.contains();
list/set.add()
//不推荐，推荐用stream流
list/set1.retainAll(set2)  //求交集，若是集合中不是基本类型而是引用则不能这样
list/set1.addAll(set2)  //求并集
list/set1.removeAll(set2) //求差集，size大的放前面。若是aa,abb，则结果为[]
    
set.remove(i) //不管i是Integer还是int都移除i元素
```



##### map

```java
//和string.intern()方法类似
map.computeIfAbsent("AA", k -> new ArrayList<>());  //如果map中有key为AA的就不插入，没有就放入。返回的是map中的。

//放入
map.put(key,map.getOrDefault(key,0)+1);

map.containsKey(t)

//遍历
map.keySet()
map.values()
for (Map.Entry<Integer, Integer> e : map.entrySet()) {e.getKey();e,getValue()}


//复制
m1.putAll(m2)
    
//清空
map.clear()
```

以下输出：isContains=false		size=1

```java
public class HashSetTest {
    public static final class Person {
        private String name = "";
        public Person(String n) {
            setName(n);
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = (name == null) ? "" : name;
        }
        @Override
        public int hashCode() {
            return name.length();
        }
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof Person)) {		//instanceOf 左边是否是右边的实例
                return false;
            }
            if (obj == this) {
                return true;
            }
            return this.name.equals(((Person) obj).name);
        }
    }
    public static void main(String[] args) {
        Set<Person> persons = new HashSet<Person>();
        Person person = new Person("nowcoder");
        persons.add(person);
        person.setName("nowcodertest");
        boolean isContains = persons.contains(person);
        int size = persons.size();
        System.out.println("isContains=" + isContains);
        System.out.println("size=" + size);
    }
}
```

HashSet的底层是HashMap，对象还是person没变，size为1，person的内容变了，hashcode也变了，为false



##### stack

```java
Stack<Integer> stack = new Stack<>();  //推荐使用 Deque<Integer> q = new LinkedList<>(); 比stack快，方法一样
s.push();  //入
s.pop();
s.peek();
//复制
Stack<Integer> stack2 = (Stack<Integer>) stack1.clone ();
```



##### queue*

```java
LinkedList<Integer> q = new LinkedList<>(); //大小可变的链表双端队列，允许元素为插入null
q.addLast();   q.addFirst()  //Dqueue有这两个方法
q.pollLast();
q.peek();    q.peekLast();
//写成List<Integer> q = new LinkedList<>()或Queue<Integer> q = new LinkedList<>();上述方法的First/last不能用，广度遍历时选用Queue，快很多
//推荐用：
Deque<Integer> q = new LinkedList<>()  //上述方法都可用且栈方法可用
    
Deque<Integer> q = new ArrayDeque<>();  //大小可变的数组双端队列，不允许插入null

Queue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>(k,(o1, o2) -> o2.getValue() - o1.getValue()); //k大小，按大顶堆排序，顶最大

q.offer();	q.add()
q.poll();	q.remove()
q.peek();
```



##### 相同方法

集合的相同方法：size()，empty()，isEmpty()

数组：length

String : contains

String/StringBuilder : length()   charAt(i)



##### 转化

```java
数组和集合：
list=Arrays.asList(arr)//返回的是一个Array的内部类，没有实现集合的方法，在对返回的集合进行增删查操作会出错，arr要为Integer类型
 <=>Arrays.asList(new Integer[]{a,b,c}); //int会报错，或直接Arrays.asList(a,b,c);
arr=list.toArray(new Int[list.size()]);
list.toArray(new int[list.size()][2])  //二维数组，List<int[]> list=...
 <=> list.toArray(new int[0][])

    
打印数组:
System.out.println(Arrays.toString(array));  //Arrays.asList(arr)
打印二维数组：Arrays.deepToString

    
String转为int：
int i=Integer.parseInt(s)；
int i=Integer.valueOf(s).intValue();
int转为String：
String s = String.valueOf(i);
String s = Integer.toString(i);
String s = “” + i;

int转char：
 char c=(char) i+'0'
char转int：
 int i=c-'0'

String和StringBuilder：
StringBuilder bu = new StringBuilder(s);
s=sb.toString();


char[] array = {'h','e','l','l','o'}; String str2 = new String(array); //将字符数组换为字符串 
带valueof 逆向：String str2 =String.valueof(array)
带to的正向：char[] array=str.toCharArray();

Integer.parseInt(String s)将会返回int常量。
Integer.valueOf(String s)将会返回Integer类型的对象。
```



#### 42、Linux

##### 1）命令

```java
javac Test.java		// 编译命令,Java 程序名字加后缀
java Test		//运行对象是Test.class（字节码文件），但不加后缀 .class

tail -f nginx.log	//打印日志
    
chmod 777 /home/test -R  // “-rwxrwxrwx”三个一组，分别表示：文件所有者owner、群组用户group、其他用户others。r读:4，w写:2，x执行:1；可读可写要大于等于6；-R表示递归的子目录
chmod +050 data    //对data目录增加用户组可读权限，但不可写。data是目录，要进入目录还要加上可执行权限。
chmod u+x file.sh    //u代表文件所有者，x代表执行权限。 + 表示增加权限。a表所有人
chown -R root:root /tmp  //将tmp下的所有文件的用户名和用户组改成root和root
    
sort Test.txt | uniq -c | sort -rn | head -n 5  //找到次数最多的前5个mac和出现的次数
或 cat Test.txt | sort | uniq -c | sort -rn | head -n 5 //uniq -c去重和统计，sort -n按第一列值从小到大排序，倒序是sort -r
    
find ./ -name XXX //查找当前目录以及子目录有没有XXX文件
ifconfig eth0  //可以使用一般身份用户执行
    
FILE *fopen(char *filename,char * mode)//Linux内核中创建一个文件  //一般创建文件使用 touch，创建文件夹使用mkdir
//可以生成/test文件的是:  
touch /test;  	
a=`touch /test`;	//表示转义，` `中的的内容会被执行	
>/test;    //表示输出重定向，没有文件则创建

cp f1.txt f2.txt    //复制
cat f1.txt > f2.txt  //复制，将f1.txt中的内容，覆盖到f2.txt中，如果是>>，则是将f1.txt中的内容，追加到f2.txt中       

#!/bin/bash;   //运行bin目录下bash，一般都是 #！开头
#-/bin/bash   //注释
    
mount -r /dev/sdb1 /tools	//对将要加载安装的文件只读。-ro是对已安装的文件只读
    
echo `expr 3/4`	 // 用于整数的加减乘除余，运算符左右要有空格，没有空格表示是字符串连接，3/4没有隔开，还是输出3/4； 3 / 4 会执行计算，为0
echo "It is a test"    //用于字符串的输出或给文字添加颜色
    
错误重定向： 2>；标准输出： >；同时实现输出和错误重定向到a.txt 文件： &>a.txt   （0，1表输入和输出，可省略） 
    
ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数
uptime命令能够打印系统总共运行了多长时间和系统的平均负载（1、5、15）
top命令可以实时动态地查看系统及 cpu 的整体运行情况
netstat命令用来打印Linux中网络系统的状态信息
export 设置环境变量
“|”符号是管道符，命令A | 命令B，作用是把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入
linux系统中，SIGSTOP与SIGKILL不可捕获
ctrl c 终止正在运行的程序； ctrl z 将前台任务转入后台，挂起一个进程； ctrl d 表示 EOF，相当于在终端中输入exit后回车
    
//
进程状态 ps，查看 cpu 状态 top。查看占用端口的进程号 netstat grep
 
    
//10g 文件，只有 2g 内存，怎么查找文件中指定的字符串出现位置:
cat | grep 管道处理
//
head -n 10 date.log     获取前40行
tail -10  date.log        输出最后20行的内容
```

##### 2）shell脚本

Shell 脚本（shell script），是一种为 shell 编写的脚本程序。

获取shell脚本参数：$1，$*         返回值$?

<img src="/image-20210928203238269.png" alt="image-20210928203238269" style="zoom: 80%;" />



```shell
可执行的test.sh文件内容为:
#!/bin/bash
aa='Hello World !'
. ./test.sh >/dev/null 1 && echo $aa  //能正常显示Hello World 
点斜杠，点空格点斜杠，两者都可以执行脚本，但第一种方式是在子进程中运行脚本，非当前进程是看不到aa变量的；第二种方式是在当前进程中执行脚本。
```

##### 3）软连接

- 链接有自己的文件属性及权限等
- **可对存在或不存在的文件或目录创建软链接**
- 创建软链接时，链接计数 i_nlink 不会增加

- 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。

##### 4）文件系统

inode描述了文件大小和指向数据块的指针，**文件名和inode号码一般是一 一对应，但Unix/Linux系统中，多个文件名可以指向同一个inode号码，意味着可用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但文件执行了删除操作之后，仍可通过之前创建的硬链接（删除一个文件名不影响另一个文件名的访问）进行正常访问**。



#### 43、java创建对象

Java有5种方式来创建对象：new和反射是通过构造函数完成，反序列化和克隆是读取别的内存区域中的对象的各个域来完成

1. 使用 new 关键字（最常用）： ObjectName obj = new ObjectName();

2. 使用反射的Class类的newInstance()方法： ObjectName obj = ObjectName.class.newInstance(); 

3. 使用反射的Constructor类的newInstance()方法： ObjectName obj = ObjectName.class.getConstructor.newInstance();

4. 使用对象克隆clone()方法： ObjectName obj = obj.clone(); 

5. 使用反序列化（ObjectInputStream）的readObject()方法：

    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) { ObjectName obj = ois.readObject(); }



#### 44、JDK8

jdk8的lambda 表达式：dir.listFiles((File f)->f.getName().endsWith(“.Java”)); 	dir.listFiles( f->f.getName().endsWith(“.Java”));



#### 45、泛型

1、创建泛型对象时最好指明具体类型，让编译器尽早的做参数检查。而不是留给JVM运行的时候抛出类不匹配的异常。 

2、 ① 虚拟机中**没有泛型，只有普通类和方法**。 ② 在**编译阶段会有类型擦除**，所有泛型类的类型参数都会被**Object或者它们的限定边界（原生类型）来替换**。③ 在继承泛型类型的时候，桥方法的合成是为了避免类型变量擦除所带来的多态灾难。**JVM通过反射可在运行时动态获取实际类型**



#### 46、递归

下面程序的输出：12136

```java
public class Main {
    public static void main(String[] args) {
        split(12);
    }
    public static int split(int number) {
        if (number > 1) {
            if (number % 2 != 0) System.out.print(split((number + 1) / 2));		//一行内部全部递归完再执行下一行，最内层的递归先输出
                System.out.print(split(number / 2));		//不管是否满足条件，第二个输出语句都会执行
            }
        return number;		
       }
}
//解析
split(12){
sout split(6) {
    sout split(3) {
        sout split(2) {
            sout split(1)
            return 2
        }
        sout split(1)
        return 3;
    }
    return 6   //输出
}
return 12   //不输出
}
```



#### 47、枚举类

输出：FIXED  +三次 It is a account type

```java
enum AccountType{
    SAVING, FIXED, CURRENT;   //在static代码块{...}中都会调用构造器创建实例且只创建一次  
    private AccountType(){
        System.out.println(“It is a account type”);
    }
}
class EnumOne{
    public static void main(String[]args){
        System.out.println(AccountType.FIXED);
    }
}	
```

枚举类实际转化为一个继承了java.lang.Enum类的实体类，会生成一个新的构造函数，若原有构造函数，则在此基础上添加两个参数String，int；所有的枚举值加上public` `static` `final；还会添加一段static代码段{...}，此枚举类有三个实例，初始化时会对所有实例调用构造方法

```java
enum SEX {
   MALE, FEMALE;}
//编译器中执行的代码如下:
public final class Sex extends Enum<Sex> {  //final表示不可再被继承  
   // 对应枚举类中的元素
   public static final Sex MALE;    
   public static final Sex FEMALE;    
   private static final Sex[] $VALUES;   
    static {        	// 调用构造函数，传入枚举元素的值及 ordinal ，都会创建实例且只创建一次   
    	MALE = new Sex("MALE", 0);    
        FEMALE = new Sex("FEMALE", 1);   
        $VALUES = new Sex[]{MALE, FEMALE}; 
   }	   
    private Sex(String name, int ordinal) {      //私有， 调用父类中的方法
        super(name, ordinal);    
    }   
    public static Sex[] values() {  
        return $VALUES.clone();  
    }
    public static Sex valueOf(String name) { 
        return Enum.valueOf(Sex.class, name);  
    }    
}
```



#### 48、Math类方法

```java
Math.floor()  表示向下取整，**返回double类型**  （floor---地板）

Math.ceil()  表示向上取整，返回double类型   （ceil---天花板）

Math.pow(a,b)  a的b次方

Math.abs(a) 绝对值，有溢出的风险，int范围：-2^32 ~ 2^32-1，Math.abs(-2147483648) 的返回值为-2147483648

Math.round()  四舍五入，**返回int类型**；负数是五舍六入（Math.round(-11.5)===》-11）

计算42度（角度）的余弦值：double d=Math.cos(Math.toRadians(42))，toRadians()将角度转换为弧度，toDegrees()将弧度转换为角度
    
java中对负数取模的结果也是负数。-8 % 5 = -3
```



#### 49、



#### 50、日志

日志的优先级（范围变小）：ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF ，Log4j建议只使用四个级别， ERROR > WARN > INFO > DEBUG。 log4j在运行期间是不可以重新设置的



应用中不可使用日志系统（Log4J、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API。使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。门面模式，又叫外观模式，它为子系统中的一组接口提供一个统一的高层接口，使的子系统更容易使用



高并发下日志的打印：

日志格式要规范，**为了方便查找问题，定位问题**。采用占位符方式，这种方式即使没有开启 Debug ，也不会产生不必要的字符串拼接

一定要用异步和缓冲模式来打印日志

```java
ogger.debug("There are now {} user accounts: {}", count, userAccountList);
logger.debug("There are now " + count + " user accounts: " + userAccountList);
```

不同级别的日志，可以定义不同日志文件名

阿里开源的 SkyWalking 分布式追踪系统，通过动态字节码技术，无侵入的实现服务之间的追踪，并提供 UI 界面查看调用链情况，非常方便



#### 51、概率

<img src="/bf096b63f6246b60ce5ef109fbf81a4c510fa27f" alt="img" style="zoom:50%;" />

`A2/5=5*4;  C2/5=5*4/2*1=10`

某盒中有 5 件产品，其中 2 件次品。现随机地从中 2 件，则 2 件中次品数的均值是：

![image-20210921112322425](/image-20210921112322425.png)



三角形的三个端点分别有一只蚂蚁，蚂蚁可以绕任意边走，蚂蚁不相撞的概率是 1/4。=2*(1/2)^3，第一只选一条特定的边要乘1/2。

分析2：共有2^3=8种选择，有两种选择满足。



#### 52、平均查找长度

设散列表的长度是13，函数为H(K) = k % 13，关键字序列为{32， 14， 23， 01， 42， 20， 45， 27， 55， 24， 10， 53}。用线性探测法和拉链法解决冲突时这两种方法平均查找长度？一般指查找成功时的

<img src="/20160418102533374" alt="img" style="zoom:50%;" />

查找成功时的查找次数等于插入元素时的比较次数, 平均查找长度为：ASL = （1+2+1+4+3+1+1+3+9+1+1+3)/12 = 2.5

查找不成功为第n个位置到第1个没有数据位置的距离，平均查找次数为：ASL = （1+2+3+4+5+6+7+8+9+10+11+12）/ 13 = 91/13

<img src="/20160418103144353" alt="img" style="zoom:50%;" />

查找成功时的平均查找长度：ASL = `(1*6+2*4+3*1+4*1)/12 = 7/4`

查找不成功时的平均查找长度：ASL = (4+2+2+1+2+1)/13

查找成功时，分母为哈希表元素个数，查找不成功时，分母为哈希表长度



#### 53、struts

**是一个web框架，基于MVC 设计模式，**struts1和struts2的区别：

Struts1要求Action类继承一个抽象基类。Struts 2 Action类可以实现一个Action接口

Struts1 Action 依赖于Servlet API，Struts 2 **Action不依赖于容器**，允许Action脱离容器单独被测试

Struts1 Action是**单例模式不安全的**，Struts2 Action对象为每一个请求产生一个实例（**多例的），没有线程安全问题**

Struts1 整合了JSTL，Struts2可以使用JSTL，但是也支持OGNL（Object Graph Notation Language）

struts项目中的类与MVC模式的对应关系：**Struts的核心是ActionSevlet，ActionSevlet的核心是Struts-config.xml**

![img](/6740262_1502892230619_8AA0BB8C0EEED931C8EE12011A5E8E1B)



#### 54、java注解

4个元注解（meta-annotation），用来对注解类型进行注解的注解类：

-  @Target	描述注解的使用范围（修饰 类、接口、枚举、注解类、类成员（方法、构造方法、成员变量、枚举值）等）
-  @Retention   描述注解保留的时间范围
-  @Documented  描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息
-  @Inherited  使被它修饰的注解具有继承性（子类将有该注解）



#### 55、网路攻击

SSRF：为服务端请求伪造(Server-Side Request Forgery)，指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。 

 CSRF ： 跨站请求伪造（Cross-site request forgery），利用的是网站对用户网页浏览器的信任。验证Content-Type来防止

XSS是跨站脚本攻击(Cross Site Scripting)，恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行。

xss攻击绕过过滤的方法：大小写绕过；过滤后返回语句再次构成攻击语句来绕过

后端获取数据，向前端输出的过程中，输出前应该采用信息安全部发布的XSSFilter进行相应编码。



对于文件上传漏洞，防御手段：服务器端限制文件扩展名（浏览器端没用）；将上传的文件存储在静态文件服务器中



分布式拒绝服务攻击(DDoS)：导致合法用户不能够访问正常网络服务的行为。解决：对于高流量访问，可以限制同时打开SYN半链接的数目。



#### 56、最短作业时间

假设某单CPU系统中有输入和输出设备各1台，现有3个并发执行的作业，每个作业的输入、 计算和输出时间均分别为2ms、3ms和4ms，且都按输入、计算和愉出的顺序执行，则执行完3 个作业的最短时间是 17ms

<img src="/image-20210922181811673.png" alt="image-20210922181811673" style="zoom:50%;" />



单核CPU执行，三个程序需要的资源如下所示：优先级高的可抢占优先级低的的CPU，但不能抢占IO。作业的最短时间是130ms。

![img](/5918115_1479368672293_16BBBC9F6DD8BF82C58F5446BA488A90)

<img src="/image-20211002222141380.png" alt="image-20211002222141380" style="zoom: 50%;" />





#### 57、深浅拷贝

如果是基本类型的拷贝，深浅拷贝都一样，都是对该字段复制。引用类型的话，浅拷贝是拷贝对象的引用地址，两个对象还是指向同一个内存地址，修改其中任意的值，另一个值会随之变化；而深拷贝是将对象地址和值都复制过来，两个对象修改其中任意的值另一个值不会改变。

浅拷贝可通过实现Cloneable接口，重写clone()方法实现；

深拷贝可通过对象实现Serializable序列化接口，用流的形式将要复制对象序列化到内存，再用反序列化readObject()方法创建；



#### 58、getClass()

object的getClass方法是返回当前运行时的类，getName()返回：包名+类名。整体返回当前类的包名.类名

```java
        ArrayList<String> l1 = new ArrayList<String>();
        ArrayList<Integer> l2 = new ArrayList<Integer>();
        l1.add("1");
        l2.add(1);
        System.out.println(l1.get(0).getClass());   //class java.lang.String
        System.out.println(l2.get(0).getClass());   //class java.lang.Integer
        System.out.println(l1.getClass() == l2.getClass());  //true ,每一个类的Class的对象有且只有一个,且有泛型擦除
		super.getClass().getName();   //调用父类的getClass方法，final方法父类也不能重写，故调用的是object的getClass方法
```



#### 59、printf 输出

相当于占位符

```java
Date date=new Date()
System.out.printf("%tD%n",date);  //  %n表换行(\t表Tab)， tD表美式日期：08/20/21，tT表24小时时间：13:20:18，tY表年：2020
int i = 1234;
String s="张三";
System.out.printf("输出一个整数：%d，一个字符串：%s", i, s);  // %d 表示输出十进制整数，%s表字符串类型，%f表浮点类型
System.out.printf("%d  %.1f\n", c, a);//c输出是整数，中间空格，a输出是保留一位小数的浮点数
```



#### 60、UML类结构图

![image-20210928181441774](/image-20210928181441774.png)



#### 61、软件开发模型

瀑布模型：**自上而下、**相互衔接的固定次序。**对于经常变化的项目而言，瀑布模型毫无价值**。清楚的区分逻辑设计与物理设计，尽可能推迟程序的物理实现，是按照瀑布模型开发软件的一条重要的指导思想。瀑布模型是文档驱动的模型，遵守这个约束可使软件维护变得比较容易一些，从而显著降低软件预算。按照瀑布模型的阶段划分，软件测试可以分为单元测试，集成测试，系统测试

<img src="/20190725130452991.png" alt="img" style="zoom: 67%;" />

快速原型模型：增量模型的另一种形式，**需求分析阶段预先不能确切定义需求。**

<img src="/20190726073429663.png" alt="img" style="zoom: 67%;" />



增量模型：**将软件的每个模块作为一个增量组件**，从而分批次地分析、设计、编码和测试这些增量组件。运用增量模型的软件开发过程是递增式的过程，必须遵守的约束条件是，当把新构件集成到现有构件中时，所形成的产品必须是可测试的。**相对于瀑布模型，增量模型不需要一次性地把整个软件产品提交给用户，而是可以分批次进行提交。**

![img](/20190725221525524.png)

螺旋模型：**强调风险分析**

![img](/20190726104625570.png)



#### 62、图片下载器

根据标题或配图寻找自己喜欢的文章，然后点击进入图文详情页或图集，请设计一个图片下载器，满足对于快速加载内容和系统流畅度的需求

异步下载图片，线程池放两三个线程下载即可，下完后缓存到内存



#### 63、运算符运算

（1） ^（异或运算XOR）：1、0二进制异或，相等为0，不等为1（true）		n^0=n ；n^n=0；		a ^ b = b ^ a；a ^ b ^ a = b；	

用途：**a^=b；b^=a；a^=b;		1^2^3^2^3=(2^2)^(3^3)^1=1**

（2）&（与运算AND）：同时为“1”，结果才为“1”，否则为0			

用途：**(n&1)==1 取最后一位是1还是0，判断奇偶。(n&1)==1和n=n>>1来取n二进制的每一位。n&(n-1)，将原来的最右边的1变为0**

取余，要求M是2次幂：**key % M = key & （M-1）**。0111010，从左边算起的第3，5，7位保留/取下来，0111010&0010101=0010000

（3）|（或运算OR） ：只要有一个为1，其值为1。

用途：将X=10100000的低4位置为1 ，用X | 0000 1111 = 1010 1111

（4）~（非门NOT）：相反



i=(i<<1)+1，要括号

(n&1)==1，要括号

c=a---b 等价于：c=(a--)-b 



-10%3 结果是 -1

#### 64、Jdk1.8新特性

函数式接口：**一个接口中只声明了一个抽象方法。**

Lambda表达式：对函数式接口实例化时可使用。形参列表只一个参数，()可省略；lambda体只一条执行语句，可能是return语句，可省略{}和return关键字

方法引用：在lambda基础上，抽象方法的参数与返回值和方法体中调用方法的参数和放回值相同时省掉参数。类(或对象) :: 方法名。对象只能非静态方法，类可（非）静态

Stream 流API：更加直观优雅，对内存中的数据进行过滤（filter）、排序（sort）、映射（map接收参数映射为新元素）、收集（collect）等操作。

集合=集合.stream.map(一个元素 -> {}).filter().collect(Collectors.toList());



#### 65、



#### 66 交换两数

```java
//a，b两数相同时会等于0，丢失这个数
a=a^b;
b=a^b;
a=a^b;
//内存溢出风险
a=b+a-(b=a);
//
int c=a;
a=b;
b=c
```



#### 67 随机数

①Math.random()，生成 [0.0,1.0）的double型数值。此方法是完全同步的，可允许多个线程使用而不出现错误

 (int) (Math.random()*(max-min))+min

② Random r = new Random(1);   //种子数，不填以当前时间为默认种子，两个random对象 如果seed相同则生成同一随机数列 （随机相同次数的话得到相同的数）

int ran1 = r.nextInt(101);   //范围是[0，100] 

一般都不直接使用Random()，并发量大的时候会对机器造成很大负担，一般都是先生成放到队列中，等需要的时候去取。



### 智力题

一个蛋糕切三刀分成四块相等的

<img src="/image-20220717233651839.png" alt="image-20220717233651839" style="zoom:50%;" />

 四辆小车，每辆车加满油可以走一公里，问怎么能让一辆小车走最远。

1. 先一起走
2. 走一段路程 s 之后，任选一辆车，把剩余的油全分给其余的车，加满。s条件：走完s之后，剩下的油要把其余的车刚好全加满
3. 重复步骤二，直到最后一辆车没油

ans=(1/1+1/2+…+1/n)*x       注：n 辆车加满油可以走 x 公里



